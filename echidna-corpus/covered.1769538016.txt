/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/ContractRegistry.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.25;
   3 |     | 
   4 |     | import {IFlareContractRegistry} from "./IFlareContractRegistry.sol";
   5 |     | // AUTO GENERATED - DO NOT EDIT BELOW THIS LINE
   6 |     | import {IPriceSubmitter} from "./IPriceSubmitter.sol";
   7 |     | import {IGovernanceSettings} from "./IGovernanceSettings.sol";
   8 |     | import {IFtsoRewardManager} from "./IFtsoRewardManager.sol";
   9 |     | import {IFtsoRegistry} from "./IFtsoRegistry.sol";
  10 |     | import {IVoterWhitelister} from "./IVoterWhitelister.sol";
  11 |     | import {IFtsoManager} from "./IFtsoManager.sol";
  12 |     | import {IWNat} from "./IWNat.sol";
  13 |     | import {IGovernanceVotePower} from "./IGovernanceVotePower.sol";
  14 |     | import {IClaimSetupManager} from "./IClaimSetupManager.sol";
  15 |     | import {IFlareAssetRegistry} from "./IFlareAssetRegistry.sol";
  16 |     | import {IFlareContractRegistry} from "./IFlareContractRegistry.sol";
  17 |     | import {ISubmission} from "./ISubmission.sol";
  18 |     | import {IEntityManager} from "./IEntityManager.sol";
  19 |     | import {IVoterRegistry} from "./IVoterRegistry.sol";
  20 |     | import {IFlareSystemsCalculator} from "./IFlareSystemsCalculator.sol";
  21 |     | import {IFlareSystemsManager} from "./IFlareSystemsManager.sol";
  22 |     | import {IRewardManager} from "./IRewardManager.sol";
  23 |     | import {IRelay} from "./IRelay.sol";
  24 |     | import {IWNatDelegationFee} from "./IWNatDelegationFee.sol";
  25 |     | import {IFtsoInflationConfigurations} from "./IFtsoInflationConfigurations.sol";
  26 |     | import {IFtsoRewardOffersManager} from "./IFtsoRewardOffersManager.sol";
  27 |     | import {IFtsoFeedDecimals} from "./IFtsoFeedDecimals.sol";
  28 |     | import {IFtsoFeedPublisher} from "./IFtsoFeedPublisher.sol";
  29 |     | import {IFtsoFeedIdConverter} from "./IFtsoFeedIdConverter.sol";
  30 |     | import {IFastUpdateIncentiveManager} from "./IFastUpdateIncentiveManager.sol";
  31 |     | import {IFastUpdater} from "./IFastUpdater.sol";
  32 |     | import {IFastUpdatesConfiguration} from "./IFastUpdatesConfiguration.sol";
  33 |     | import {IFeeCalculator} from "./IFeeCalculator.sol";
  34 |     | import {FtsoV2Interface} from "./FtsoV2Interface.sol";
  35 |     | import {TestFtsoV2Interface} from "./TestFtsoV2Interface.sol";
  36 |     | import {ProtocolsV2Interface} from "./ProtocolsV2Interface.sol";
  37 |     | import {RandomNumberV2Interface} from "./RandomNumberV2Interface.sol";
  38 |     | import {RewardsV2Interface} from "./RewardsV2Interface.sol";
  39 |     | import {IFdcVerification} from "./IFdcVerification.sol";
  40 |     | import {IFdcHub} from "./IFdcHub.sol";
  41 |     | import {IFdcRequestFeeConfigurations} from "./IFdcRequestFeeConfigurations.sol";
  42 |     | import {IAssetManagerController} from "./IAssetManagerController.sol";
  43 |     | import {IAssetManager} from "./IAssetManager.sol";
  44 |     | import {IJsonApiVerification} from "./IJsonApiVerification.sol";
  45 |     | import {IGenericRewardManager} from "./IGenericRewardManager.sol";
  46 |     | // END AUTO GENERATED - DO NOT EDIT ABOVE THIS LINE
  47 |     | 
  48 |     | // Library is intended to be used inline, so the strings are all memory allocated (instead of calldata)
  49 |     | library ContractRegistry {
  50 |     |     address internal constant FLARE_CONTRACT_REGISTRY_ADDRESS =
  51 |     |         0xaD67FE66660Fb8dFE9d6b1b4240d8650e30F6019;
  52 |     | 
  53 |     |     IFlareContractRegistry internal constant FLARE_CONTRACT_REGISTRY =
  54 |     |         IFlareContractRegistry(FLARE_CONTRACT_REGISTRY_ADDRESS);
  55 |     | 
  56 |     |     /**
  57 |     |      * @notice Returns contract address for the given name - might be address(0)
  58 |     |      * @param _name             name of the contract
  59 |     |      */
  60 |     |     function getContractAddressByName(
  61 |     |         string memory _name
  62 |     |     ) internal view returns (address) {
  63 |     |         return FLARE_CONTRACT_REGISTRY.getContractAddressByName(_name);
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @notice Returns contract address for the given name hash - might be address(0)
  68 |     |      * @param _nameHash         hash of the contract name (keccak256(abi.encode(name))
  69 |     |      */
  70 |     |     function getContractAddressByHash(
  71 |     |         bytes32 _nameHash
  72 |     |     ) internal view returns (address) {
  73 |     |         return FLARE_CONTRACT_REGISTRY.getContractAddressByHash(_nameHash);
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @notice Returns contract addresses for the given names - might be address(0)
  78 |     |      * @param _names            names of the contracts
  79 |     |      */
  80 |     |     function getContractAddressesByName(
  81 |     |         string[] memory _names
  82 |     |     ) internal view returns (address[] memory) {
  83 |     |         return FLARE_CONTRACT_REGISTRY.getContractAddressesByName(_names);
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @notice Returns contract addresses for the given name hashes - might be address(0)
  88 |     |      * @param _nameHashes       hashes of the contract names (keccak256(abi.encode(name))
  89 |     |      */
  90 |     |     function getContractAddressesByHash(
  91 |     |         bytes32[] memory _nameHashes
  92 |     |     ) internal view returns (address[] memory) {
  93 |     |         return FLARE_CONTRACT_REGISTRY.getContractAddressesByHash(_nameHashes);
  94 |     |     }
  95 |     | 
  96 |     |     /**
  97 |     |      * @notice Returns all contract names and corresponding addresses
  98 |     |      */
  99 |     |     function getAllContracts()
 100 |     |         internal
 101 |     |         view
 102 |     |         returns (string[] memory _names, address[] memory _addresses)
 103 |     |     {
 104 |     |         return FLARE_CONTRACT_REGISTRY.getAllContracts();
 105 |     |     }
 106 |     | 
 107 |     |     // Nice typed getters for all the important contracts
 108 |     |     // AUTO GENERATED - DO NOT EDIT BELOW THIS LINE
 109 |     |     function getPriceSubmitter() internal view returns (IPriceSubmitter) {
 110 |     |         return
 111 |     |             IPriceSubmitter(
 112 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 113 |     |                     keccak256(abi.encode("PriceSubmitter"))
 114 |     |                 )
 115 |     |             );
 116 |     |     }
 117 |     | 
 118 |     |     function getGovernanceSettings()
 119 |     |         internal
 120 |     |         view
 121 |     |         returns (IGovernanceSettings)
 122 |     |     {
 123 |     |         return
 124 |     |             IGovernanceSettings(
 125 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 126 |     |                     keccak256(abi.encode("GovernanceSettings"))
 127 |     |                 )
 128 |     |             );
 129 |     |     }
 130 |     | 
 131 |     |     function getFtsoRewardManager() internal view returns (IFtsoRewardManager) {
 132 |     |         return
 133 |     |             IFtsoRewardManager(
 134 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 135 |     |                     keccak256(abi.encode("FtsoRewardManager"))
 136 |     |                 )
 137 |     |             );
 138 |     |     }
 139 |     | 
 140 |     |     function getFtsoRegistry() internal view returns (IFtsoRegistry) {
 141 |     |         return
 142 |     |             IFtsoRegistry(
 143 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 144 |     |                     keccak256(abi.encode("FtsoRegistry"))
 145 |     |                 )
 146 |     |             );
 147 |     |     }
 148 |     | 
 149 |     |     function getVoterWhitelister() internal view returns (IVoterWhitelister) {
 150 |     |         return
 151 |     |             IVoterWhitelister(
 152 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 153 |     |                     keccak256(abi.encode("VoterWhitelister"))
 154 |     |                 )
 155 |     |             );
 156 |     |     }
 157 |     | 
 158 |     |     function getFtsoManager() internal view returns (IFtsoManager) {
 159 |     |         return
 160 |     |             IFtsoManager(
 161 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 162 |     |                     keccak256(abi.encode("FtsoManager"))
 163 |     |                 )
 164 |     |             );
 165 |     |     }
 166 |     | 
 167 |     |     function getWNat() internal view returns (IWNat) {
 168 |     |         return
 169 |     |             IWNat(
 170 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 171 |     |                     keccak256(abi.encode("WNat"))
 172 |     |                 )
 173 |     |             );
 174 |     |     }
 175 |     | 
 176 |     |     function getGovernanceVotePower()
 177 |     |         internal
 178 |     |         view
 179 |     |         returns (IGovernanceVotePower)
 180 |     |     {
 181 |     |         return
 182 |     |             IGovernanceVotePower(
 183 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 184 |     |                     keccak256(abi.encode("GovernanceVotePower"))
 185 |     |                 )
 186 |     |             );
 187 |     |     }
 188 |     | 
 189 |     |     function getClaimSetupManager() internal view returns (IClaimSetupManager) {
 190 |     |         return
 191 |     |             IClaimSetupManager(
 192 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 193 |     |                     keccak256(abi.encode("ClaimSetupManager"))
 194 |     |                 )
 195 |     |             );
 196 |     |     }
 197 |     | 
 198 |     |     function getFlareAssetRegistry()
 199 |     |         internal
 200 |     |         view
 201 |     |         returns (IFlareAssetRegistry)
 202 |     |     {
 203 |     |         return
 204 |     |             IFlareAssetRegistry(
 205 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 206 |     |                     keccak256(abi.encode("FlareAssetRegistry"))
 207 |     |                 )
 208 |     |             );
 209 |     |     }
 210 |     | 
 211 |     |     function getFlareContractRegistry()
 212 |     |         internal
 213 |     |         view
 214 |     |         returns (IFlareContractRegistry)
 215 |     |     {
 216 |     |         return
 217 |     |             IFlareContractRegistry(
 218 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 219 |     |                     keccak256(abi.encode("FlareContractRegistry"))
 220 |     |                 )
 221 |     |             );
 222 |     |     }
 223 |     | 
 224 |     |     function getSubmission() internal view returns (ISubmission) {
 225 |     |         return
 226 |     |             ISubmission(
 227 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 228 |     |                     keccak256(abi.encode("Submission"))
 229 |     |                 )
 230 |     |             );
 231 |     |     }
 232 |     | 
 233 |     |     function getEntityManager() internal view returns (IEntityManager) {
 234 |     |         return
 235 |     |             IEntityManager(
 236 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 237 |     |                     keccak256(abi.encode("EntityManager"))
 238 |     |                 )
 239 |     |             );
 240 |     |     }
 241 |     | 
 242 |     |     function getVoterRegistry() internal view returns (IVoterRegistry) {
 243 |     |         return
 244 |     |             IVoterRegistry(
 245 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 246 |     |                     keccak256(abi.encode("VoterRegistry"))
 247 |     |                 )
 248 |     |             );
 249 |     |     }
 250 |     | 
 251 |     |     function getFlareSystemsCalculator()
 252 |     |         internal
 253 |     |         view
 254 |     |         returns (IFlareSystemsCalculator)
 255 |     |     {
 256 |     |         return
 257 |     |             IFlareSystemsCalculator(
 258 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 259 |     |                     keccak256(abi.encode("FlareSystemsCalculator"))
 260 |     |                 )
 261 |     |             );
 262 |     |     }
 263 |     | 
 264 |     |     function getFlareSystemsManager()
 265 |     |         internal
 266 |     |         view
 267 |     |         returns (IFlareSystemsManager)
 268 |     |     {
 269 |     |         return
 270 |     |             IFlareSystemsManager(
 271 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 272 |     |                     keccak256(abi.encode("FlareSystemsManager"))
 273 |     |                 )
 274 |     |             );
 275 |     |     }
 276 |     | 
 277 |     |     function getRewardManager() internal view returns (IRewardManager) {
 278 |     |         return
 279 |     |             IRewardManager(
 280 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 281 |     |                     keccak256(abi.encode("RewardManager"))
 282 |     |                 )
 283 |     |             );
 284 |     |     }
 285 |     | 
 286 |     |     function getRelay() internal view returns (IRelay) {
 287 |     |         return
 288 |     |             IRelay(
 289 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 290 |     |                     keccak256(abi.encode("Relay"))
 291 |     |                 )
 292 |     |             );
 293 |     |     }
 294 |     | 
 295 |     |     function getWNatDelegationFee() internal view returns (IWNatDelegationFee) {
 296 |     |         return
 297 |     |             IWNatDelegationFee(
 298 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 299 |     |                     keccak256(abi.encode("WNatDelegationFee"))
 300 |     |                 )
 301 |     |             );
 302 |     |     }
 303 |     | 
 304 |     |     function getFtsoInflationConfigurations()
 305 |     |         internal
 306 |     |         view
 307 |     |         returns (IFtsoInflationConfigurations)
 308 |     |     {
 309 |     |         return
 310 |     |             IFtsoInflationConfigurations(
 311 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 312 |     |                     keccak256(abi.encode("FtsoInflationConfigurations"))
 313 |     |                 )
 314 |     |             );
 315 |     |     }
 316 |     | 
 317 |     |     function getFtsoRewardOffersManager()
 318 |     |         internal
 319 |     |         view
 320 |     |         returns (IFtsoRewardOffersManager)
 321 |     |     {
 322 |     |         return
 323 |     |             IFtsoRewardOffersManager(
 324 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 325 |     |                     keccak256(abi.encode("FtsoRewardOffersManager"))
 326 |     |                 )
 327 |     |             );
 328 |     |     }
 329 |     | 
 330 |     |     function getFtsoFeedDecimals() internal view returns (IFtsoFeedDecimals) {
 331 |     |         return
 332 |     |             IFtsoFeedDecimals(
 333 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 334 |     |                     keccak256(abi.encode("FtsoFeedDecimals"))
 335 |     |                 )
 336 |     |             );
 337 |     |     }
 338 |     | 
 339 |     |     function getFtsoFeedPublisher() internal view returns (IFtsoFeedPublisher) {
 340 |     |         return
 341 |     |             IFtsoFeedPublisher(
 342 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 343 |     |                     keccak256(abi.encode("FtsoFeedPublisher"))
 344 |     |                 )
 345 |     |             );
 346 |     |     }
 347 |     | 
 348 |     |     function getFtsoFeedIdConverter()
 349 |     |         internal
 350 |     |         view
 351 |     |         returns (IFtsoFeedIdConverter)
 352 |     |     {
 353 |     |         return
 354 |     |             IFtsoFeedIdConverter(
 355 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 356 |     |                     keccak256(abi.encode("FtsoFeedIdConverter"))
 357 |     |                 )
 358 |     |             );
 359 |     |     }
 360 |     | 
 361 |     |     function getFastUpdateIncentiveManager()
 362 |     |         internal
 363 |     |         view
 364 |     |         returns (IFastUpdateIncentiveManager)
 365 |     |     {
 366 |     |         return
 367 |     |             IFastUpdateIncentiveManager(
 368 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 369 |     |                     keccak256(abi.encode("FastUpdateIncentiveManager"))
 370 |     |                 )
 371 |     |             );
 372 |     |     }
 373 |     | 
 374 |     |     function getFastUpdater() internal view returns (IFastUpdater) {
 375 |     |         return
 376 |     |             IFastUpdater(
 377 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 378 |     |                     keccak256(abi.encode("FastUpdater"))
 379 |     |                 )
 380 |     |             );
 381 |     |     }
 382 |     | 
 383 |     |     function getFastUpdatesConfiguration()
 384 |     |         internal
 385 |     |         view
 386 |     |         returns (IFastUpdatesConfiguration)
 387 |     |     {
 388 |     |         return
 389 |     |             IFastUpdatesConfiguration(
 390 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 391 |     |                     keccak256(abi.encode("FastUpdatesConfiguration"))
 392 |     |                 )
 393 |     |             );
 394 |     |     }
 395 |     | 
 396 |     |     function getFeeCalculator() internal view returns (IFeeCalculator) {
 397 |     |         return
 398 |     |             IFeeCalculator(
 399 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 400 |     |                     keccak256(abi.encode("FeeCalculator"))
 401 |     |                 )
 402 |     |             );
 403 |     |     }
 404 |     | 
 405 |     |     function getFtsoV2() internal view returns (FtsoV2Interface) {
 406 |     |         return
 407 |     |             FtsoV2Interface(
 408 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 409 |     |                     keccak256(abi.encode("FtsoV2"))
 410 |     |                 )
 411 |     |             );
 412 |     |     }
 413 |     | 
 414 |     |     function getTestFtsoV2() internal view returns (TestFtsoV2Interface) {
 415 |     |         return
 416 |     |             TestFtsoV2Interface(
 417 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 418 |     |                     keccak256(abi.encode("FtsoV2"))
 419 |     |                 )
 420 |     |             );
 421 |     |     }
 422 |     | 
 423 |     |     function getProtocolsV2() internal view returns (ProtocolsV2Interface) {
 424 |     |         return
 425 |     |             ProtocolsV2Interface(
 426 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 427 |     |                     keccak256(abi.encode("ProtocolsV2"))
 428 |     |                 )
 429 |     |             );
 430 |     |     }
 431 |     | 
 432 |     |     function getRandomNumberV2()
 433 |     |         internal
 434 |     |         view
 435 |     |         returns (RandomNumberV2Interface)
 436 |     |     {
 437 |     |         return
 438 |     |             RandomNumberV2Interface(
 439 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 440 |     |                     keccak256(abi.encode("RandomNumberV2"))
 441 |     |                 )
 442 |     |             );
 443 |     |     }
 444 |     | 
 445 |     |     function getRewardsV2() internal view returns (RewardsV2Interface) {
 446 |     |         return
 447 |     |             RewardsV2Interface(
 448 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 449 |     |                     keccak256(abi.encode("RewardsV2"))
 450 |     |                 )
 451 |     |             );
 452 |     |     }
 453 |     | 
 454 |     |     function getFdcVerification() internal view returns (IFdcVerification) {
 455 |     |         return
 456 |     |             IFdcVerification(
 457 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 458 |     |                     keccak256(abi.encode("FdcVerification"))
 459 |     |                 )
 460 |     |             );
 461 |     |     }
 462 |     | 
 463 |     |     function getFdcHub() internal view returns (IFdcHub) {
 464 |     |         return
 465 |     |             IFdcHub(
 466 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 467 |     |                     keccak256(abi.encode("FdcHub"))
 468 |     |                 )
 469 |     |             );
 470 |     |     }
 471 |     | 
 472 |     |     function getFdcRequestFeeConfigurations()
 473 |     |         internal
 474 |     |         view
 475 |     |         returns (IFdcRequestFeeConfigurations)
 476 |     |     {
 477 |     |         return
 478 |     |             IFdcRequestFeeConfigurations(
 479 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 480 |     |                     keccak256(abi.encode("FdcRequestFeeConfigurations"))
 481 |     |                 )
 482 |     |             );
 483 |     |     }
 484 |     | 
 485 |     |     function getAssetManagerController()
 486 |     |         internal
 487 |     |         view
 488 |     |         returns (IAssetManagerController)
 489 |     |     {
 490 |     |         return
 491 |     |             IAssetManagerController(
 492 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 493 |     |                     keccak256(abi.encode("AssetManagerController"))
 494 |     |                 )
 495 |     |             );
 496 |     |     }
 497 |     | 
 498 |     |     function getAssetManagerFXRP() internal view returns (IAssetManager) {
 499 |     |         return
 500 |     |             IAssetManager(
 501 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 502 |     |                     keccak256(abi.encode("AssetManagerFXRP"))
 503 |     |                 )
 504 |     |             );
 505 |     |     }
 506 |     | 
 507 |     |     function auxiliaryGetIJsonApiVerification()
 508 |     |         internal
 509 |     |         pure
 510 |     |         returns (IJsonApiVerification)
 511 |     |     {
 512 |     |         return IJsonApiVerification(0x07ad8508C9173DC845817472Ca0484035AbFA3c8);
 513 |     |     }
 514 |     | 
 515 |     |     function getValidatorRewardManager()
 516 |     |         internal
 517 |     |         view
 518 |     |         returns (IGenericRewardManager)
 519 |     |     {
 520 |     |         return
 521 |     |             IGenericRewardManager(
 522 |     |                 FLARE_CONTRACT_REGISTRY.getContractAddressByHash(
 523 |     |                     keccak256(abi.encode("ValidatorRewardManager"))
 524 |     |                 )
 525 |     |             );
 526 |     |     }
 527 |     | 
 528 |     |     // END AUTO GENERATED - DO NOT EDIT ABOVE THIS LINE
 529 |     | }
 530 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/FtsoV2Interface.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | /**
   5 |     |  * FtsoV2 long term support interface.
   6 |     |  */
   7 |     | interface FtsoV2Interface {
   8 |     |     /// Feed data structure
   9 |     |     struct FeedData {
  10 |     |         uint32 votingRoundId;
  11 |     |         bytes21 id;
  12 |     |         int32 value;
  13 |     |         uint16 turnoutBIPS;
  14 |     |         int8 decimals;
  15 |     |     }
  16 |     | 
  17 |     |     /// Feed data with proof structure
  18 |     |     struct FeedDataWithProof {
  19 |     |         bytes32[] proof;
  20 |     |         FeedData body;
  21 |     |     }
  22 |     | 
  23 |     |     /// Feed id change structure
  24 |     |     struct FeedIdChange {
  25 |     |         bytes21 oldFeedId;
  26 |     |         bytes21 newFeedId;
  27 |     |     }
  28 |     | 
  29 |     |     /// Event emitted when a feed id is changed (e.g. feed renamed).
  30 |     |     event FeedIdChanged(bytes21 indexed oldFeedId, bytes21 indexed newFeedId);
  31 |     | 
  32 |     |     /**
  33 |     |      * Returns the FTSO protocol id.
  34 |     |      */
  35 |     |     function getFtsoProtocolId() external view returns (uint256);
  36 |     | 
  37 |     |     /**
  38 |     |      * Returns the list of supported feed ids (currently active feed ids).
  39 |     |      * To get the list of all available feed ids, combine with `getFeedIdChanges()`.
  40 |     |      * @return _feedIds The list of supported feed ids.
  41 |     |      */
  42 |     |     function getSupportedFeedIds()
  43 |     |         external
  44 |     |         view
  45 |     |         returns (bytes21[] memory _feedIds);
  46 |     | 
  47 |     |     /**
  48 |     |      * Returns the list of feed id changes.
  49 |     |      * @return _feedIdChanges The list of changed feed id pairs (old and new feed id).
  50 |     |      */
  51 |     |     function getFeedIdChanges()
  52 |     |         external
  53 |     |         view
  54 |     |         returns (FeedIdChange[] memory _feedIdChanges);
  55 |     | 
  56 |     |     /**
  57 |     |      * Calculates the fee for fetching a feed.
  58 |     |      * @param _feedId The id of the feed.
  59 |     |      * @return _fee The fee for fetching the feed.
  60 |     |      */
  61 |     |     function calculateFeeById(
  62 |     |         bytes21 _feedId
  63 |     |     ) external view returns (uint256 _fee);
  64 |     | 
  65 |     |     /**
  66 |     |      * Calculates the fee for fetching feeds.
  67 |     |      * @param _feedIds The list of feed ids.
  68 |     |      * @return _fee The fee for fetching the feeds.
  69 |     |      */
  70 |     |     function calculateFeeByIds(
  71 |     |         bytes21[] memory _feedIds
  72 |     |     ) external view returns (uint256 _fee);
  73 |     | 
  74 |     |     /**
  75 |     |      * Returns stored data of a feed.
  76 |     |      * A fee (calculated by the FeeCalculator contract) may need to be paid.
  77 |     |      * @param _feedId The id of the feed.
  78 |     |      * @return _value The value for the requested feed.
  79 |     |      * @return _decimals The decimal places for the requested feed.
  80 |     |      * @return _timestamp The timestamp of the last update.
  81 |     |      */
  82 |     |     function getFeedById(
  83 |     |         bytes21 _feedId
  84 |     |     )
  85 |     |         external
  86 |     |         payable
  87 |     |         returns (uint256 _value, int8 _decimals, uint64 _timestamp);
  88 |     | 
  89 |     |     /**
  90 |     |      * Returns stored data of each feed.
  91 |     |      * A fee (calculated by the FeeCalculator contract) may need to be paid.
  92 |     |      * @param _feedIds The list of feed ids.
  93 |     |      * @return _values The list of values for the requested feeds.
  94 |     |      * @return _decimals The list of decimal places for the requested feeds.
  95 |     |      * @return _timestamp The timestamp of the last update.
  96 |     |      */
  97 |     |     function getFeedsById(
  98 |     |         bytes21[] memory _feedIds
  99 |     |     )
 100 |     |         external
 101 |     |         payable
 102 |     |         returns (
 103 |     |             uint256[] memory _values,
 104 |     |             int8[] memory _decimals,
 105 |     |             uint64 _timestamp
 106 |     |         );
 107 |     | 
 108 |     |     /**
 109 |     |      * Returns value in wei and timestamp of a feed.
 110 |     |      * A fee (calculated by the FeeCalculator contract) may need to be paid.
 111 |     |      * @param _feedId The id of the feed.
 112 |     |      * @return _value The value for the requested feed in wei (i.e. with 18 decimal places).
 113 |     |      * @return _timestamp The timestamp of the last update.
 114 |     |      */
 115 |     |     function getFeedByIdInWei(
 116 |     |         bytes21 _feedId
 117 |     |     ) external payable returns (uint256 _value, uint64 _timestamp);
 118 |     | 
 119 |     |     /** Returns value of each feed and a timestamp.
 120 |     |      * For some feeds, a fee (calculated by the FeeCalculator contract) may need to be paid.
 121 |     |      * @param _feedIds Ids of the feeds.
 122 |     |      * @return _values The list of values for the requested feeds in wei (i.e. with 18 decimal places).
 123 |     |      * @return _timestamp The timestamp of the last update.
 124 |     |      */
 125 |     |     function getFeedsByIdInWei(
 126 |     |         bytes21[] memory _feedIds
 127 |     |     ) external payable returns (uint256[] memory _values, uint64 _timestamp);
 128 |     | 
 129 |     |     /**
 130 |     |      * Checks if the feed data is valid (i.e. is part of the confirmed Merkle tree).
 131 |     |      * @param _feedData Structure containing data about the feed (FeedData structure) and Merkle proof.
 132 |     |      * @return true if the feed data is valid.
 133 |     |      */
 134 |     |     function verifyFeedData(
 135 |     |         FeedDataWithProof calldata _feedData
 136 |     |     ) external view returns (bool);
 137 |     | }
 138 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IAddressValidity.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * @custom:name IAddressValidity
  6 |     |  * @custom:id 0x05
  7 |     |  * @custom:supported BTC, DOGE, XRP
  8 |     |  * @author Flare
  9 |     |  * @notice An assertion whether a string represents a valid address on an external chain.
 10 |     |  * @custom:verification The address is checked against all validity criteria of the chain with `sourceId`.
 11 |     |  * Indicator of validity is provided.
 12 |     |  * If the address is valid, its standard form and standard hash are computed.
 13 |     |  * Validity criteria for each supported chain:
 14 |     |  * - [BTC](/specs/attestations/external-chains/address-validity/BTC.md)
 15 |     |  * - [DOGE](/specs/attestations/external-chains/address-validity/DOGE.md)
 16 |     |  * - [XRPL](/specs/attestations/external-chains/address-validity/XRPL.md)
 17 |     |  * @custom:lut `0xffffffffffffffff` ($2^{64}-1$ in hex)
 18 |     |  * @custom:lutlimit `0xffffffffffffffff`, `0xffffffffffffffff`, `0xffffffffffffffff`
 19 |     |  */
 20 |     | interface IAddressValidity {
 21 |     |     /**
 22 |     |      * @notice Toplevel request
 23 |     |      * @param attestationType ID of the attestation type.
 24 |     |      * @param sourceId Id of the data source.
 25 |     |      * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.
 26 |     |      * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.
 27 |     |      */
 28 |     |     struct Request {
 29 |     |         bytes32 attestationType;
 30 |     |         bytes32 sourceId;
 31 |     |         bytes32 messageIntegrityCode;
 32 |     |         RequestBody requestBody;
 33 |     |     }
 34 |     | 
 35 |     |     /**
 36 |     |      * @notice Toplevel response
 37 |     |      * @param attestationType Extracted from the request.
 38 |     |      * @param sourceId Extracted from the request.
 39 |     |      * @param votingRound The ID of the State Connector round in which the request was considered.
 40 |     |      * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
 41 |     |      * @param requestBody Extracted from the request.
 42 |     |      * @param responseBody Data defining the response. The verification rules for the construction of the
 43 |     |      * response body and the type are defined per specific `attestationType`.
 44 |     |      */
 45 |     |     struct Response {
 46 |     |         bytes32 attestationType;
 47 |     |         bytes32 sourceId;
 48 |     |         uint64 votingRound;
 49 |     |         uint64 lowestUsedTimestamp;
 50 |     |         RequestBody requestBody;
 51 |     |         ResponseBody responseBody;
 52 |     |     }
 53 |     | 
 54 |     |     /**
 55 |     |      * @notice Toplevel proof
 56 |     |      * @param merkleProof Merkle proof corresponding to the attestation response.
 57 |     |      * @param data Attestation response.
 58 |     |      */
 59 |     |     struct Proof {
 60 |     |         bytes32[] merkleProof;
 61 |     |         Response data;
 62 |     |     }
 63 |     | 
 64 |     |     /**
 65 |     |      * @notice Request body for IAddressValidity attestation type
 66 |     |      * @param addressStr Address to be verified.
 67 |     |      */
 68 |     |     struct RequestBody {
 69 |     |         string addressStr;
 70 |     |     }
 71 |     | 
 72 |     |     /**
 73 |     |      * @notice Response body for IAddressValidity attestation type
 74 |     |      * @param isValid Boolean indicator of the address validity.
 75 |     |      * @param standardAddress If `isValid`, standard form of the validated address. Otherwise an empty string.
 76 |     |      * @param standardAddressHash If `isValid`, standard address hash of the validated address.
 77 |     |      * Otherwise a zero bytes32 string.
 78 |     |      */
 79 |     |     struct ResponseBody {
 80 |     |         bool isValid;
 81 |     |         string standardAddress;
 82 |     |         bytes32 standardAddressHash;
 83 |     |     }
 84 |     | }
 85 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IAddressValidityVerification.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "./IAddressValidity.sol";
  5 |     | 
  6 |     | interface IAddressValidityVerification {
  7 |     |     function verifyAddressValidity(
  8 |     |         IAddressValidity.Proof calldata _proof
  9 |     |     ) external view returns (bool _proved);
 10 |     | }
 11 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IAgentAlwaysAllowedMinters.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | interface IAgentAlwaysAllowedMinters {
  5 |     |     function addAlwaysAllowedMinterForAgent(
  6 |     |         address _agentVault,
  7 |     |         address _minter
  8 |     |     ) external;
  9 |     | 
 10 |     |     function removeAlwaysAllowedMinterForAgent(
 11 |     |         address _agentVault,
 12 |     |         address _minter
 13 |     |     ) external;
 14 |     | 
 15 |     |     function alwaysAllowedMintersForAgent(
 16 |     |         address _agentVault
 17 |     |     ) external view returns (address[] memory);
 18 |     | }
 19 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IAgentPing.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | interface IAgentPing {
  5 |     |     /**
  6 |     |      * Agent bot liveness check.
  7 |     |      * @param agentVault the agent vault whose owner bot to ping
  8 |     |      * @param sender the account that triggered ping; helps bot decide whether it is important to answer
  9 |     |      * @param query off-chain defined id of the query
 10 |     |      */
 11 |     |     event AgentPing(
 12 |     |         address indexed agentVault,
 13 |     |         address indexed sender,
 14 |     |         uint256 query
 15 |     |     );
 16 |     | 
 17 |     |     /**
 18 |     |      * Response to agent bot liveness check.
 19 |     |      * @param agentVault the pinged agent vault
 20 |     |      * @param owner owner of the agent vault (management address)
 21 |     |      * @param query repeated `query` from the AgentPing event
 22 |     |      * @param response response data to the query
 23 |     |      */
 24 |     |     event AgentPingResponse(
 25 |     |         address indexed agentVault,
 26 |     |         address indexed owner,
 27 |     |         uint256 query,
 28 |     |         string response
 29 |     |     );
 30 |     | 
 31 |     |     /**
 32 |     |      * Used for liveness checks, simply emits AgentPing event.
 33 |     |      * @param _agentVault the agent vault whose owner bot to ping
 34 |     |      * @param _query off-chain defined id of the query
 35 |     |      */
 36 |     |     function agentPing(address _agentVault, uint256 _query) external;
 37 |     | 
 38 |     |     /**
 39 |     |      * Used for liveness checks, the bot's response to AgentPing event.
 40 |     |      * Simply emits AgentPingResponse event identifying the owner.
 41 |     |      * NOTE: may only be called by the agent vault owner
 42 |     |      * @param _agentVault the pinged agent vault
 43 |     |      * @param _query repeated `_query` from the agentPing
 44 |     |      * @param _response response data to the query
 45 |     |      */
 46 |     |     function agentPingResponse(
 47 |     |         address _agentVault,
 48 |     |         uint256 _query,
 49 |     |         string memory _response
 50 |     |     ) external;
 51 |     | }
 52 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IAssetManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | import {IConfirmedBlockHeightExists, IPayment, IAddressValidity, IReferencedPaymentNonexistence, IBalanceDecreasingTransaction} from ".//IFdcVerification.sol";
   5 |     | import {IERC165} from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
   6 |     | import {IDiamondLoupe} from "./diamond/interfaces/IDiamondLoupe.sol";
   7 |     | import {AssetManagerSettings} from "./data/AssetManagerSettings.sol";
   8 |     | import {CollateralType} from "./data/CollateralType.sol";
   9 |     | import {AgentInfo} from "./data/AgentInfo.sol";
  10 |     | import {AgentSettings} from "./data/AgentSettings.sol";
  11 |     | import {AvailableAgentInfo} from "./data/AvailableAgentInfo.sol";
  12 |     | import {RedemptionTicketInfo} from "./data/RedemptionTicketInfo.sol";
  13 |     | import {RedemptionRequestInfo} from "./data/RedemptionRequestInfo.sol";
  14 |     | import {CollateralReservationInfo} from "./data/CollateralReservationInfo.sol";
  15 |     | import {EmergencyPause} from "./data/EmergencyPause.sol";
  16 |     | import {IAssetManagerEvents} from "./IAssetManagerEvents.sol";
  17 |     | import {IAgentPing} from "./IAgentPing.sol";
  18 |     | import {IRedemptionTimeExtension} from "./IRedemptionTimeExtension.sol";
  19 |     | import {ICoreVaultClient} from "./ICoreVaultClient.sol";
  20 |     | import {ICoreVaultClientSettings} from "./ICoreVaultClientSettings.sol";
  21 |     | import {IAgentAlwaysAllowedMinters} from "./IAgentAlwaysAllowedMinters.sol";
  22 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  23 |     | 
  24 |     | /**
  25 |     |  * Asset manager publicly callable methods.
  26 |     |  */
  27 |     | interface IAssetManager is
  28 |     |     IERC165,
  29 |     |     IDiamondLoupe,
  30 |     |     IAssetManagerEvents,
  31 |     |     IAgentPing,
  32 |     |     IRedemptionTimeExtension,
  33 |     |     ICoreVaultClient,
  34 |     |     ICoreVaultClientSettings,
  35 |     |     IAgentAlwaysAllowedMinters
  36 |     | {
  37 |     |     ////////////////////////////////////////////////////////////////////////////////////
  38 |     |     // Basic system information
  39 |     | 
  40 |     |     /**
  41 |     |      * Get the asset manager controller, the only address that can change settings.
  42 |     |      * Asset manager must be attached to the asset manager controller in the system contract registry.
  43 |     |      */
  44 |     |     function assetManagerController() external view returns (address);
  45 |     | 
  46 |     |     /**
  47 |     |      * Get the f-asset contract managed by this asset manager instance.
  48 |     |      */
  49 |     |     function fAsset() external view returns (IERC20);
  50 |     | 
  51 |     |     /**
  52 |     |      * Get the price reader contract used by this asset manager instance.
  53 |     |      */
  54 |     |     function priceReader() external view returns (address);
  55 |     | 
  56 |     |     /**
  57 |     |      * Return lot size in UBA (underlying base amount - smallest amount on underlying chain, e.g. satoshi).
  58 |     |      */
  59 |     |     function lotSize() external view returns (uint256 _lotSizeUBA);
  60 |     | 
  61 |     |     /**
  62 |     |      * Return asset minting granularity - smallest unit of f-asset stored internally
  63 |     |      * within this asset manager instance.
  64 |     |      */
  65 |     |     function assetMintingGranularityUBA() external view returns (uint256);
  66 |     | 
  67 |     |     /**
  68 |     |      * Return asset minting decimals - the number of decimals of precision for minting.
  69 |     | 
  70 |     |      */
  71 |     |     function assetMintingDecimals() external view returns (uint256);
  72 |     | 
  73 |     |     ////////////////////////////////////////////////////////////////////////////////////
  74 |     |     // System settings
  75 |     | 
  76 |     |     /**
  77 |     |      * Get complete current settings.
  78 |     |      * @return the current settings
  79 |     |      */
  80 |     |     function getSettings()
  81 |     |         external
  82 |     |         view
  83 |     |         returns (AssetManagerSettings.Data memory);
  84 |     | 
  85 |     |     /**
  86 |     |      * When `controllerAttached` is true, asset manager has been added to the asset manager controller.
  87 |     |      * This is required for the asset manager to be operational (create agent and minting don't work otherwise).
  88 |     |      */
  89 |     |     function controllerAttached() external view returns (bool);
  90 |     | 
  91 |     |     ////////////////////////////////////////////////////////////////////////////////////
  92 |     |     // Emergency pause
  93 |     | 
  94 |     |     /**
  95 |     |      * If true, the system is in emergency pause mode and most operations (mint, redeem, liquidate) are disabled.
  96 |     |      */
  97 |     |     function emergencyPaused() external view returns (bool);
  98 |     | 
  99 |     |     /**
 100 |     |      * Emergency pause level defines which operations are paused:
 101 |     |      * NONE - pause is not active,
 102 |     |      * START_OPERATIONS - prevent starting mint, redeem, liquidation (start/liquidate) and core vault transfer/return,
 103 |     |      * FULL - everything from START_OPERATIONS, plus prevent finishing or defulating already started mints and redeems,
 104 |     |      * FULL_AND_TRANSFER - everything from FULL, plus prevent FAsset transfers.
 105 |     |      */
 106 |     |     function emergencyPauseLevel() external view returns (EmergencyPause.Level);
 107 |     | 
 108 |     |     /**
 109 |     |      * The time when emergency pause mode will end automatically.
 110 |     |      */
 111 |     |     function emergencyPausedUntil() external view returns (uint256);
 112 |     | 
 113 |     |     ////////////////////////////////////////////////////////////////////////////////////
 114 |     |     // Asset manager upgrading state
 115 |     | 
 116 |     |     /**
 117 |     |      * True if the asset manager is paused.
 118 |     |      * In the paused state, minting is disabled, but all other operations (e.g. redemptions, liquidation) still work.
 119 |     |      * Paused asset manager can be later unpaused.
 120 |     |      */
 121 |     |     function mintingPaused() external view returns (bool);
 122 |     | 
 123 |     |     ////////////////////////////////////////////////////////////////////////////////////
 124 |     |     // Timekeeping for underlying chain
 125 |     | 
 126 |     |     /**
 127 |     |      * Prove that a block with given number and timestamp exists and
 128 |     |      * update the current underlying block info if the provided data is higher.
 129 |     |      * This method should be called by minters before minting and by agent's regularly
 130 |     |      * to prevent current block being too outdated, which gives too short time for
 131 |     |      * minting or redemption payment.
 132 |     |      * NOTE: anybody can call.
 133 |     |      * @param _proof proof that a block with given number and timestamp exists
 134 |     |      */
 135 |     |     function updateCurrentBlock(
 136 |     |         IConfirmedBlockHeightExists.Proof calldata _proof
 137 |     |     ) external;
 138 |     | 
 139 |     |     /**
 140 |     |      * Get block number and timestamp of the current underlying block known to the f-asset system.
 141 |     |      * @return _blockNumber current underlying block number tracked by asset manager
 142 |     |      * @return _blockTimestamp current underlying block timestamp tracked by asset manager
 143 |     |      * @return _lastUpdateTs the timestamp on this chain when the current underlying block was last updated
 144 |     |      */
 145 |     |     function currentUnderlyingBlock()
 146 |     |         external
 147 |     |         view
 148 |     |         returns (
 149 |     |             uint256 _blockNumber,
 150 |     |             uint256 _blockTimestamp,
 151 |     |             uint256 _lastUpdateTs
 152 |     |         );
 153 |     | 
 154 |     |     ////////////////////////////////////////////////////////////////////////////////////
 155 |     |     // Available collateral types
 156 |     | 
 157 |     |     /**
 158 |     |      * Get collateral  information about a token.
 159 |     |      */
 160 |     |     function getCollateralType(
 161 |     |         CollateralType.Class _collateralClass,
 162 |     |         IERC20 _token
 163 |     |     ) external view returns (CollateralType.Data memory);
 164 |     | 
 165 |     |     /**
 166 |     |      * Get the list of all available tokens used for collateral.
 167 |     |      */
 168 |     |     function getCollateralTypes()
 169 |     |         external
 170 |     |         view
 171 |     |         returns (CollateralType.Data[] memory);
 172 |     | 
 173 |     |     ////////////////////////////////////////////////////////////////////////////////////
 174 |     |     // Agent create / destroy
 175 |     | 
 176 |     |     /**
 177 |     |      * Create an agent vault.
 178 |     |      * The agent will always be identified by `_agentVault` address.
 179 |     |      * (Externally, one account may own several agent vaults,
 180 |     |      *  but in fasset system, each agent vault acts as an independent agent.)
 181 |     |      * NOTE: may only be called by an agent on the allowed agent list.
 182 |     |      * Can be called from the management or the work agent owner address.
 183 |     |      * @return _agentVault new agent vault address
 184 |     |      */
 185 |     |     function createAgentVault(
 186 |     |         IAddressValidity.Proof calldata _addressProof,
 187 |     |         AgentSettings.Data calldata _settings
 188 |     |     ) external returns (address _agentVault);
 189 |     | 
 190 |     |     /**
 191 |     |      * Announce that the agent is going to be destroyed. At this time, the agent must not have any mintings
 192 |     |      * or collateral reservations and must not be on the available agents list.
 193 |     |      * NOTE: may only be called by the agent vault owner.
 194 |     |      * @return _destroyAllowedAt the timestamp at which the destroy can be executed
 195 |     |      */
 196 |     |     function announceDestroyAgent(
 197 |     |         address _agentVault
 198 |     |     ) external returns (uint256 _destroyAllowedAt);
 199 |     | 
 200 |     |     /**
 201 |     |      * Delete all agent data, self destruct agent vault and send remaining collateral to the `_recipient`.
 202 |     |      * Procedure for destroying agent:
 203 |     |      * - exit available agents list
 204 |     |      * - wait until all assets are redeemed or perform self-close
 205 |     |      * - announce destroy (and wait the required time)
 206 |     |      * - call destroyAgent()
 207 |     |      * NOTE: may only be called by the agent vault owner.
 208 |     |      * NOTE: the remaining funds from the vault will be transferred to the provided recipient.
 209 |     |      * @param _agentVault address of the agent's vault to destroy
 210 |     |      * @param _recipient address that receives the remaining funds and possible vault balance
 211 |     |      */
 212 |     |     function destroyAgent(
 213 |     |         address _agentVault,
 214 |     |         address payable _recipient
 215 |     |     ) external;
 216 |     | 
 217 |     |     /**
 218 |     |      * When agent vault, collateral pool or collateral pool token factory is upgraded, new agent vaults
 219 |     |      * automatically get the new implementation from the factory. But the existing agent vaults must
 220 |     |      * be upgraded by their owners using this method.
 221 |     |      * NOTE: may only be called by the agent vault owner.
 222 |     |      * @param _agentVault address of the agent's vault; both vault, its corresponding pool, and
 223 |     |      *  its pool token will be upgraded to the newest implementations
 224 |     |      */
 225 |     |     function upgradeAgentVaultAndPool(address _agentVault) external;
 226 |     | 
 227 |     |     /**
 228 |     |      * Check if the collateral pool token has been used already by some vault.
 229 |     |      * @param _suffix the suffix to check
 230 |     |      */
 231 |     |     function isPoolTokenSuffixReserved(
 232 |     |         string memory _suffix
 233 |     |     ) external view returns (bool);
 234 |     | 
 235 |     |     ////////////////////////////////////////////////////////////////////////////////////
 236 |     |     // Agent settings update
 237 |     | 
 238 |     |     /**
 239 |     |      * Due to the effect on the pool, all agent settings are timelocked.
 240 |     |      * This method announces a setting change. The change can be executed after the timelock expires.
 241 |     |      * NOTE: may only be called by the agent vault owner.
 242 |     |      * @param _agentVault agent vault address
 243 |     |      * @param _name setting name, same as for `getAgentSetting`
 244 |     |      * @return _updateAllowedAt the timestamp at which the update can be executed
 245 |     |      */
 246 |     |     function announceAgentSettingUpdate(
 247 |     |         address _agentVault,
 248 |     |         string memory _name,
 249 |     |         uint256 _value
 250 |     |     ) external returns (uint256 _updateAllowedAt);
 251 |     | 
 252 |     |     /**
 253 |     |      * Due to the effect on the pool, all agent settings are timelocked.
 254 |     |      * This method executes a setting change after the timelock expires.
 255 |     |      * NOTE: may only be called by the agent vault owner.
 256 |     |      * @param _agentVault agent vault address
 257 |     |      * @param _name setting name, same as for `getAgentSetting`
 258 |     |      */
 259 |     |     function executeAgentSettingUpdate(
 260 |     |         address _agentVault,
 261 |     |         string memory _name
 262 |     |     ) external;
 263 |     | 
 264 |     |     ////////////////////////////////////////////////////////////////////////////////////
 265 |     |     // Collateral withdrawal announcement
 266 |     | 
 267 |     |     /**
 268 |     |      * The agent is going to withdraw `_valueNATWei` amount of collateral from the agent vault.
 269 |     |      * This has to be announced and the agent must then wait `withdrawalWaitMinSeconds` time.
 270 |     |      * After that time, the agent can call `withdrawCollateral(_vaultCollateralToken, _valueNATWei)`
 271 |     |      * on the agent vault.
 272 |     |      * NOTE: may only be called by the agent vault owner.
 273 |     |      * @param _agentVault agent vault address
 274 |     |      * @param _valueNATWei the amount to be withdrawn
 275 |     |      * @return _withdrawalAllowedAt the timestamp when the withdrawal can be made
 276 |     |      */
 277 |     |     function announceVaultCollateralWithdrawal(
 278 |     |         address _agentVault,
 279 |     |         uint256 _valueNATWei
 280 |     |     ) external returns (uint256 _withdrawalAllowedAt);
 281 |     | 
 282 |     |     /**
 283 |     |      * The agent is going to redeem `_valueWei` collateral pool tokens in the agent vault.
 284 |     |      * This has to be announced and the agent must then wait `withdrawalWaitMinSeconds` time.
 285 |     |      * After that time, the agent can call `redeemCollateralPoolTokens(_valueNATWei)` on the agent vault.
 286 |     |      * NOTE: may only be called by the agent vault owner.
 287 |     |      * @param _agentVault agent vault address
 288 |     |      * @param _valueNATWei the amount to be withdrawn
 289 |     |      * @return _redemptionAllowedAt the timestamp when the redemption can be made
 290 |     |      */
 291 |     |     function announceAgentPoolTokenRedemption(
 292 |     |         address _agentVault,
 293 |     |         uint256 _valueNATWei
 294 |     |     ) external returns (uint256 _redemptionAllowedAt);
 295 |     | 
 296 |     |     ////////////////////////////////////////////////////////////////////////////////////
 297 |     |     // Underlying balance topup
 298 |     | 
 299 |     |     /**
 300 |     |      * When the agent tops up his underlying address, it has to be confirmed by calling this method,
 301 |     |      * which updates the underlying free balance value.
 302 |     |      * NOTE: may only be called by the agent vault owner.
 303 |     |      * @param _payment proof of the underlying payment; must include payment
 304 |     |      *      reference of the form `0x4642505266410011000...0<agents_vault_address>`
 305 |     |      * @param _agentVault agent vault address
 306 |     |      */
 307 |     |     function confirmTopupPayment(
 308 |     |         IPayment.Proof calldata _payment,
 309 |     |         address _agentVault
 310 |     |     ) external;
 311 |     | 
 312 |     |     ////////////////////////////////////////////////////////////////////////////////////
 313 |     |     // Underlying withdrawal announcements
 314 |     | 
 315 |     |     /**
 316 |     |      * Announce withdrawal of underlying currency.
 317 |     |      * In the event UnderlyingWithdrawalAnnounced the agent receives payment reference, which must be
 318 |     |      * added to the payment, otherwise it can be challenged as illegal.
 319 |     |      * Until the announced withdrawal is performed and confirmed or canceled, no other withdrawal can be announced.
 320 |     |      * NOTE: may only be called by the agent vault owner.
 321 |     |      * @param _agentVault agent vault address
 322 |     |      */
 323 |     |     function announceUnderlyingWithdrawal(address _agentVault) external;
 324 |     | 
 325 |     |     /**
 326 |     |      * Agent must provide confirmation of performed underlying withdrawal, which updates free balance with used gas
 327 |     |      * and releases announcement so that a new one can be made.
 328 |     |      * If the agent doesn't call this method, anyone can call it after a time (`confirmationByOthersAfterSeconds`).
 329 |     |      * NOTE: may only be called by the owner of the agent vault
 330 |     |      *   except if enough time has passed without confirmation - then it can be called by anybody.
 331 |     |      * @param _payment proof of the underlying payment
 332 |     |      * @param _agentVault agent vault address
 333 |     |      */
 334 |     |     function confirmUnderlyingWithdrawal(
 335 |     |         IPayment.Proof calldata _payment,
 336 |     |         address _agentVault
 337 |     |     ) external;
 338 |     | 
 339 |     |     /**
 340 |     |      * Cancel ongoing withdrawal of underlying currency.
 341 |     |      * Needed in order to reset announcement timestamp, so that others cannot front-run the agent at
 342 |     |      * `confirmUnderlyingWithdrawal` call. This could happen if withdrawal would be performed more
 343 |     |      * than `confirmationByOthersAfterSeconds` seconds after announcement.
 344 |     |      * NOTE: may only be called by the agent vault owner.
 345 |     |      * @param _agentVault agent vault address
 346 |     |      */
 347 |     |     function cancelUnderlyingWithdrawal(address _agentVault) external;
 348 |     | 
 349 |     |     ////////////////////////////////////////////////////////////////////////////////////
 350 |     |     // Agent information
 351 |     | 
 352 |     |     /**
 353 |     |      * Get (a part of) the list of all agents.
 354 |     |      * The list must be retrieved in parts since retrieving the whole list can consume too much gas for one block.
 355 |     |      * @param _start first index to return from the available agent's list
 356 |     |      * @param _end end index (one above last) to return from the available agent's list
 357 |     |      */
 358 |     |     function getAllAgents(
 359 |     |         uint256 _start,
 360 |     |         uint256 _end
 361 |     |     ) external view returns (address[] memory _agents, uint256 _totalLength);
 362 |     | 
 363 |     |     /**
 364 |     |      * Return detailed info about an agent, typically needed by a minter.
 365 |     |      * @param _agentVault agent vault address
 366 |     |      * @return structure containing agent's minting fee (BIPS), min collateral ratio (BIPS),
 367 |     |      *      and current free collateral (lots)
 368 |     |      */
 369 |     |     function getAgentInfo(
 370 |     |         address _agentVault
 371 |     |     ) external view returns (AgentInfo.Info memory);
 372 |     | 
 373 |     |     /**
 374 |     |      * Get agent's setting by name.
 375 |     |      * This allows reading individual settings.
 376 |     |      * @param _agentVault agent vault address
 377 |     |      * @param _name setting name, one of: `feeBIPS`, `poolFeeShareBIPS`, `redemptionPoolFeeShareBIPS`,
 378 |     |      *  `mintingVaultCollateralRatioBIPS`, `mintingPoolCollateralRatioBIPS`,`buyFAssetByAgentFactorBIPS`,
 379 |     |      *  `poolExitCollateralRatioBIPS`
 380 |     |      */
 381 |     |     function getAgentSetting(
 382 |     |         address _agentVault,
 383 |     |         string memory _name
 384 |     |     ) external view returns (uint256);
 385 |     | 
 386 |     |     /**
 387 |     |      * Returns the collateral pool address of the agent identified by `_agentVault`.
 388 |     |      */
 389 |     |     function getCollateralPool(
 390 |     |         address _agentVault
 391 |     |     ) external view returns (address);
 392 |     | 
 393 |     |     /**
 394 |     |      * Return the management address of the owner of the agent identified by `_agentVault`.
 395 |     |      */
 396 |     |     function getAgentVaultOwner(
 397 |     |         address _agentVault
 398 |     |     ) external view returns (address _ownerManagementAddress);
 399 |     | 
 400 |     |     /**
 401 |     |      * Return vault collateral ERC20 token chosen by the agent identified by `_agentVault`.
 402 |     |      */
 403 |     |     function getAgentVaultCollateralToken(
 404 |     |         address _agentVault
 405 |     |     ) external view returns (IERC20);
 406 |     | 
 407 |     |     /**
 408 |     |      * Return full vault collateral (free + locked) deposited in the vault `_agentVault`.
 409 |     |      */
 410 |     |     function getAgentFullVaultCollateral(
 411 |     |         address _agentVault
 412 |     |     ) external view returns (uint256);
 413 |     | 
 414 |     |     /**
 415 |     |      * Return full pool NAT collateral (free + locked) deposited in the vault `_agentVault`.
 416 |     |      */
 417 |     |     function getAgentFullPoolCollateral(
 418 |     |         address _agentVault
 419 |     |     ) external view returns (uint256);
 420 |     | 
 421 |     |     /**
 422 |     |      * Return the current liquidation factors and max liquidation amount of the agent
 423 |     |      * identified by `_agentVault`.
 424 |     |      */
 425 |     |     function getAgentLiquidationFactorsAndMaxAmount(
 426 |     |         address _agentVault
 427 |     |     )
 428 |     |         external
 429 |     |         view
 430 |     |         returns (
 431 |     |             uint256 liquidationPaymentFactorVaultBIPS,
 432 |     |             uint256 liquidationPaymentFactorPoolBIPS,
 433 |     |             uint256 maxLiquidationAmountUBA
 434 |     |         );
 435 |     | 
 436 |     |     /**
 437 |     |      * Return the minimum collateral ratio of the pool collateral owned by vault `_agentVault`.
 438 |     |      */
 439 |     |     function getAgentMinPoolCollateralRatioBIPS(
 440 |     |         address _agentVault
 441 |     |     ) external view returns (uint256);
 442 |     | 
 443 |     |     /**
 444 |     |      * Return the minimum collateral ratio of the vault collateral owned by vault `_agentVault`.
 445 |     |      */
 446 |     |     function getAgentMinVaultCollateralRatioBIPS(
 447 |     |         address _agentVault
 448 |     |     ) external view returns (uint256);
 449 |     | 
 450 |     |     ////////////////////////////////////////////////////////////////////////////////////
 451 |     |     // List of available agents (i.e. publicly available for minting).
 452 |     | 
 453 |     |     /**
 454 |     |      * Add the agent to the list of publicly available agents.
 455 |     |      * Other agents can only self-mint.
 456 |     |      * NOTE: may only be called by the agent vault owner.
 457 |     |      * @param _agentVault agent vault address
 458 |     |      */
 459 |     |     function makeAgentAvailable(address _agentVault) external;
 460 |     | 
 461 |     |     /**
 462 |     |      * Announce exit from the publicly available agents list.
 463 |     |      * NOTE: may only be called by the agent vault owner.
 464 |     |      * @param _agentVault agent vault address
 465 |     |      * @return _exitAllowedAt the timestamp when the agent can exit
 466 |     |      */
 467 |     |     function announceExitAvailableAgentList(
 468 |     |         address _agentVault
 469 |     |     ) external returns (uint256 _exitAllowedAt);
 470 |     | 
 471 |     |     /**
 472 |     |      * Exit the publicly available agents list.
 473 |     |      * NOTE: may only be called by the agent vault owner and after announcement.
 474 |     |      * @param _agentVault agent vault address
 475 |     |      */
 476 |     |     function exitAvailableAgentList(address _agentVault) external;
 477 |     | 
 478 |     |     /**
 479 |     |      * Get (a part of) the list of available agents.
 480 |     |      * The list must be retrieved in parts since retrieving the whole list can consume too much gas for one block.
 481 |     |      * @param _start first index to return from the available agent's list
 482 |     |      * @param _end end index (one above last) to return from the available agent's list
 483 |     |      */
 484 |     |     function getAvailableAgentsList(
 485 |     |         uint256 _start,
 486 |     |         uint256 _end
 487 |     |     ) external view returns (address[] memory _agents, uint256 _totalLength);
 488 |     | 
 489 |     |     /**
 490 |     |      * Get (a part of) the list of available agents with extra information about agents' fee, min collateral ratio
 491 |     |      * and available collateral (in lots).
 492 |     |      * The list must be retrieved in parts since retrieving the whole list can consume too much gas for one block.
 493 |     |      * NOTE: agent's available collateral can change anytime due to price changes, minting, or changes
 494 |     |      * in agent's min collateral ratio, so it is only to be used as an estimate.
 495 |     |      * @param _start first index to return from the available agent's list
 496 |     |      * @param _end end index (one above last) to return from the available agent's list
 497 |     |      */
 498 |     |     function getAvailableAgentsDetailedList(
 499 |     |         uint256 _start,
 500 |     |         uint256 _end
 501 |     |     )
 502 |     |         external
 503 |     |         view
 504 |     |         returns (
 505 |     |             AvailableAgentInfo.Data[] memory _agents,
 506 |     |             uint256 _totalLength
 507 |     |         );
 508 |     | 
 509 |     |     ////////////////////////////////////////////////////////////////////////////////////
 510 |     |     // Minting
 511 |     | 
 512 |     |     /**
 513 |     |      * Before paying underlying assets for minting, minter has to reserve collateral and
 514 |     |      * pay collateral reservation fee. Collateral is reserved at ratio of agent's agentMinCollateralRatio
 515 |     |      * to requested lots NAT market price.
 516 |     |      * The minter receives instructions for underlying payment
 517 |     |      * (value, fee and payment reference) in event CollateralReserved.
 518 |     |      * Then the minter has to pay `value + fee` on the underlying chain.
 519 |     |      * If the minter pays the underlying amount, minter obtains f-assets.
 520 |     |      * The collateral reservation fee is split between the agent and the collateral pool.
 521 |     |      * NOTE: the owner of the agent vault must be in the AgentOwnerRegistry.
 522 |     |      * @param _agentVault agent vault address
 523 |     |      * @param _lots the number of lots for which to reserve collateral
 524 |     |      * @param _maxMintingFeeBIPS maximum minting fee (BIPS) that can be charged by the agent - best is just to
 525 |     |      *      copy current agent's published fee; used to prevent agent from front-running reservation request
 526 |     |      *      and increasing fee (that would mean that the minter would have to pay raised fee or forfeit
 527 |     |      *      collateral reservation fee)
 528 |     |      * @param _executor the account that is allowed to execute minting (besides minter and agent)
 529 |     |      */
 530 |     |     function reserveCollateral(
 531 |     |         address _agentVault,
 532 |     |         uint256 _lots,
 533 |     |         uint256 _maxMintingFeeBIPS,
 534 |     |         address payable _executor
 535 |     |     ) external payable returns (uint256 _collateralReservationId);
 536 |     | 
 537 |     |     /**
 538 |     |      * Return the collateral reservation fee amount that has to be passed to the `reserveCollateral` method.
 539 |     |      * NOTE: the amount paid may be larger than the required amount, but the difference is not returned.
 540 |     |      * It is advised that the minter pays the exact amount, but when the amount is so small that the revert
 541 |     |      * would cost more than the lost difference, the minter may want to send a slightly larger amount to compensate
 542 |     |      * for the possibility of a FTSO price change between obtaining this value and calling `reserveCollateral`.
 543 |     |      * @param _lots the number of lots for which to reserve collateral
 544 |     |      * @return _reservationFeeNATWei the amount of reservation fee in NAT wei
 545 |     |      */
 546 |     |     function collateralReservationFee(
 547 |     |         uint256 _lots
 548 |     |     ) external view returns (uint256 _reservationFeeNATWei);
 549 |     | 
 550 |     |     /**
 551 |     |      * Returns the data about the collateral reservation for an ongoing minting.
 552 |     |      * Note: once the minting is executed or defaulted, the collateral reservation is deleted and this method fails.
 553 |     |      * @param _collateralReservationId the collateral reservation id, as used for executing or defaulting the minting
 554 |     |      */
 555 |     |     function collateralReservationInfo(
 556 |     |         uint256 _collateralReservationId
 557 |     |     ) external view returns (CollateralReservationInfo.Data memory);
 558 |     | 
 559 |     |     /**
 560 |     |      * After obtaining proof of underlying payment, the minter calls this method to finish the minting
 561 |     |      * and collect the minted f-assets.
 562 |     |      * NOTE: may only be called by the minter (= creator of CR, the collateral reservation request),
 563 |     |      *   the executor appointed by the minter, or the agent owner (= owner of the agent vault in CR).
 564 |     |      * @param _payment proof of the underlying payment (must contain exact `value + fee` amount and correct
 565 |     |      *      payment reference)
 566 |     |      * @param _collateralReservationId collateral reservation id
 567 |     |      */
 568 |     |     function executeMinting(
 569 |     |         IPayment.Proof calldata _payment,
 570 |     |         uint256 _collateralReservationId
 571 |     |     ) external;
 572 |     | 
 573 |     |     /**
 574 |     |      * When the time for the minter to pay the underlying amount is over (i.e. the last underlying block has passed),
 575 |     |      * the agent can declare payment default. Then the agent collects the collateral reservation fee
 576 |     |      * (it goes directly to the vault), and the reserved collateral is unlocked.
 577 |     |      * NOTE: The attestation request must be done with `checkSourceAddresses=false`.
 578 |     |      * NOTE: may only be called by the owner of the agent vault in the collateral reservation request.
 579 |     |      * @param _proof proof that the minter didn't pay with correct payment reference on the underlying chain
 580 |     |      * @param _collateralReservationId id of a collateral reservation created by the minter
 581 |     |      */
 582 |     |     function mintingPaymentDefault(
 583 |     |         IReferencedPaymentNonexistence.Proof calldata _proof,
 584 |     |         uint256 _collateralReservationId
 585 |     |     ) external;
 586 |     | 
 587 |     |     /**
 588 |     |      * The minter can make several mistakes in the underlying payment:
 589 |     |      * - the payment is too late and is already defaulted before executing
 590 |     |      * - the payment is too small so executeMinting reverts
 591 |     |      * - the payment is performed twice
 592 |     |      * In all of these cases the paid amount ends up on the agent vault's underlying account, but it is not
 593 |     |      * confirmed and therefore the agent cannot withdraw it without triggering full liquidation (of course
 594 |     |      * the agent can legally withdraw it once the vault is closed).
 595 |     |      * This method enables the agent to confirm such payments, converting the deposited amount to agent's
 596 |     |      * free underlying.
 597 |     |      * NOTE: may only be called by the agent vault owner.
 598 |     |      * @param _payment proof of the underlying payment (must have correct payment reference)
 599 |     |      * @param _collateralReservationId collateral reservation id
 600 |     |      */
 601 |     |     function confirmClosedMintingPayment(
 602 |     |         IPayment.Proof calldata _payment,
 603 |     |         uint256 _collateralReservationId
 604 |     |     ) external;
 605 |     | 
 606 |     |     /**
 607 |     |      * If a collateral reservation request exists for more than 24 hours, payment or non-payment proof are no longer
 608 |     |      * available. In this case the agent can call this method, which burns reserved collateral at market price
 609 |     |      * and releases the remaining collateral (CRF is also burned).
 610 |     |      * NOTE: may only be called by the owner of the agent vault in the collateral reservation request.
 611 |     |      * NOTE: the agent (management address) receives the vault collateral and NAT is burned instead. Therefore
 612 |     |      *      this method is `payable` and the caller must provide enough NAT to cover the received vault collateral
 613 |     |      *      amount multiplied by `vaultCollateralBuyForFlareFactorBIPS`.
 614 |     |      * @param _proof proof that the attestation query window can not not contain
 615 |     |      *      the payment/non-payment proof anymore
 616 |     |      * @param _collateralReservationId collateral reservation id
 617 |     |      */
 618 |     |     function unstickMinting(
 619 |     |         IConfirmedBlockHeightExists.Proof calldata _proof,
 620 |     |         uint256 _collateralReservationId
 621 |     |     ) external payable;
 622 |     | 
 623 |     |     /**
 624 |     |      * Agent can mint against himself.
 625 |     |      * This is a one-step process, skipping collateral reservation and collateral reservation fee payment.
 626 |     |      * Moreover, the agent doesn't have to be on the publicly available agents list to self-mint.
 627 |     |      * NOTE: may only be called by the agent vault owner.
 628 |     |      * NOTE: the caller must be a whitelisted agent.
 629 |     |      * @param _payment proof of the underlying payment; must contain payment reference of the form
 630 |     |      *      `0x4642505266410012000...0<agent_vault_address>`
 631 |     |      * @param _agentVault agent vault address
 632 |     |      * @param _lots number of lots to mint
 633 |     |      */
 634 |     |     function selfMint(
 635 |     |         IPayment.Proof calldata _payment,
 636 |     |         address _agentVault,
 637 |     |         uint256 _lots
 638 |     |     ) external;
 639 |     | 
 640 |     |     /**
 641 |     |      * If an agent has enough free underlying, they can mint immediately without any underlying payment.
 642 |     |      * This is a one-step process, skipping collateral reservation and collateral reservation fee payment.
 643 |     |      * Moreover, the agent doesn't have to be on the publicly available agents list to self-mint.
 644 |     |      * NOTE: may only be called by the agent vault owner.
 645 |     |      * NOTE: the caller must be a whitelisted agent.
 646 |     |      * @param _agentVault agent vault address
 647 |     |      * @param _lots number of lots to mint
 648 |     |      */
 649 |     |     function mintFromFreeUnderlying(address _agentVault, uint64 _lots) external;
 650 |     | 
 651 |     |     ////////////////////////////////////////////////////////////////////////////////////
 652 |     |     // Redemption
 653 |     | 
 654 |     |     /**
 655 |     |      * Redeem (up to) `_lots` lots of f-assets. The corresponding amount of the f-assets belonging
 656 |     |      * to the redeemer will be burned and the redeemer will get paid by the agent in underlying currency
 657 |     |      * (or, in case of agent's payment default, by agent's collateral with a premium).
 658 |     |      * NOTE: in some cases not all sent f-assets can be redeemed (either there are not enough tickets or
 659 |     |      * more than a fixed limit of tickets should be redeemed). In this case only part of the approved assets
 660 |     |      * are burned and redeemed and the redeemer can execute this method again for the remaining lots.
 661 |     |      * In such a case the `RedemptionRequestIncomplete` event will be emitted, indicating the number
 662 |     |      * of remaining lots.
 663 |     |      * Agent receives redemption request id and instructions for underlying payment in
 664 |     |      * RedemptionRequested event and has to pay `value - fee` and use the provided payment reference.
 665 |     |      * @param _lots number of lots to redeem
 666 |     |      * @param _redeemerUnderlyingAddressString the address to which the agent must transfer underlying amount
 667 |     |      * @param _executor the account that is allowed to execute redemption default (besides redeemer and agent)
 668 |     |      * @return _redeemedAmountUBA the actual redeemed amount; may be less than requested if there are not enough
 669 |     |      *      redemption tickets available or the maximum redemption ticket limit is reached
 670 |     |      */
 671 |     |     function redeem(
 672 |     |         uint256 _lots,
 673 |     |         string memory _redeemerUnderlyingAddressString,
 674 |     |         address payable _executor
 675 |     |     ) external payable returns (uint256 _redeemedAmountUBA);
 676 |     | 
 677 |     |     /**
 678 |     |      * If the redeemer provides invalid address, the agent should provide the proof of address invalidity from the
 679 |     |      * Flare data connector. With this, the agent's obligations are fulfilled and they can keep the underlying.
 680 |     |      * NOTE: may only be called by the owner of the agent vault in the redemption request
 681 |     |      * NOTE: also checks that redeemer's address is normalized, so the redeemer must normalize their address,
 682 |     |      *   otherwise it will be rejected!
 683 |     |      * @param _proof proof that the address is invalid
 684 |     |      * @param _redemptionRequestId id of an existing redemption request
 685 |     |      */
 686 |     |     function rejectInvalidRedemption(
 687 |     |         IAddressValidity.Proof calldata _proof,
 688 |     |         uint256 _redemptionRequestId
 689 |     |     ) external;
 690 |     | 
 691 |     |     /**
 692 |     |      * After paying to the redeemer, the agent must call this method to unlock the collateral
 693 |     |      * and to make sure that the redeemer cannot demand payment in collateral on timeout.
 694 |     |      * The same method must be called for any payment status (SUCCESS, FAILED, BLOCKED).
 695 |     |      * In case of FAILED, it just releases the agent's underlying funds and the redeemer gets paid in collateral
 696 |     |      * after calling redemptionPaymentDefault.
 697 |     |      * In case of SUCCESS or BLOCKED, remaining underlying funds and collateral are released to the agent.
 698 |     |      * If the agent doesn't confirm payment in enough time (several hours, setting
 699 |     |      * `confirmationByOthersAfterSeconds`), anybody can do it and get rewarded from the agent's vault.
 700 |     |      * NOTE: may only be called by the owner of the agent vault in the redemption request
 701 |     |      *   except if enough time has passed without confirmation - then it can be called by anybody
 702 |     |      * @param _payment proof of the underlying payment (must contain exact `value - fee` amount and correct
 703 |     |      *      payment reference)
 704 |     |      * @param _redemptionRequestId id of an existing redemption request
 705 |     |      */
 706 |     |     function confirmRedemptionPayment(
 707 |     |         IPayment.Proof calldata _payment,
 708 |     |         uint256 _redemptionRequestId
 709 |     |     ) external;
 710 |     | 
 711 |     |     /**
 712 |     |      * If the agent doesn't transfer the redeemed underlying assets in time (until the last allowed block on
 713 |     |      * the underlying chain), the redeemer calls this method and receives payment in collateral (with some extra).
 714 |     |      * The agent can also call default if the redeemer is unresponsive, to payout the redeemer and free the
 715 |     |      * remaining collateral.
 716 |     |      * NOTE: The attestation request must be done with `checkSourceAddresses=false`.
 717 |     |      * NOTE: may only be called by the redeemer (= creator of the redemption request),
 718 |     |      *   the executor appointed by the redeemer,
 719 |     |      *   or the agent owner (= owner of the agent vault in the redemption request)
 720 |     |      * @param _proof proof that the agent didn't pay with correct payment reference on the underlying chain
 721 |     |      * @param _redemptionRequestId id of an existing redemption request
 722 |     |      */
 723 |     |     function redemptionPaymentDefault(
 724 |     |         IReferencedPaymentNonexistence.Proof calldata _proof,
 725 |     |         uint256 _redemptionRequestId
 726 |     |     ) external;
 727 |     | 
 728 |     |     /**
 729 |     |      * If the agent hasn't performed the payment, the agent can close the redemption request to free underlying funds.
 730 |     |      * It can be done immediately after the redeemer or agent calls `redemptionPaymentDefault`,
 731 |     |      * or this method can trigger the default payment without proof, but only after enough time has passed so that
 732 |     |      * attestation proof of non-payment is not available any more.
 733 |     |      * NOTE: may only be called by the owner of the agent vault in the redemption request.
 734 |     |      * @param _proof proof that the attestation query window can not not contain
 735 |     |      *      the payment/non-payment proof anymore
 736 |     |      * @param _redemptionRequestId id of an existing, but already defaulted, redemption request
 737 |     |      */
 738 |     |     function finishRedemptionWithoutPayment(
 739 |     |         IConfirmedBlockHeightExists.Proof calldata _proof,
 740 |     |         uint256 _redemptionRequestId
 741 |     |     ) external;
 742 |     | 
 743 |     |     /**
 744 |     |      * Returns the data about an ongoing redemption request.
 745 |     |      * Note: once the redemptions is confirmed, the request is deleted and this method fails.
 746 |     |      * However, if there is no payment and the redemption defaults, the method works and returns status DEFAULTED.
 747 |     |      * @param _redemptionRequestId the redemption request id, as used for confirming or defaulting the redemption
 748 |     |      */
 749 |     |     function redemptionRequestInfo(
 750 |     |         uint256 _redemptionRequestId
 751 |     |     ) external view returns (RedemptionRequestInfo.Data memory);
 752 |     | 
 753 |     |     /**
 754 |     |      * Agent can "redeem against himself" by calling `selfClose`, which burns agent's own f-assets
 755 |     |      * and unlocks agent's collateral. The underlying funds backing the f-assets are released
 756 |     |      * as agent's free underlying funds and can be later withdrawn after announcement.
 757 |     |      * NOTE: may only be called by the agent vault owner.
 758 |     |      * @param _agentVault agent vault address
 759 |     |      * @param _amountUBA amount of f-assets to self-close
 760 |     |      * @return _closedAmountUBA the actual self-closed amount, may be less than requested if there are not enough
 761 |     |      *      redemption tickets available or the maximum redemption ticket limit is reached
 762 |     |      */
 763 |     |     function selfClose(
 764 |     |         address _agentVault,
 765 |     |         uint256 _amountUBA
 766 |     |     ) external returns (uint256 _closedAmountUBA);
 767 |     | 
 768 |     |     ////////////////////////////////////////////////////////////////////////////////////
 769 |     |     // Redemption queue info
 770 |     | 
 771 |     |     /**
 772 |     |      * Return (part of) the redemption queue.
 773 |     |      * @param _firstRedemptionTicketId the ticket id to start listing from; if 0, starts from the beginning
 774 |     |      * @param _pageSize the maximum number of redemption tickets to return
 775 |     |      * @return _queue the (part of) the redemption queue; maximum length is _pageSize
 776 |     |      * @return _nextRedemptionTicketId works as a cursor - if the _pageSize is reached and there are more tickets,
 777 |     |      *  it is the first ticket id not returned; if the end is reached, it is 0
 778 |     |      */
 779 |     |     function redemptionQueue(
 780 |     |         uint256 _firstRedemptionTicketId,
 781 |     |         uint256 _pageSize
 782 |     |     )
 783 |     |         external
 784 |     |         view
 785 |     |         returns (
 786 |     |             RedemptionTicketInfo.Data[] memory _queue,
 787 |     |             uint256 _nextRedemptionTicketId
 788 |     |         );
 789 |     | 
 790 |     |     /**
 791 |     |      * Return (part of) the redemption queue for a specific agent.
 792 |     |      * @param _agentVault the agent vault address of the queried agent
 793 |     |      * @param _firstRedemptionTicketId the ticket id to start listing from; if 0, starts from the beginning
 794 |     |      * @param _pageSize the maximum number of redemption tickets to return
 795 |     |      * @return _queue the (part of) the redemption queue; maximum length is _pageSize
 796 |     |      * @return _nextRedemptionTicketId works as a cursor - if the _pageSize is reached and there are more tickets,
 797 |     |      *  it is the first ticket id not returned; if the end is reached, it is 0
 798 |     |      */
 799 |     |     function agentRedemptionQueue(
 800 |     |         address _agentVault,
 801 |     |         uint256 _firstRedemptionTicketId,
 802 |     |         uint256 _pageSize
 803 |     |     )
 804 |     |         external
 805 |     |         view
 806 |     |         returns (
 807 |     |             RedemptionTicketInfo.Data[] memory _queue,
 808 |     |             uint256 _nextRedemptionTicketId
 809 |     |         );
 810 |     | 
 811 |     |     ////////////////////////////////////////////////////////////////////////////////////
 812 |     |     // Dust and small ticket management
 813 |     | 
 814 |     |     /**
 815 |     |      * Due to the minting pool fees or after a lot size change by the governance,
 816 |     |      * it may happen that less than one lot remains on a redemption ticket. This is named "dust" and
 817 |     |      * can be self closed or liquidated, but not redeemed. However, after several additions,
 818 |     |      * the total dust can amount to more than one lot. Using this method, the amount, rounded down
 819 |     |      * to a whole number of lots, can be converted to a new redemption ticket.
 820 |     |      * NOTE: we do NOT check that the caller is the agent vault owner, since we want to
 821 |     |      * allow anyone to convert dust to tickets to increase asset fungibility.
 822 |     |      * NOTE: dust above 1 lot is actually added to ticket at every minting, so this function need
 823 |     |      * only be called when the agent doesn't have any minting.
 824 |     |      * @param _agentVault agent vault address
 825 |     |      */
 826 |     |     function convertDustToTicket(address _agentVault) external;
 827 |     | 
 828 |     |     /**
 829 |     |      * If lot size is increased, there may be many tickets less than one lot in the queue.
 830 |     |      * In extreme cases, this could prevent redemptions, if there weren't any tickets above 1 lot
 831 |     |      * among the first `maxRedeemedTickets` tickets.
 832 |     |      * To fix this, call this method. It converts small tickets to dust and when the dust exceeds one lot
 833 |     |      * adds it to the ticket.
 834 |     |      * Since the method just cleans the redemption queue it can be called by anybody.
 835 |     |      * @param _firstTicketId if nonzero, the ticket id of starting ticket; if zero, the starting ticket will
 836 |     |      *   be the redemption queue's first ticket id.
 837 |     |      *   When the method finishes, it emits RedemptionTicketsConsolidated event with the nextTicketId
 838 |     |      *   parameter. If it is nonzero, the method should be invoked again with this value as _firstTicketId.
 839 |     |      */
 840 |     |     function consolidateSmallTickets(uint256 _firstTicketId) external;
 841 |     | 
 842 |     |     ////////////////////////////////////////////////////////////////////////////////////
 843 |     |     // Liquidation
 844 |     | 
 845 |     |     /**
 846 |     |      * Checks that the agent's collateral is too low and if true, starts agent's liquidation.
 847 |     |      * If the agent is already in liquidation, returns the timestamp when liquidation started.
 848 |     |      * @param _agentVault agent vault address
 849 |     |      * @return _liquidationStartTs timestamp when liquidation started
 850 |     |      */
 851 |     |     function startLiquidation(
 852 |     |         address _agentVault
 853 |     |     ) external returns (uint256 _liquidationStartTs);
 854 |     | 
 855 |     |     /**
 856 |     |      * Burns up to `_amountUBA` f-assets owned by the caller and pays
 857 |     |      * the caller the corresponding amount of native currency with premium
 858 |     |      * (premium depends on the liquidation state).
 859 |     |      * If the agent isn't in liquidation yet, but satisfies conditions,
 860 |     |      * automatically puts the agent in liquidation status.
 861 |     |      * @param _agentVault agent vault address
 862 |     |      * @param _amountUBA the amount of f-assets to liquidate
 863 |     |      * @return _liquidatedAmountUBA liquidated amount of f-asset
 864 |     |      * @return _amountPaidVault amount paid to liquidator (in agent's vault collateral)
 865 |     |      * @return _amountPaidPool amount paid to liquidator (in NAT from pool)
 866 |     |      */
 867 |     |     function liquidate(
 868 |     |         address _agentVault,
 869 |     |         uint256 _amountUBA
 870 |     |     )
 871 |     |         external
 872 |     |         returns (
 873 |     |             uint256 _liquidatedAmountUBA,
 874 |     |             uint256 _amountPaidVault,
 875 |     |             uint256 _amountPaidPool
 876 |     |         );
 877 |     | 
 878 |     |     /**
 879 |     |      * When the agent's collateral reaches the safe level during liquidation, the liquidation
 880 |     |      * process can be stopped by calling this method.
 881 |     |      * Full liquidation (i.e. the liquidation triggered by illegal underlying payment)
 882 |     |      * cannot be stopped.
 883 |     |      * NOTE: anybody can call.
 884 |     |      * NOTE: if the method succeeds, the agent's liquidation has ended.
 885 |     |      * @param _agentVault agent vault address
 886 |     |      */
 887 |     |     function endLiquidation(address _agentVault) external;
 888 |     | 
 889 |     |     ////////////////////////////////////////////////////////////////////////////////////
 890 |     |     // Challenges
 891 |     | 
 892 |     |     /**
 893 |     |      * Called with a proof of payment made from the agent's underlying address, for which
 894 |     |      * no valid payment reference exists (valid payment references are from redemption and
 895 |     |      * underlying withdrawal announcement calls).
 896 |     |      * On success, immediately triggers full agent liquidation and rewards the caller.
 897 |     |      * @param _payment proof of a transaction from the agent's underlying address
 898 |     |      * @param _agentVault agent vault address
 899 |     |      */
 900 |     |     function illegalPaymentChallenge(
 901 |     |         IBalanceDecreasingTransaction.Proof calldata _payment,
 902 |     |         address _agentVault
 903 |     |     ) external;
 904 |     | 
 905 |     |     /**
 906 |     |      * Called with proofs of two payments made from the agent's underlying address
 907 |     |      * with the same payment reference (each payment reference is valid for only one payment).
 908 |     |      * On success, immediately triggers full agent liquidation and rewards the caller.
 909 |     |      * @param _payment1 proof of first payment from the agent's underlying address
 910 |     |      * @param _payment2 proof of second payment from the agent's underlying address
 911 |     |      * @param _agentVault agent vault address
 912 |     |      */
 913 |     |     function doublePaymentChallenge(
 914 |     |         IBalanceDecreasingTransaction.Proof calldata _payment1,
 915 |     |         IBalanceDecreasingTransaction.Proof calldata _payment2,
 916 |     |         address _agentVault
 917 |     |     ) external;
 918 |     | 
 919 |     |     /**
 920 |     |      * Called with proofs of several (otherwise legal) payments, which together make the agent's
 921 |     |      * underlying free balance negative (i.e. the underlying address balance is less than
 922 |     |      * the total amount of backed f-assets).
 923 |     |      * On success, immediately triggers full agent liquidation and rewards the caller.
 924 |     |      * @param _payments proofs of several distinct payments from the agent's underlying address
 925 |     |      * @param _agentVault agent vault address
 926 |     |      */
 927 |     |     function freeBalanceNegativeChallenge(
 928 |     |         IBalanceDecreasingTransaction.Proof[] calldata _payments,
 929 |     |         address _agentVault
 930 |     |     ) external;
 931 |     | }
 932 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IAssetManagerController.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import {IAssetManager} from "./IAssetManager.sol";
  5 |     | 
  6 |     | interface IAssetManagerController {
  7 |     |     /**
  8 |     |      * Return the list of all asset managers managed by this controller.
  9 |     |      */
 10 |     |     function getAssetManagers() external view returns (IAssetManager[] memory);
 11 |     | 
 12 |     |     /**
 13 |     |      * Check whether the asset manager is managed by this controller.
 14 |     |      * @param _assetManager an asset manager address
 15 |     |      */
 16 |     |     function assetManagerExists(
 17 |     |         address _assetManager
 18 |     |     ) external view returns (bool);
 19 |     | }
 20 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IAssetManagerEvents.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | import {EmergencyPause} from "./data/EmergencyPause.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * All asset manager events.
   8 |     |  */
   9 |     | interface IAssetManagerEvents {
  10 |     |     struct AgentVaultCreationData {
  11 |     |         address collateralPool;
  12 |     |         address collateralPoolToken;
  13 |     |         string underlyingAddress;
  14 |     |         address vaultCollateralToken;
  15 |     |         address poolWNatToken;
  16 |     |         uint256 feeBIPS;
  17 |     |         uint256 poolFeeShareBIPS;
  18 |     |         uint256 mintingVaultCollateralRatioBIPS;
  19 |     |         uint256 mintingPoolCollateralRatioBIPS;
  20 |     |         uint256 buyFAssetByAgentFactorBIPS;
  21 |     |         uint256 poolExitCollateralRatioBIPS;
  22 |     |         uint256 redemptionPoolFeeShareBIPS;
  23 |     |     }
  24 |     | 
  25 |     |     /**
  26 |     |      * A new agent vault was created.
  27 |     |      */
  28 |     |     event AgentVaultCreated(
  29 |     |         address indexed owner,
  30 |     |         address indexed agentVault,
  31 |     |         AgentVaultCreationData creationData
  32 |     |     );
  33 |     | 
  34 |     |     /**
  35 |     |      * Agent has announced destroy (close) of agent vault and will be able to
  36 |     |      * perform destroy after the timestamp `destroyAllowedAt`.
  37 |     |      */
  38 |     |     event AgentDestroyAnnounced(
  39 |     |         address indexed agentVault,
  40 |     |         uint256 destroyAllowedAt
  41 |     |     );
  42 |     | 
  43 |     |     /**
  44 |     |      * Agent has destroyed (closed) the agent vault.
  45 |     |      */
  46 |     |     event AgentDestroyed(address indexed agentVault);
  47 |     | 
  48 |     |     /**
  49 |     |      * Agent has announced a withdrawal of collateral and will be able to
  50 |     |      * withdraw the announced amount after timestamp `withdrawalAllowedAt`.
  51 |     |      * If withdrawal was canceled (announced with amount 0), amountWei and withdrawalAllowedAt are zero.
  52 |     |      */
  53 |     |     event VaultCollateralWithdrawalAnnounced(
  54 |     |         address indexed agentVault,
  55 |     |         uint256 amountWei,
  56 |     |         uint256 withdrawalAllowedAt
  57 |     |     );
  58 |     | 
  59 |     |     /**
  60 |     |      * Agent has announced a withdrawal of collateral and will be able to
  61 |     |      * redeem the announced amount of pool tokens after the timestamp `withdrawalAllowedAt`.
  62 |     |      * If withdrawal was canceled (announced with amount 0), amountWei and withdrawalAllowedAt are zero.
  63 |     |      */
  64 |     |     event PoolTokenRedemptionAnnounced(
  65 |     |         address indexed agentVault,
  66 |     |         uint256 amountWei,
  67 |     |         uint256 withdrawalAllowedAt
  68 |     |     );
  69 |     | 
  70 |     |     /**
  71 |     |      * Agent was added to the list of available agents and can accept collateral reservation requests.
  72 |     |      */
  73 |     |     event AgentAvailable(
  74 |     |         address indexed agentVault,
  75 |     |         uint256 feeBIPS,
  76 |     |         uint256 mintingVaultCollateralRatioBIPS,
  77 |     |         uint256 mintingPoolCollateralRatioBIPS,
  78 |     |         uint256 freeCollateralLots
  79 |     |     );
  80 |     | 
  81 |     |     /**
  82 |     |      * Agent exited from available agents list.
  83 |     |      * The agent can exit the available list after the timestamp `exitAllowedAt`.
  84 |     |      */
  85 |     |     event AvailableAgentExitAnnounced(
  86 |     |         address indexed agentVault,
  87 |     |         uint256 exitAllowedAt
  88 |     |     );
  89 |     | 
  90 |     |     /**
  91 |     |      * Agent exited from available agents list.
  92 |     |      */
  93 |     |     event AvailableAgentExited(address indexed agentVault);
  94 |     | 
  95 |     |     /**
  96 |     |      * Agent has initiated setting change (fee or some agent collateral ratio change).
  97 |     |      * The setting change can be executed after the timestamp `validAt`.
  98 |     |      */
  99 |     |     event AgentSettingChangeAnnounced(
 100 |     |         address indexed agentVault,
 101 |     |         string name,
 102 |     |         uint256 value,
 103 |     |         uint256 validAt
 104 |     |     );
 105 |     | 
 106 |     |     /**
 107 |     |      * Agent has executed setting change (fee or some agent collateral ratio change).
 108 |     |      */
 109 |     |     event AgentSettingChanged(
 110 |     |         address indexed agentVault,
 111 |     |         string name,
 112 |     |         uint256 value
 113 |     |     );
 114 |     | 
 115 |     |     /**
 116 |     |      * Agent or agent's collateral pool has changed token contract.
 117 |     |      */
 118 |     |     event AgentCollateralTypeChanged(
 119 |     |         address indexed agentVault,
 120 |     |         uint8 collateralClass,
 121 |     |         address token
 122 |     |     );
 123 |     | 
 124 |     |     /**
 125 |     |      * Minter reserved collateral, paid the reservation fee, and is expected to pay the underlying funds.
 126 |     |      * Agent's collateral was reserved.
 127 |     |      */
 128 |     |     event CollateralReserved(
 129 |     |         address indexed agentVault,
 130 |     |         address indexed minter,
 131 |     |         uint256 indexed collateralReservationId,
 132 |     |         uint256 valueUBA,
 133 |     |         uint256 feeUBA,
 134 |     |         uint256 firstUnderlyingBlock,
 135 |     |         uint256 lastUnderlyingBlock,
 136 |     |         uint256 lastUnderlyingTimestamp,
 137 |     |         string paymentAddress,
 138 |     |         bytes32 paymentReference,
 139 |     |         address executor,
 140 |     |         uint256 executorFeeNatWei
 141 |     |     );
 142 |     | 
 143 |     |     /**
 144 |     |      * Minter paid underlying funds in time and received the fassets.
 145 |     |      * The agent's collateral is locked.
 146 |     |      */
 147 |     |     event MintingExecuted(
 148 |     |         address indexed agentVault,
 149 |     |         uint256 indexed collateralReservationId,
 150 |     |         uint256 mintedAmountUBA,
 151 |     |         uint256 agentFeeUBA,
 152 |     |         uint256 poolFeeUBA
 153 |     |     );
 154 |     | 
 155 |     |     /**
 156 |     |      * Minter failed to pay underlying funds in time. Collateral reservation fee was paid to the agent.
 157 |     |      * Reserved collateral was released.
 158 |     |      */
 159 |     |     event MintingPaymentDefault(
 160 |     |         address indexed agentVault,
 161 |     |         address indexed minter,
 162 |     |         uint256 indexed collateralReservationId,
 163 |     |         uint256 reservedAmountUBA
 164 |     |     );
 165 |     | 
 166 |     |     /**
 167 |     |      * Both minter and agent failed to present any proof within attestation time window, so
 168 |     |      * the agent called `unstickMinting` to release reserved collateral.
 169 |     |      */
 170 |     |     event CollateralReservationDeleted(
 171 |     |         address indexed agentVault,
 172 |     |         address indexed minter,
 173 |     |         uint256 indexed collateralReservationId,
 174 |     |         uint256 reservedAmountUBA
 175 |     |     );
 176 |     | 
 177 |     |     /**
 178 |     |      * Emitted when a late or too small payment for an already defaulted or expired minting is confirmed.
 179 |     |      * It is equivalent to agent performing underlying topup.
 180 |     |      */
 181 |     |     event ConfirmedClosedMintingPayment(
 182 |     |         address indexed agentVault,
 183 |     |         bytes32 transactionHash,
 184 |     |         uint256 depositedUBA
 185 |     |     );
 186 |     | 
 187 |     |     /**
 188 |     |      * Agent performed self minting, either by executing selfMint with underlying deposit or
 189 |     |      * by executing mintFromFreeUnderlying (in this case, `mintFromFreeUnderlying` is true and
 190 |     |      * `depositedAmountUBA` is zero).
 191 |     |      */
 192 |     |     event SelfMint(
 193 |     |         address indexed agentVault,
 194 |     |         bool mintFromFreeUnderlying,
 195 |     |         uint256 mintedAmountUBA,
 196 |     |         uint256 depositedAmountUBA,
 197 |     |         uint256 poolFeeUBA
 198 |     |     );
 199 |     | 
 200 |     |     /**
 201 |     |      * Redeemer started the redemption process and provided fassets.
 202 |     |      * The amount of fassets corresponding to valueUBA was burned.
 203 |     |      * Several RedemptionRequested events are emitted, one for every agent redeemed against
 204 |     |      * (but multiple tickets for the same agent are combined).
 205 |     |      * The agent's collateral is still locked.
 206 |     |      */
 207 |     |     event RedemptionRequested(
 208 |     |         address indexed agentVault,
 209 |     |         address indexed redeemer,
 210 |     |         uint256 indexed requestId,
 211 |     |         string paymentAddress,
 212 |     |         uint256 valueUBA,
 213 |     |         uint256 feeUBA,
 214 |     |         uint256 firstUnderlyingBlock,
 215 |     |         uint256 lastUnderlyingBlock,
 216 |     |         uint256 lastUnderlyingTimestamp,
 217 |     |         bytes32 paymentReference,
 218 |     |         address executor,
 219 |     |         uint256 executorFeeNatWei
 220 |     |     );
 221 |     | 
 222 |     |     /**
 223 |     |      * Agent rejected the redemption payment because the redeemer's address is invalid.
 224 |     |      */
 225 |     |     event RedemptionRejected(
 226 |     |         address indexed agentVault,
 227 |     |         address indexed redeemer,
 228 |     |         uint256 indexed requestId,
 229 |     |         uint256 redemptionAmountUBA
 230 |     |     );
 231 |     | 
 232 |     |     /**
 233 |     |      * In case there were not enough tickets or more than allowed number would have to be redeemed,
 234 |     |      * only partial redemption is done and the `remainingLots` lots of the fassets are returned to
 235 |     |      * the redeemer.
 236 |     |      */
 237 |     |     event RedemptionRequestIncomplete(
 238 |     |         address indexed redeemer,
 239 |     |         uint256 remainingLots
 240 |     |     );
 241 |     | 
 242 |     |     /**
 243 |     |      * Agent provided proof of redemption payment.
 244 |     |      * Agent's collateral is released.
 245 |     |      */
 246 |     |     event RedemptionPerformed(
 247 |     |         address indexed agentVault,
 248 |     |         address indexed redeemer,
 249 |     |         uint256 indexed requestId,
 250 |     |         bytes32 transactionHash,
 251 |     |         uint256 redemptionAmountUBA,
 252 |     |         int256 spentUnderlyingUBA
 253 |     |     );
 254 |     | 
 255 |     |     /**
 256 |     |      * The time for redemption payment is over and payment proof was not provided.
 257 |     |      * Redeemer was paid in the collateral (with extra).
 258 |     |      * The rest of the agent's collateral is released.
 259 |     |      * The corresponding amount of underlying currency, held by the agent, is released
 260 |     |      * and the agent can withdraw it (after underlying withdrawal announcement).
 261 |     |      */
 262 |     |     event RedemptionDefault(
 263 |     |         address indexed agentVault,
 264 |     |         address indexed redeemer,
 265 |     |         uint256 indexed requestId,
 266 |     |         uint256 redemptionAmountUBA,
 267 |     |         uint256 redeemedVaultCollateralWei,
 268 |     |         uint256 redeemedPoolCollateralWei
 269 |     |     );
 270 |     | 
 271 |     |     /**
 272 |     |      * Agent provided the proof that redemption payment was attempted, but failed due to
 273 |     |      * the redeemer's address being blocked (or burning more than allowed amount of gas).
 274 |     |      * Redeemer is not paid and all of the agent's collateral is released.
 275 |     |      * The underlying currency is also released to the agent.
 276 |     |      */
 277 |     |     event RedemptionPaymentBlocked(
 278 |     |         address indexed agentVault,
 279 |     |         address indexed redeemer,
 280 |     |         uint256 indexed requestId,
 281 |     |         bytes32 transactionHash,
 282 |     |         uint256 redemptionAmountUBA,
 283 |     |         int256 spentUnderlyingUBA
 284 |     |     );
 285 |     | 
 286 |     |     /**
 287 |     |      * Agent provided the proof that redemption payment was attempted, but failed due to
 288 |     |      * his own error. Also triggers payment default, unless the redeemer has done it already.
 289 |     |      */
 290 |     |     event RedemptionPaymentFailed(
 291 |     |         address indexed agentVault,
 292 |     |         address indexed redeemer,
 293 |     |         uint256 indexed requestId,
 294 |     |         bytes32 transactionHash,
 295 |     |         int256 spentUnderlyingUBA,
 296 |     |         string failureReason
 297 |     |     );
 298 |     | 
 299 |     |     /**
 300 |     |      * At the end of a successful redemption, part of the redemption fee is re-minted as FAssets
 301 |     |      * and paid to the agent's collateral pool as fee.
 302 |     |      */
 303 |     |     event RedemptionPoolFeeMinted(
 304 |     |         address indexed agentVault,
 305 |     |         uint256 indexed requestId,
 306 |     |         uint256 poolFeeUBA
 307 |     |     );
 308 |     | 
 309 |     |     /**
 310 |     |      * Due to self-close exit, some of the agent's backed fAssets were redeemed,
 311 |     |      * but the redemption was immediately paid in collateral so no redemption process is started.
 312 |     |      */
 313 |     |     event RedeemedInCollateral(
 314 |     |         address indexed agentVault,
 315 |     |         address indexed redeemer,
 316 |     |         uint256 redemptionAmountUBA,
 317 |     |         uint256 paidVaultCollateralWei
 318 |     |     );
 319 |     | 
 320 |     |     /**
 321 |     |      * Agent self-closed valueUBA of backing fassets.
 322 |     |      */
 323 |     |     event SelfClose(address indexed agentVault, uint256 valueUBA);
 324 |     | 
 325 |     |     /**
 326 |     |      * Redemption ticket with given value was created (when minting was executed).
 327 |     |      */
 328 |     |     event RedemptionTicketCreated(
 329 |     |         address indexed agentVault,
 330 |     |         uint256 indexed redemptionTicketId,
 331 |     |         uint256 ticketValueUBA
 332 |     |     );
 333 |     | 
 334 |     |     /**
 335 |     |      * Redemption ticket value was changed (partially redeemed).
 336 |     |      * @param ticketValueUBA the ticket value after update
 337 |     |      */
 338 |     |     event RedemptionTicketUpdated(
 339 |     |         address indexed agentVault,
 340 |     |         uint256 indexed redemptionTicketId,
 341 |     |         uint256 ticketValueUBA
 342 |     |     );
 343 |     | 
 344 |     |     /**
 345 |     |      * Redemption ticket was deleted.
 346 |     |      */
 347 |     |     event RedemptionTicketDeleted(
 348 |     |         address indexed agentVault,
 349 |     |         uint256 indexed redemptionTicketId
 350 |     |     );
 351 |     | 
 352 |     |     /**
 353 |     |      * Method `consolidateSmallTickets` has finished.
 354 |     |      * @param firstTicketId first handled ticket id (different from the method param _firstTicketId if it was 0).
 355 |     |      * @param nextTicketId the first remaining (not handled) ticket id, or 0 if the end of queue was reached.
 356 |     |      */
 357 |     |     event RedemptionTicketsConsolidated(
 358 |     |         uint256 firstTicketId,
 359 |     |         uint256 nextTicketId
 360 |     |     );
 361 |     | 
 362 |     |     /**
 363 |     |      * Due to lot size change, some dust was created for this agent during
 364 |     |      * redemption. Value `dustUBA` is the new amount of dust. Dust cannot be directly redeemed,
 365 |     |      * but it can be self-closed or liquidated and if it accumulates to more than 1 lot,
 366 |     |      * it can be converted to a new redemption ticket.
 367 |     |      */
 368 |     |     event DustChanged(address indexed agentVault, uint256 dustUBA);
 369 |     | 
 370 |     |     /**
 371 |     |      * Agent entered liquidation state due to unhealthy position.
 372 |     |      * The liquidation ends when the agent is again healthy or the agent's position is fully liquidated.
 373 |     |      */
 374 |     |     event LiquidationStarted(address indexed agentVault, uint256 timestamp);
 375 |     | 
 376 |     |     /**
 377 |     |      * Agent entered liquidation state due to illegal payment.
 378 |     |      * Full liquidation will always liquidate the whole agent's position and
 379 |     |      * the agent can never use the same vault and underlying address for minting again.
 380 |     |      */
 381 |     |     event FullLiquidationStarted(address indexed agentVault, uint256 timestamp);
 382 |     | 
 383 |     |     /**
 384 |     |      * Some of the agent's position was liquidated, by burning liquidator's fassets.
 385 |     |      * Liquidator was paid in collateral with extra.
 386 |     |      * The corresponding amount of underlying currency, held by the agent, is released
 387 |     |      * and the agent can withdraw it (after underlying withdrawal announcement).
 388 |     |      */
 389 |     |     event LiquidationPerformed(
 390 |     |         address indexed agentVault,
 391 |     |         address indexed liquidator,
 392 |     |         uint256 valueUBA,
 393 |     |         uint256 paidVaultCollateralWei,
 394 |     |         uint256 paidPoolCollateralWei
 395 |     |     );
 396 |     | 
 397 |     |     /**
 398 |     |      * Agent exited liquidation state as agent's position was healthy again and not in full liquidation.
 399 |     |      */
 400 |     |     event LiquidationEnded(address indexed agentVault);
 401 |     | 
 402 |     |     /**
 403 |     |      * Part of the balance in the agent's underlying address is "free balance" that the agent can withdraw.
 404 |     |      * It is obtained from minting / redemption fees and self-closed fassets.
 405 |     |      * Some of this amount should be left for paying redemption (and withdrawal) gas fees,
 406 |     |      * and the rest can be withdrawn by the agent.
 407 |     |      * However, withdrawal has to be announced, otherwise it can be challenged as illegal payment.
 408 |     |      * Only one announcement can exist per agent - agent has to present payment proof for withdrawal
 409 |     |      * before starting a new one.
 410 |     |      */
 411 |     |     event UnderlyingWithdrawalAnnounced(
 412 |     |         address indexed agentVault,
 413 |     |         uint256 indexed announcementId,
 414 |     |         bytes32 paymentReference
 415 |     |     );
 416 |     | 
 417 |     |     /**
 418 |     |      * After announcing legal underlying withdrawal and creating transaction,
 419 |     |      * the agent must confirm the transaction. This frees the announcement so the agent can create another one.
 420 |     |      * If the agent doesn't confirm in time, anybody can confirm the transaction after several hours.
 421 |     |      * Failed payments must also be confirmed.
 422 |     |      */
 423 |     |     event UnderlyingWithdrawalConfirmed(
 424 |     |         address indexed agentVault,
 425 |     |         uint256 indexed announcementId,
 426 |     |         int256 spentUBA,
 427 |     |         bytes32 transactionHash
 428 |     |     );
 429 |     | 
 430 |     |     /**
 431 |     |      * After announcing legal underlying withdrawal agent can cancel ongoing withdrawal.
 432 |     |      * The reason for doing that would be in resetting announcement timestamp due to any problems with underlying
 433 |     |      * withdrawal - in order to prevent others to confirm withdrawal before agent and get some of his collateral.
 434 |     |      */
 435 |     |     event UnderlyingWithdrawalCancelled(
 436 |     |         address indexed agentVault,
 437 |     |         uint256 indexed announcementId
 438 |     |     );
 439 |     | 
 440 |     |     /**
 441 |     |      * Emitted when the agent tops up the underlying address balance.
 442 |     |      */
 443 |     |     event UnderlyingBalanceToppedUp(
 444 |     |         address indexed agentVault,
 445 |     |         bytes32 transactionHash,
 446 |     |         uint256 depositedUBA
 447 |     |     );
 448 |     | 
 449 |     |     /**
 450 |     |      * Emitted whenever the tracked underlying balance changes.
 451 |     |      */
 452 |     |     event UnderlyingBalanceChanged(
 453 |     |         address indexed agentVault,
 454 |     |         int256 underlyingBalanceUBA
 455 |     |     );
 456 |     | 
 457 |     |     /**
 458 |     |      * An unexpected transaction from the agent's underlying address was proved.
 459 |     |      * Whole agent's position goes into liquidation.
 460 |     |      * The challenger is rewarded from the agent's collateral.
 461 |     |      */
 462 |     |     event IllegalPaymentConfirmed(
 463 |     |         address indexed agentVault,
 464 |     |         bytes32 transactionHash
 465 |     |     );
 466 |     | 
 467 |     |     /**
 468 |     |      * Two transactions with the same payment reference, both from the agent's underlying address, were proved.
 469 |     |      * Whole agent's position goes into liquidation.
 470 |     |      * The challenger is rewarded from the agent's collateral.
 471 |     |      */
 472 |     |     event DuplicatePaymentConfirmed(
 473 |     |         address indexed agentVault,
 474 |     |         bytes32 transactionHash1,
 475 |     |         bytes32 transactionHash2
 476 |     |     );
 477 |     | 
 478 |     |     /**
 479 |     |      * Agent's underlying balance became lower than required for backing f-assets (either through payment or via
 480 |     |      * a challenge. Agent goes to a full liquidation.
 481 |     |      * The challenger is rewarded from the agent's collateral.
 482 |     |      */
 483 |     |     event UnderlyingBalanceTooLow(
 484 |     |         address indexed agentVault,
 485 |     |         int256 balance,
 486 |     |         uint256 requiredBalance
 487 |     |     );
 488 |     | 
 489 |     |     /**
 490 |     |      * A setting has changed.
 491 |     |      */
 492 |     |     event SettingChanged(string name, uint256 value);
 493 |     | 
 494 |     |     /**
 495 |     |      * A setting has changed.
 496 |     |      */
 497 |     |     event SettingArrayChanged(string name, uint256[] value);
 498 |     | 
 499 |     |     /**
 500 |     |      * A contract in the settings has changed.
 501 |     |      */
 502 |     |     event ContractChanged(string name, address value);
 503 |     | 
 504 |     |     /**
 505 |     |      * Current underlying block number or timestamp has been updated.
 506 |     |      */
 507 |     |     event CurrentUnderlyingBlockUpdated(
 508 |     |         uint256 underlyingBlockNumber,
 509 |     |         uint256 underlyingBlockTimestamp,
 510 |     |         uint256 updatedAt
 511 |     |     );
 512 |     | 
 513 |     |     /**
 514 |     |      * New collateral token has been added.
 515 |     |      */
 516 |     |     event CollateralTypeAdded(
 517 |     |         uint8 collateralClass,
 518 |     |         address token,
 519 |     |         uint256 decimals,
 520 |     |         bool directPricePair,
 521 |     |         string assetFtsoSymbol,
 522 |     |         string tokenFtsoSymbol,
 523 |     |         uint256 minCollateralRatioBIPS,
 524 |     |         uint256 safetyMinCollateralRatioBIPS
 525 |     |     );
 526 |     | 
 527 |     |     /**
 528 |     |      * System defined collateral ratios for the token have changed (minimal and safety collateral ratio).
 529 |     |      */
 530 |     |     event CollateralRatiosChanged(
 531 |     |         uint8 collateralClass,
 532 |     |         address collateralToken,
 533 |     |         uint256 minCollateralRatioBIPS,
 534 |     |         uint256 safetyMinCollateralRatioBIPS
 535 |     |     );
 536 |     | 
 537 |     |     /**
 538 |     |      * Emergency pause was triggered.
 539 |     |      */
 540 |     |     event EmergencyPauseTriggered(
 541 |     |         EmergencyPause.Level externalLevel,
 542 |     |         uint256 externalPausedUntil,
 543 |     |         EmergencyPause.Level governanceLevel,
 544 |     |         uint256 governancePausedUntil
 545 |     |     );
 546 |     | 
 547 |     |     /**
 548 |     |      * Emergency pause was canceled.
 549 |     |      */
 550 |     |     event EmergencyPauseCanceled();
 551 |     | }
 552 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IBalanceDecreasingTransaction.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | /**
   5 |     |  * @custom:name IBalanceDecreasingTransaction
   6 |     |  * @custom:id 0x02
   7 |     |  * @custom:supported BTC, DOGE, XRP
   8 |     |  * @author Flare
   9 |     |  * @notice A detection of a transaction that either decreases the balance for some address or is
  10 |     |  * signed by the source address.
  11 |     |  * Such an attestation could prove a violation of an agreement and therefore provides grounds to liquidate
  12 |     |  * some funds locked by a smart contract on Flare.
  13 |     |  *
  14 |     |  * A transaction is considered balance decreasing for the address, if the balance after the
  15 |     |  * transaction is lower than before or the address is among the signers of the transaction
  16 |     |  * (even if its balance is greater than before the transaction).
  17 |     |  * @custom:verification The transaction with `transactionId` is fetched from the API of the
  18 |     |  * source blockchain node or relevant indexer.
  19 |     |  * If the transaction cannot be fetched or the transaction is in a block that does not have a
  20 |     |  * sufficient number of confirmations, the attestation request is rejected.
  21 |     |  *
  22 |     |  * Once the transaction is received, the response fields are extracted if the transaction is balance
  23 |     |  * decreasing for the indicated address.
  24 |     |  * Some of the request and response fields are chain specific as described below.
  25 |     |  * The fields can be computed with the help of a balance decreasing summary.
  26 |     |  *
  27 |     |  * ### UTXO (Bitcoin and Dogecoin)
  28 |     |  *
  29 |     |  * - `sourceAddressIndicator` is the the index of the transaction input in hex padded to a 0x prefixed 32-byte string.
  30 |     |  * If the indicated input does not exist or the indicated input does not have the address,
  31 |     |  * the attestation request is rejected.
  32 |     |  * The `sourceAddress` is the address of the indicated transaction input.
  33 |     |  * - `spentAmount` is the sum of values of all inputs with sourceAddress minus the sum of
  34 |     |  * all outputs with `sourceAddress`.
  35 |     |  * Can be negative.
  36 |     |  * - `blockTimestamp` is the mediantime of a block.
  37 |     |  *
  38 |     |  * ### XRPL
  39 |     |  *
  40 |     |  * - `sourceAddressIndicator` is the standard address hash of the address whose balance has been decreased.
  41 |     |  * If the address indicated by `sourceAddressIndicator` is not among the signers of the transaction and the balance
  42 |     |  * of the address was not lowered in the transaction, the attestation request is rejected.
  43 |     |  *
  44 |     |  * - `spentAmount` is the difference between the balance of the indicated address after and before the transaction.
  45 |     |  * Can be negative.
  46 |     |  * - `blockTimestamp` is the close_time of a ledger converted to unix time.
  47 |     |  *
  48 |     |  * @custom:lut `blockTimestamp`
  49 |     |  * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`
  50 |     |  */
  51 |     | interface IBalanceDecreasingTransaction {
  52 |     |     /**
  53 |     |      * @notice Toplevel request
  54 |     |      * @param attestationType ID of the attestation type.
  55 |     |      * @param sourceId ID of the data source.
  56 |     |      * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.
  57 |     |      * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.
  58 |     |      */
  59 |     |     struct Request {
  60 |     |         bytes32 attestationType;
  61 |     |         bytes32 sourceId;
  62 |     |         bytes32 messageIntegrityCode;
  63 |     |         RequestBody requestBody;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @notice Toplevel response
  68 |     |      * @param attestationType Extracted from the request.
  69 |     |      * @param sourceId Extracted from the request.
  70 |     |      * @param votingRound The ID of the State Connector round in which the request was considered.
  71 |     |      * This is a security measure to prevent a collision of attestation hashes.
  72 |     |      * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
  73 |     |      * @param requestBody Extracted from the request.
  74 |     |      * @param responseBody Data defining the response. The verification rules for the construction of the
  75 |     |      * response body and the type are defined per specific `attestationType`.
  76 |     |      */
  77 |     |     struct Response {
  78 |     |         bytes32 attestationType;
  79 |     |         bytes32 sourceId;
  80 |     |         uint64 votingRound;
  81 |     |         uint64 lowestUsedTimestamp;
  82 |     |         RequestBody requestBody;
  83 |     |         ResponseBody responseBody;
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @notice Toplevel proof
  88 |     |      * @param merkleProof Merkle proof corresponding to the attestation response.
  89 |     |      * @param data Attestation response.
  90 |     |      */
  91 |     |     struct Proof {
  92 |     |         bytes32[] merkleProof;
  93 |     |         Response data;
  94 |     |     }
  95 |     | 
  96 |     |     /**
  97 |     |      * @notice Request body for IBalanceDecreasingTransaction attestation type
  98 |     |      * @param transactionId ID of the payment transaction.
  99 |     |      * @param sourceAddressIndicator The indicator of the address whose balance has been decreased.
 100 |     |      */
 101 |     |     struct RequestBody {
 102 |     |         bytes32 transactionId;
 103 |     |         bytes32 sourceAddressIndicator;
 104 |     |     }
 105 |     | 
 106 |     |     /**
 107 |     |      * @notice Response body for IBalanceDecreasingTransaction attestation type.
 108 |     |      * @param blockNumber The number of the block in which the transaction is included.
 109 |     |      * @param blockTimestamp The timestamp of the block in which the transaction is included.
 110 |     |      * @param sourceAddressHash Standard address hash of the address indicated by the `sourceAddressIndicator`.
 111 |     |      * @param spentAmount Amount spent by the source address in minimal units.
 112 |     |      * @param standardPaymentReference Standard payment reference of the transaction.
 113 |     |      */
 114 |     |     struct ResponseBody {
 115 |     |         uint64 blockNumber;
 116 |     |         uint64 blockTimestamp;
 117 |     |         bytes32 sourceAddressHash;
 118 |     |         int256 spentAmount;
 119 |     |         bytes32 standardPaymentReference;
 120 |     |     }
 121 |     | }
 122 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IBalanceDecreasingTransactionVerification.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "./IBalanceDecreasingTransaction.sol";
  5 |     | 
  6 |     | interface IBalanceDecreasingTransactionVerification {
  7 |     |     function verifyBalanceDecreasingTransaction(
  8 |     |         IBalanceDecreasingTransaction.Proof calldata _proof
  9 |     |     ) external view returns (bool _proved);
 10 |     | }
 11 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IBn256.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | // G1Point implements a point in G1 group.
  5 |     | struct G1Point {
  6 |     |     uint256 x;
  7 |     |     uint256 y;
  8 |     | }
  9 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IClaimSetupManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | import "./IDelegationAccount.sol";
   5 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   6 |     | 
   7 |     | interface IClaimSetupManager {
   8 |     |     event DelegationAccountCreated(
   9 |     |         address owner,
  10 |     |         IDelegationAccount delegationAccount
  11 |     |     );
  12 |     |     event DelegationAccountUpdated(
  13 |     |         address owner,
  14 |     |         IDelegationAccount delegationAccount,
  15 |     |         bool enabled
  16 |     |     );
  17 |     |     event ClaimExecutorsChanged(address owner, address[] executors);
  18 |     |     event AllowedClaimRecipientsChanged(address owner, address[] recipients);
  19 |     |     event ClaimExecutorFeeValueChanged(
  20 |     |         address executor,
  21 |     |         uint256 validFromRewardEpoch,
  22 |     |         uint256 feeValueWei
  23 |     |     );
  24 |     |     event ExecutorRegistered(address executor);
  25 |     |     event ExecutorUnregistered(address executor, uint256 validFromRewardEpoch);
  26 |     |     event MinFeeSet(uint256 minFeeValueWei);
  27 |     |     event MaxFeeSet(uint256 maxFeeValueWei);
  28 |     |     event RegisterExecutorFeeSet(uint256 registerExecutorFeeValueWei);
  29 |     |     event SetExecutorsExcessAmountRefunded(address owner, uint256 excessAmount);
  30 |     | 
  31 |     |     /**
  32 |     |      * @notice Sets the addresses of executors and optionally enables (creates) delegation account.
  33 |     |      * @notice If setting registered executors some fee must be paid to them.
  34 |     |      * @param _executors        The new executors. All old executors will be deleted and replaced by these.
  35 |     |      */
  36 |     |     function setAutoClaiming(
  37 |     |         address[] memory _executors,
  38 |     |         bool _enableDelegationAccount
  39 |     |     ) external payable;
  40 |     | 
  41 |     |     /**
  42 |     |      * @notice Sets the addresses of executors.
  43 |     |      * @notice If setting registered executors some fee must be paid to them.
  44 |     |      * @param _executors        The new executors. All old executors will be deleted and replaced by these.
  45 |     |      */
  46 |     |     function setClaimExecutors(address[] memory _executors) external payable;
  47 |     | 
  48 |     |     /**
  49 |     |      * Set the addresses of allowed recipients.
  50 |     |      * Apart from these, the owner is always an allowed recipient.
  51 |     |      * @param _recipients The new allowed recipients. All old recipients will be deleted and replaced by these.
  52 |     |      */
  53 |     |     function setAllowedClaimRecipients(address[] memory _recipients) external;
  54 |     | 
  55 |     |     /**
  56 |     |      * @notice Enables (creates) delegation account contract,
  57 |     |      * i.e. all airdrop and ftso rewards will be send to delegation account when using automatic claiming.
  58 |     |      * @return Address of delegation account contract.
  59 |     |      */
  60 |     |     function enableDelegationAccount() external returns (IDelegationAccount);
  61 |     | 
  62 |     |     /**
  63 |     |      * @notice Disables delegation account contract,
  64 |     |      * i.e. all airdrop and ftso rewards will be send to owner's account when using automatic claiming.
  65 |     |      * @notice Automatic claiming will not claim airdrop and ftso rewards for delegation account anymore.
  66 |     |      * @dev Reverts if there is no delegation account
  67 |     |      */
  68 |     |     function disableDelegationAccount() external;
  69 |     | 
  70 |     |     /**
  71 |     |      * @notice Allows executor to register and set initial fee value.
  72 |     |      * If executor was already registered before (has fee set), only update fee after `feeValueUpdateOffset`.
  73 |     |      * @notice Executor must pay fee in order to register - `registerExecutorFeeValueWei`.
  74 |     |      * @param _feeValue    number representing fee value
  75 |     |      * @return Returns the reward epoch number when the setting becomes effective.
  76 |     |      */
  77 |     |     function registerExecutor(
  78 |     |         uint256 _feeValue
  79 |     |     ) external payable returns (uint256);
  80 |     | 
  81 |     |     /**
  82 |     |      * @notice Allows executor to unregister.
  83 |     |      * @return Returns the reward epoch number when the setting becomes effective.
  84 |     |      */
  85 |     |     function unregisterExecutor() external returns (uint256);
  86 |     | 
  87 |     |     /**
  88 |     |      * @notice Allows registered executor to set (or update last scheduled) fee value.
  89 |     |      * @param _feeValue    number representing fee value
  90 |     |      * @return Returns the reward epoch number when the setting becomes effective.
  91 |     |      */
  92 |     |     function updateExecutorFeeValue(
  93 |     |         uint256 _feeValue
  94 |     |     ) external returns (uint256);
  95 |     | 
  96 |     |     /**
  97 |     |      * @notice Delegate `_bips` of voting power to `_to` from msg.sender's delegation account
  98 |     |      * @param _to The address of the recipient
  99 |     |      * @param _bips The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).
 100 |     |      *   Not cumulative - every call resets the delegation value (and value of 0 revokes delegation).
 101 |     |      */
 102 |     |     function delegate(address _to, uint256 _bips) external;
 103 |     | 
 104 |     |     /**
 105 |     |      * @notice Undelegate all percentage delegations from the msg.sender's delegation account and then delegate
 106 |     |      *   corresponding `_bips` percentage of voting power to each member of `_delegatees`.
 107 |     |      * @param _delegatees The addresses of the new recipients.
 108 |     |      * @param _bips The percentages of voting power to be delegated expressed in basis points (1/100 of one percent).
 109 |     |      *   Total of all `_bips` values must be at most 10000.
 110 |     |      */
 111 |     |     function batchDelegate(
 112 |     |         address[] memory _delegatees,
 113 |     |         uint256[] memory _bips
 114 |     |     ) external;
 115 |     | 
 116 |     |     /**
 117 |     |      * @notice Undelegate all voting power for delegates of msg.sender's delegation account
 118 |     |      */
 119 |     |     function undelegateAll() external;
 120 |     | 
 121 |     |     /**
 122 |     |      * @notice Revoke all delegation from msg.sender's delegation account to `_who` at given block.
 123 |     |      *    Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.
 124 |     |      *    Block `_blockNumber` must be in the past.
 125 |     |      *    This method should be used only to prevent rogue delegate voting in the current voting block.
 126 |     |      *    To stop delegating use delegate with value of 0 or undelegateAll.
 127 |     |      */
 128 |     |     function revokeDelegationAt(address _who, uint256 _blockNumber) external;
 129 |     | 
 130 |     |     /**
 131 |     |      * @notice Delegate all governance vote power of msg.sender's delegation account to `_to`.
 132 |     |      * @param _to The address of the recipient
 133 |     |      */
 134 |     |     function delegateGovernance(address _to) external;
 135 |     | 
 136 |     |     /**
 137 |     |      * @notice Undelegate governance vote power for delegate of msg.sender's delegation account
 138 |     |      */
 139 |     |     function undelegateGovernance() external;
 140 |     | 
 141 |     |     /**
 142 |     |      * @notice Allows user to transfer WNat to owner's account.
 143 |     |      * @param _amount           Amount of tokens to transfer
 144 |     |      */
 145 |     |     function withdraw(uint256 _amount) external;
 146 |     | 
 147 |     |     /**
 148 |     |      * @notice Allows user to transfer balance of ERC20 tokens owned by the personal delegation contract.
 149 |     |      The main use case is to transfer tokens/NFTs that were received as part of an airdrop or register 
 150 |     |      as participant in such airdrop.
 151 |     |      * @param _token            Target token contract address
 152 |     |      * @param _amount           Amount of tokens to transfer
 153 |     |      * @dev Reverts if target token is WNat contract - use method `withdraw` for that
 154 |     |      */
 155 |     |     function transferExternalToken(IERC20 _token, uint256 _amount) external;
 156 |     | 
 157 |     |     /**
 158 |     |      * @notice Gets the delegation account of the `_owner`. Returns address(0) if not created yet.
 159 |     |      */
 160 |     |     function accountToDelegationAccount(
 161 |     |         address _owner
 162 |     |     ) external view returns (address);
 163 |     | 
 164 |     |     /**
 165 |     |      * @notice Gets the delegation account data for the `_owner`. Returns address(0) if not created yet.
 166 |     |      * @param _owner                        owner's address
 167 |     |      * @return _delegationAccount           owner's delegation account address - could be address(0)
 168 |     |      * @return _enabled                     indicates if delegation account is enabled
 169 |     |      */
 170 |     |     function getDelegationAccountData(
 171 |     |         address _owner
 172 |     |     )
 173 |     |         external
 174 |     |         view
 175 |     |         returns (IDelegationAccount _delegationAccount, bool _enabled);
 176 |     | 
 177 |     |     /**
 178 |     |      * @notice Get the addresses of executors.
 179 |     |      */
 180 |     |     function claimExecutors(
 181 |     |         address _owner
 182 |     |     ) external view returns (address[] memory);
 183 |     | 
 184 |     |     /**
 185 |     |      * Get the addresses of allowed recipients.
 186 |     |      * Apart from these, the owner is always an allowed recipient.
 187 |     |      */
 188 |     |     function allowedClaimRecipients(
 189 |     |         address _rewardOwner
 190 |     |     ) external view returns (address[] memory);
 191 |     | 
 192 |     |     /**
 193 |     |      * @notice Returns info if `_executor` is allowed to execute calls for `_owner`
 194 |     |      */
 195 |     |     function isClaimExecutor(
 196 |     |         address _owner,
 197 |     |         address _executor
 198 |     |     ) external view returns (bool);
 199 |     | 
 200 |     |     /**
 201 |     |      * @notice Get registered executors
 202 |     |      */
 203 |     |     function getRegisteredExecutors(
 204 |     |         uint256 _start,
 205 |     |         uint256 _end
 206 |     |     )
 207 |     |         external
 208 |     |         view
 209 |     |         returns (address[] memory _registeredExecutors, uint256 _totalLength);
 210 |     | 
 211 |     |     /**
 212 |     |      * @notice Returns some info about the `_executor`
 213 |     |      * @param _executor             address representing executor
 214 |     |      * @return _registered          information if executor is registered
 215 |     |      * @return _currentFeeValue     executor's current fee value
 216 |     |      */
 217 |     |     function getExecutorInfo(
 218 |     |         address _executor
 219 |     |     ) external view returns (bool _registered, uint256 _currentFeeValue);
 220 |     | 
 221 |     |     /**
 222 |     |      * @notice Returns the current fee value of `_executor`
 223 |     |      * @param _executor             address representing executor
 224 |     |      */
 225 |     |     function getExecutorCurrentFeeValue(
 226 |     |         address _executor
 227 |     |     ) external view returns (uint256);
 228 |     | 
 229 |     |     /**
 230 |     |      * @notice Returns the fee value of `_executor` at `_rewardEpoch`
 231 |     |      * @param _executor             address representing executor
 232 |     |      * @param _rewardEpoch          reward epoch number
 233 |     |      */
 234 |     |     function getExecutorFeeValue(
 235 |     |         address _executor,
 236 |     |         uint256 _rewardEpoch
 237 |     |     ) external view returns (uint256);
 238 |     | 
 239 |     |     /**
 240 |     |      * @notice Returns the scheduled fee value changes of `_executor`
 241 |     |      * @param _executor             address representing executor
 242 |     |      * @return _feeValue            positional array of fee values
 243 |     |      * @return _validFromEpoch      positional array of reward epochs the fee settings are effective from
 244 |     |      * @return _fixed               positional array of boolean values indicating if settings are subjected to change
 245 |     |      */
 246 |     |     function getExecutorScheduledFeeValueChanges(
 247 |     |         address _executor
 248 |     |     )
 249 |     |         external
 250 |     |         view
 251 |     |         returns (
 252 |     |             uint256[] memory _feeValue,
 253 |     |             uint256[] memory _validFromEpoch,
 254 |     |             bool[] memory _fixed
 255 |     |         );
 256 |     | }
 257 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IConfirmedBlockHeightExists.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | /**
   5 |     |  * @custom:name IConfirmedBlockHeightExists
   6 |     |  * @custom:id 0x02
   7 |     |  * @custom:supported BTC, DOGE, XRP
   8 |     |  * @author Flare
   9 |     |  * @notice An assertion that a block with `blockNumber` is confirmed.
  10 |     |  * It also provides data to compute the block production rate in the given time range.
  11 |     |  * @custom:verification It is checked that the block with `blockNumber` is confirmed by at
  12 |     |  * least `numberOfConfirmations`.
  13 |     |  * If it is not, the request is rejected. We note a block on the tip of the chain is confirmed by 1 block.
  14 |     |  * Then `lowestQueryWindowBlock` is determined and its number and timestamp are extracted.
  15 |     |  *
  16 |     |  *
  17 |     |  * Current confirmation heights consensus:
  18 |     |  *
  19 |     |  *
  20 |     |  * | `Chain` | `chainId` | `numberOfConfirmations` | `timestamp ` |
  21 |     |  * | ------- | --------- | ----------------------- | ------------ |
  22 |     |  * | `BTC`   | 0         | 6                       | mediantime   |
  23 |     |  * | `DOGE`  | 2         | 60                      | mediantime   |
  24 |     |  * | `XRP`   | 3         | 3                       | close_time   |
  25 |     |  *
  26 |     |  *
  27 |     |  * @custom:lut `lowestQueryWindowBlockTimestamp`
  28 |     |  * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`
  29 |     |  */
  30 |     | interface IConfirmedBlockHeightExists {
  31 |     |     /**
  32 |     |      * @notice Toplevel request
  33 |     |      * @param attestationType ID of the attestation type.
  34 |     |      * @param sourceId ID of the data source.
  35 |     |      * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response as defined.
  36 |     |      * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.
  37 |     |      */
  38 |     |     struct Request {
  39 |     |         bytes32 attestationType;
  40 |     |         bytes32 sourceId;
  41 |     |         bytes32 messageIntegrityCode;
  42 |     |         RequestBody requestBody;
  43 |     |     }
  44 |     | 
  45 |     |     /**
  46 |     |      * @notice Toplevel response
  47 |     |      * @param attestationType Extracted from the request.
  48 |     |      * @param sourceId Extracted from the request.
  49 |     |      * @param votingRound The ID of the State Connector round in which the request was considered.
  50 |     |      * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
  51 |     |      * @param requestBody Extracted from the request.
  52 |     |      * @param responseBody Data defining the response. The verification rules for the construction of the
  53 |     |      * response body and the type are defined per specific `attestationType`.
  54 |     |      */
  55 |     |     struct Response {
  56 |     |         bytes32 attestationType;
  57 |     |         bytes32 sourceId;
  58 |     |         uint64 votingRound;
  59 |     |         uint64 lowestUsedTimestamp;
  60 |     |         RequestBody requestBody;
  61 |     |         ResponseBody responseBody;
  62 |     |     }
  63 |     | 
  64 |     |     /**
  65 |     |      * @notice Toplevel proof
  66 |     |      * @param merkleProof Merkle proof corresponding to the attestation response.
  67 |     |      * @param data Attestation response.
  68 |     |      */
  69 |     |     struct Proof {
  70 |     |         bytes32[] merkleProof;
  71 |     |         Response data;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @notice Request body for ConfirmedBlockHeightExistsType attestation type
  76 |     |      * @param blockNumber The number of the block the request wants a confirmation of.
  77 |     |      * @param queryWindow The length of the period in which the block production rate is to be computed.
  78 |     |      */
  79 |     |     struct RequestBody {
  80 |     |         uint64 blockNumber;
  81 |     |         uint64 queryWindow;
  82 |     |     }
  83 |     | 
  84 |     |     /**
  85 |     |      * @notice Response body for ConfirmedBlockHeightExistsType attestation type
  86 |     |      * @custom:below `blockNumber`, `lowestQueryWindowBlockNumber`, `blockTimestamp`, `lowestQueryWindowBlockTimestamp`
  87 |     |      * can be used to compute the average block production time in the specified block range.
  88 |     |      * @param blockTimestamp The timestamp of the block with `blockNumber`.
  89 |     |      * @param numberOfConfirmations The depth at which a block is considered confirmed depending on the chain.
  90 |     |      * All attestation providers must agree on this number.
  91 |     |      * @param lowestQueryWindowBlockNumber The block number of the latest block that has a timestamp strictly smaller
  92 |     |      * than `blockTimestamp` - `queryWindow`.
  93 |     |      * @param lowestQueryWindowBlockTimestamp The timestamp of the block at height `lowestQueryWindowBlockNumber`.
  94 |     |      */
  95 |     |     struct ResponseBody {
  96 |     |         uint64 blockTimestamp;
  97 |     |         uint64 numberOfConfirmations;
  98 |     |         uint64 lowestQueryWindowBlockNumber;
  99 |     |         uint64 lowestQueryWindowBlockTimestamp;
 100 |     |     }
 101 |     | }
 102 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IConfirmedBlockHeightExistsVerification.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "./IConfirmedBlockHeightExists.sol";
  5 |     | 
  6 |     | interface IConfirmedBlockHeightExistsVerification {
  7 |     |     function verifyConfirmedBlockHeightExists(
  8 |     |         IConfirmedBlockHeightExists.Proof calldata _proof
  9 |     |     ) external view returns (bool _proved);
 10 |     | }
 11 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/ICoreVaultClient.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | import {IPayment} from ".//IFdcVerification.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * Core vault
   8 |     |  */
   9 |     | interface ICoreVaultClient {
  10 |     |     /**
  11 |     |      * Agent has requested transfer of (some of) their backing to the core vault.
  12 |     |      */
  13 |     |     event TransferToCoreVaultStarted(
  14 |     |         address indexed agentVault,
  15 |     |         uint256 indexed transferRedemptionRequestId,
  16 |     |         uint256 valueUBA
  17 |     |     );
  18 |     | 
  19 |     |     /**
  20 |     |      * Agent has cancelled transfer to the core vault without paying.
  21 |     |      * The amount of `valueUBA` has been re-minted./
  22 |     |      */
  23 |     |     event TransferToCoreVaultDefaulted(
  24 |     |         address indexed agentVault,
  25 |     |         uint256 indexed transferRedemptionRequestId,
  26 |     |         uint256 remintedUBA
  27 |     |     );
  28 |     | 
  29 |     |     /**
  30 |     |      * The transfer of underlying to the core vault was successfully completed.
  31 |     |      */
  32 |     |     event TransferToCoreVaultSuccessful(
  33 |     |         address indexed agentVault,
  34 |     |         uint256 indexed transferRedemptionRequestId,
  35 |     |         uint256 valueUBA
  36 |     |     );
  37 |     | 
  38 |     |     /**
  39 |     |      * The agent has requested return of some of the underlying from the core vault to the agent's underlying address.
  40 |     |      */
  41 |     |     event ReturnFromCoreVaultRequested(
  42 |     |         address indexed agentVault,
  43 |     |         uint256 indexed requestId,
  44 |     |         bytes32 paymentReference,
  45 |     |         uint256 valueUBA
  46 |     |     );
  47 |     | 
  48 |     |     /**
  49 |     |      * The agent has cancelled the return request.
  50 |     |      */
  51 |     |     event ReturnFromCoreVaultCancelled(
  52 |     |         address indexed agentVault,
  53 |     |         uint256 indexed requestId
  54 |     |     );
  55 |     | 
  56 |     |     /**
  57 |     |      * The payment from core vault to the agent's underlying address has been confirmed.
  58 |     |      */
  59 |     |     event ReturnFromCoreVaultConfirmed(
  60 |     |         address indexed agentVault,
  61 |     |         uint256 indexed requestId,
  62 |     |         uint256 receivedUnderlyingUBA,
  63 |     |         uint256 remintedUBA
  64 |     |     );
  65 |     | 
  66 |     |     /**
  67 |     |      * Redemption was requested from a core vault.
  68 |     |      * Can only be redeemed to a payment address from to the `allowedDestinations` list in the core vault manager.
  69 |     |      */
  70 |     |     event CoreVaultRedemptionRequested(
  71 |     |         address indexed redeemer,
  72 |     |         string paymentAddress,
  73 |     |         bytes32 paymentReference,
  74 |     |         uint256 valueUBA,
  75 |     |         uint256 feeUBA
  76 |     |     );
  77 |     | 
  78 |     |     /**
  79 |     |      * Agent can transfer their backing to core vault.
  80 |     |      * They then get a redemption requests which the owner pays just like any other redemption request.
  81 |     |      * After that, the agent's collateral is released.
  82 |     |      * NOTE: only agent vault owner can call
  83 |     |      * @param _agentVault the agent vault address
  84 |     |      * @param _amountUBA the amount to transfer to the core vault
  85 |     |      */
  86 |     |     function transferToCoreVault(
  87 |     |         address _agentVault,
  88 |     |         uint256 _amountUBA
  89 |     |     ) external;
  90 |     | 
  91 |     |     /**
  92 |     |      * Request that core vault transfers funds to the agent's underlying address,
  93 |     |      * which makes them available for redemptions. This method reserves agent's collateral.
  94 |     |      * This may be sent by an agent when redemptions dominate mintings, so that the agents
  95 |     |      * are empty but want to earn from redemptions.
  96 |     |      * NOTE: only agent vault owner can call
  97 |     |      * NOTE: there can be only one active return request (until it is confirmed or cancelled).
  98 |     |      * @param _agentVault the agent vault address
  99 |     |      * @param _lots number of lots (same lots as for minting and redemptions)
 100 |     |      */
 101 |     |     function requestReturnFromCoreVault(
 102 |     |         address _agentVault,
 103 |     |         uint256 _lots
 104 |     |     ) external;
 105 |     | 
 106 |     |     /**
 107 |     |      * Before the return request is processed, it can be cancelled, releasing the agent's reserved collateral.
 108 |     |      * @param _agentVault the agent vault address
 109 |     |      */
 110 |     |     function cancelReturnFromCoreVault(address _agentVault) external;
 111 |     | 
 112 |     |     /**
 113 |     |      * Confirm the payment from core vault to the agent's underlying address.
 114 |     |      * This adds the reserved funds to the agent's backing.
 115 |     |      * @param _payment FDC payment proof
 116 |     |      * @param _agentVault the agent vault address
 117 |     |      */
 118 |     |     function confirmReturnFromCoreVault(
 119 |     |         IPayment.Proof calldata _payment,
 120 |     |         address _agentVault
 121 |     |     ) external;
 122 |     | 
 123 |     |     /**
 124 |     |      * Directly redeem from core vault by a user holding FAssets.
 125 |     |      * This is like ordinary redemption, but the redemption time is much longer (a day or more)
 126 |     |      * and there is no possibility of redemption default.
 127 |     |      * @param _lots the number of lots, must be larger than `coreVaultMinimumRedeemLots` setting
 128 |     |      * @param _redeemerUnderlyingAddress the underlying address to which the assets will be redeemed;
 129 |     |      *      must have been added to the `allowedDestinations` list in the core vault manager by
 130 |     |      *      the governance before the redemption request.
 131 |     |      */
 132 |     |     function redeemFromCoreVault(
 133 |     |         uint256 _lots,
 134 |     |         string memory _redeemerUnderlyingAddress
 135 |     |     ) external;
 136 |     | 
 137 |     |     /**
 138 |     |      * Return the maximum amount that can be transferred and the minimum amount that
 139 |     |      * has to remain on the agent vault's underlying address.
 140 |     |      * @param _agentVault the agent vault address
 141 |     |      * @return _maximumTransferUBA maximum amount that can be transferred
 142 |     |      * @return _minimumLeftAmountUBA the minimum amount that has to remain on the agent vault's underlying address
 143 |     |      *  after the transfer
 144 |     |      */
 145 |     |     function maximumTransferToCoreVault(
 146 |     |         address _agentVault
 147 |     |     )
 148 |     |         external
 149 |     |         view
 150 |     |         returns (uint256 _maximumTransferUBA, uint256 _minimumLeftAmountUBA);
 151 |     | 
 152 |     |     /**
 153 |     |      * Returns the amount available on the core vault - this is the maximum amount that can be returned to agent or
 154 |     |      * redeemed directly from the core vault.
 155 |     |      * @return _immediatelyAvailableUBA the amount on the core vault operating account - returns and redemptions
 156 |     |      * within this amount will be paid out quickly
 157 |     |      * @return _totalAvailableUBA the total amount on the core vault, including all escrows
 158 |     |      */
 159 |     |     function coreVaultAvailableAmount()
 160 |     |         external
 161 |     |         view
 162 |     |         returns (uint256 _immediatelyAvailableUBA, uint256 _totalAvailableUBA);
 163 |     | }
 164 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/ICoreVaultClientSettings.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * Core vault settings
  6 |     |  */
  7 |     | interface ICoreVaultClientSettings {
  8 |     |     function setCoreVaultManager(address _coreVaultManager) external;
  9 |     | 
 10 |     |     function setCoreVaultNativeAddress(address payable _nativeAddress) external;
 11 |     | 
 12 |     |     function setCoreVaultTransferTimeExtensionSeconds(
 13 |     |         uint256 _transferTimeExtensionSeconds
 14 |     |     ) external;
 15 |     | 
 16 |     |     function setCoreVaultTransferDefaultPenaltyBIPS(
 17 |     |         uint256 _transferDefaultPenaltyBIPS
 18 |     |     ) external;
 19 |     | 
 20 |     |     function setCoreVaultRedemptionFeeBIPS(uint256 _redemptionFeeBIPS) external;
 21 |     | 
 22 |     |     function setCoreVaultMinimumAmountLeftBIPS(
 23 |     |         uint256 _minimumAmountLeftBIPS
 24 |     |     ) external;
 25 |     | 
 26 |     |     function setCoreVaultMinimumRedeemLots(uint256 _minimumRedeemLots) external;
 27 |     | 
 28 |     |     function getCoreVaultManager() external view returns (address);
 29 |     | 
 30 |     |     function getCoreVaultNativeAddress() external view returns (address);
 31 |     | 
 32 |     |     function getCoreVaultTransferTimeExtensionSeconds()
 33 |     |         external
 34 |     |         view
 35 |     |         returns (uint256);
 36 |     | 
 37 |     |     function getCoreVaultTransferDefaultPenaltyBIPS()
 38 |     |         external
 39 |     |         view
 40 |     |         returns (uint256);
 41 |     | 
 42 |     |     function getCoreVaultRedemptionFeeBIPS() external view returns (uint256);
 43 |     | 
 44 |     |     function getCoreVaultMinimumAmountLeftBIPS()
 45 |     |         external
 46 |     |         view
 47 |     |         returns (uint256);
 48 |     | 
 49 |     |     function getCoreVaultMinimumRedeemLots() external view returns (uint256);
 50 |     | }
 51 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IDelegationAccount.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "./IClaimSetupManager.sol";
  5 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  6 |     | 
  7 |     | interface IDelegationAccount {
  8 |     |     event DelegateFtso(address to, uint256 bips);
  9 |     |     event RevokeFtso(address to, uint256 blockNumber);
 10 |     |     event UndelegateAllFtso();
 11 |     |     event DelegateGovernance(address to);
 12 |     |     event UndelegateGovernance();
 13 |     |     event WithdrawToOwner(uint256 amount);
 14 |     |     event ExternalTokenTransferred(IERC20 token, uint256 amount);
 15 |     |     event ExecutorFeePaid(address executor, uint256 amount);
 16 |     |     event Initialize(address owner, IClaimSetupManager manager);
 17 |     | }
 18 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IEVMTransaction.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | /**
   5 |     |  * @custom:name IEVMTransaction
   6 |     |  * @custom:id 0x06
   7 |     |  * @custom:supported ETH, FLR, SGB
   8 |     |  * @author Flare
   9 |     |  * @notice A relay of a transaction from an EVM chain.
  10 |     |  * This type is only relevant for EVM-compatible chains.
  11 |     |  * @custom:verification If a transaction with the `transactionId` is in a block on the main branch with
  12 |     |  * at least `requiredConfirmations`, the specified data is relayed.
  13 |     |  * If an indicated event does not exist, the request is rejected.
  14 |     |  * @custom:lut `timestamp`
  15 |     |  * @custom:lutlimit `0x41eb00`, `0x41eb00`, `0x41eb00`
  16 |     |  */
  17 |     | interface IEVMTransaction {
  18 |     |     /**
  19 |     |      * @notice Toplevel request
  20 |     |      * @param attestationType ID of the attestation type.
  21 |     |      * @param sourceId ID of the data source.
  22 |     |      * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.
  23 |     |      * @param requestBody Data defining the request. Type (struct) and interpretation is
  24 |     |      * determined by the `attestationType`.
  25 |     |      */
  26 |     |     struct Request {
  27 |     |         bytes32 attestationType;
  28 |     |         bytes32 sourceId;
  29 |     |         bytes32 messageIntegrityCode;
  30 |     |         RequestBody requestBody;
  31 |     |     }
  32 |     | 
  33 |     |     /**
  34 |     |      * @notice Toplevel response
  35 |     |      * @param attestationType Extracted from the request.
  36 |     |      * @param sourceId Extracted from the request.
  37 |     |      * @param votingRound The ID of the State Connector round in which the request was considered.
  38 |     |      * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
  39 |     |      * @param requestBody Extracted from the request.
  40 |     |      * @param responseBody Data defining the response. The verification rules for the construction
  41 |     |      * of the response body and the type are defined per specific `attestationType`.
  42 |     |      */
  43 |     |     struct Response {
  44 |     |         bytes32 attestationType;
  45 |     |         bytes32 sourceId;
  46 |     |         uint64 votingRound;
  47 |     |         uint64 lowestUsedTimestamp;
  48 |     |         RequestBody requestBody;
  49 |     |         ResponseBody responseBody;
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @notice Toplevel proof
  54 |     |      * @param merkleProof Merkle proof corresponding to the attestation response.
  55 |     |      * @param data Attestation response.
  56 |     |      */
  57 |     |     struct Proof {
  58 |     |         bytes32[] merkleProof;
  59 |     |         Response data;
  60 |     |     }
  61 |     | 
  62 |     |     /**
  63 |     |      * @notice Request body for EVM transaction attestation type
  64 |     |      * @custom:below Note that events (logs) are indexed in block not in each transaction.
  65 |     |      * The contract that uses the attestation should specify the order of event logs as needed and the requestor should
  66 |     |      * sort `logIndices` with respect to the set specifications.
  67 |     |      * If possible, the contact should require one `logIndex`.
  68 |     |      * @param transactionHash Hash of the transaction(transactionHash).
  69 |     |      * @param requiredConfirmations The height at which a block is considered confirmed by the requestor.
  70 |     |      * @param provideInput If true, "input" field is included in the response.
  71 |     |      * @param listEvents If true, events indicated by `logIndices` are included in the response.
  72 |     |      * Otherwise, no events are included in the response.
  73 |     |      * @param logIndices If `listEvents` is `false`, this should be an empty list, otherwise,
  74 |     |      * the request is rejected. If `listEvents` is `true`, this is the list of indices (logIndex)
  75 |     |      * of the events to be relayed (sorted by the requestor). The array should contain at most 50 indices.
  76 |     |      * If empty, it indicates all events in order capped by 50.
  77 |     |      */
  78 |     |     struct RequestBody {
  79 |     |         bytes32 transactionHash;
  80 |     |         uint16 requiredConfirmations;
  81 |     |         bool provideInput;
  82 |     |         bool listEvents;
  83 |     |         uint32[] logIndices;
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @notice Response body for EVM transaction attestation type
  88 |     |      * @custom:below The fields are in line with transaction provided by EVM node.
  89 |     |      * @param blockNumber Number of the block in which the transaction is included.
  90 |     |      * @param timestamp Timestamp of the block in which the transaction is included.
  91 |     |      * @param sourceAddress The address (from) that signed the transaction.
  92 |     |      * @param isDeployment Indicate whether it is a contract creation transaction.
  93 |     |      * @param receivingAddress The address (to) of the receiver of the initial transaction.
  94 |     |      * Zero address if `isDeployment` is `true`.
  95 |     |      * @param value The value transferred by the initial transaction in wei.
  96 |     |      * @param input If `provideInput`, this is the data send along with the initial transaction.
  97 |     |      * Otherwise it is the default value `0x00`.
  98 |     |      * @param status Status of the transaction 1 - success, 0 - failure.
  99 |     |      * @param events If `listEvents` is `true`, an array of the requested events.
 100 |     |      * Sorted by the logIndex in the same order as `logIndices`. Otherwise, an empty array.
 101 |     |      */
 102 |     |     struct ResponseBody {
 103 |     |         uint64 blockNumber;
 104 |     |         uint64 timestamp;
 105 |     |         address sourceAddress;
 106 |     |         bool isDeployment;
 107 |     |         address receivingAddress;
 108 |     |         uint256 value;
 109 |     |         bytes input;
 110 |     |         uint8 status;
 111 |     |         Event[] events;
 112 |     |     }
 113 |     | 
 114 |     |     /**
 115 |     |      * @notice Event log record
 116 |     |      * @custom:above An `Event` is a struct with the following fields:
 117 |     |      * @custom:below The fields are in line with EVM event logs.
 118 |     |      * @param logIndex The consecutive number of the event in block.
 119 |     |      * @param emitterAddress The address of the contract that emitted the event.
 120 |     |      * @param topics An array of up to four 32-byte strings of indexed log arguments.
 121 |     |      * @param data Concatenated 32-byte strings of non-indexed log arguments. At least 32 bytes long.
 122 |     |      * @param removed It is `true` if the log was removed due to a chain reorganization
 123 |     |      * and `false` if it is a valid log.
 124 |     |      */
 125 |     |     struct Event {
 126 |     |         uint32 logIndex;
 127 |     |         address emitterAddress;
 128 |     |         bytes32[] topics;
 129 |     |         bytes data;
 130 |     |         bool removed;
 131 |     |     }
 132 |     | }
 133 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IEVMTransactionVerification.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "./IEVMTransaction.sol";
  5 |     | 
  6 |     | interface IEVMTransactionVerification {
  7 |     |     function verifyEVMTransaction(
  8 |     |         IEVMTransaction.Proof calldata _proof
  9 |     |     ) external view returns (bool _proved);
 10 |     | }
 11 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IEntityManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | /**
   5 |     |  * EntityManager interface.
   6 |     |  */
   7 |     | interface IEntityManager {
   8 |     |     /// Voter addresses.
   9 |     |     struct VoterAddresses {
  10 |     |         address submitAddress;
  11 |     |         address submitSignaturesAddress;
  12 |     |         address signingPolicyAddress;
  13 |     |     }
  14 |     | 
  15 |     |     /// Event emitted when a node id is registered.
  16 |     |     event NodeIdRegistered(address indexed voter, bytes20 indexed nodeId);
  17 |     |     /// Event emitted when a node id is unregistered.
  18 |     |     event NodeIdUnregistered(address indexed voter, bytes20 indexed nodeId);
  19 |     |     /// Event emitted when a public key is registered.
  20 |     |     event PublicKeyRegistered(
  21 |     |         address indexed voter,
  22 |     |         bytes32 indexed part1,
  23 |     |         bytes32 indexed part2
  24 |     |     );
  25 |     |     /// Event emitted when a public key is unregistered.
  26 |     |     event PublicKeyUnregistered(
  27 |     |         address indexed voter,
  28 |     |         bytes32 indexed part1,
  29 |     |         bytes32 indexed part2
  30 |     |     );
  31 |     |     /// Event emitted when a delegation address is proposed.
  32 |     |     event DelegationAddressProposed(
  33 |     |         address indexed voter,
  34 |     |         address indexed delegationAddress
  35 |     |     );
  36 |     |     /// Event emitted when a delegation address registration is confirmed.
  37 |     |     event DelegationAddressRegistrationConfirmed(
  38 |     |         address indexed voter,
  39 |     |         address indexed delegationAddress
  40 |     |     );
  41 |     |     /// Event emitted when a submit address is proposed.
  42 |     |     event SubmitAddressProposed(
  43 |     |         address indexed voter,
  44 |     |         address indexed submitAddress
  45 |     |     );
  46 |     |     /// Event emitted when a submit address registration is confirmed.
  47 |     |     event SubmitAddressRegistrationConfirmed(
  48 |     |         address indexed voter,
  49 |     |         address indexed submitAddress
  50 |     |     );
  51 |     |     /// Event emitted when a submit signatures address is proposed.
  52 |     |     event SubmitSignaturesAddressProposed(
  53 |     |         address indexed voter,
  54 |     |         address indexed submitSignaturesAddress
  55 |     |     );
  56 |     |     /// Event emitted when a submit signatures address registration is confirmed.
  57 |     |     event SubmitSignaturesAddressRegistrationConfirmed(
  58 |     |         address indexed voter,
  59 |     |         address indexed submitSignaturesAddress
  60 |     |     );
  61 |     |     /// Event emitted when a signing policy address is proposed.
  62 |     |     event SigningPolicyAddressProposed(
  63 |     |         address indexed voter,
  64 |     |         address indexed signingPolicyAddress
  65 |     |     );
  66 |     |     /// Event emitted when a signing policy address registration is confirmed.
  67 |     |     event SigningPolicyAddressRegistrationConfirmed(
  68 |     |         address indexed voter,
  69 |     |         address indexed signingPolicyAddress
  70 |     |     );
  71 |     |     /// Event emitted when the maximum number of node ids per entity is set.
  72 |     |     event MaxNodeIdsPerEntitySet(uint256 maxNodeIdsPerEntity);
  73 |     | 
  74 |     |     /**
  75 |     |      * Registers a node id.
  76 |     |      * @param _nodeId Node id.
  77 |     |      * @param _certificateRaw Certificate in raw format.
  78 |     |      * @param _signature Signature.
  79 |     |      */
  80 |     |     function registerNodeId(
  81 |     |         bytes20 _nodeId,
  82 |     |         bytes calldata _certificateRaw,
  83 |     |         bytes calldata _signature
  84 |     |     ) external;
  85 |     | 
  86 |     |     /**
  87 |     |      * Unregisters a node id.
  88 |     |      * @param _nodeId Node id.
  89 |     |      */
  90 |     |     function unregisterNodeId(bytes20 _nodeId) external;
  91 |     | 
  92 |     |     /**
  93 |     |      * Registers a public key.
  94 |     |      * @param _part1 First part of the public key.
  95 |     |      * @param _part2 Second part of the public key.
  96 |     |      * @param _verificationData Additional data used to verify the public key.
  97 |     |      */
  98 |     |     function registerPublicKey(
  99 |     |         bytes32 _part1,
 100 |     |         bytes32 _part2,
 101 |     |         bytes calldata _verificationData
 102 |     |     ) external;
 103 |     | 
 104 |     |     /**
 105 |     |      * Unregisters a public key.
 106 |     |      */
 107 |     |     function unregisterPublicKey() external;
 108 |     | 
 109 |     |     /**
 110 |     |      * Proposes a delegation address (called by the voter).
 111 |     |      * @param _delegationAddress Delegation address.
 112 |     |      */
 113 |     |     function proposeDelegationAddress(address _delegationAddress) external;
 114 |     | 
 115 |     |     /**
 116 |     |      * Confirms a delegation address registration (called by the delegation address).
 117 |     |      * @param _voter Voter address.
 118 |     |      */
 119 |     |     function confirmDelegationAddressRegistration(address _voter) external;
 120 |     | 
 121 |     |     /**
 122 |     |      * Proposes a submit address (called by the voter).
 123 |     |      * @param _submitAddress Submit address.
 124 |     |      */
 125 |     |     function proposeSubmitAddress(address _submitAddress) external;
 126 |     | 
 127 |     |     /**
 128 |     |      * Confirms a submit address registration (called by the submit address).
 129 |     |      * @param _voter Voter address.
 130 |     |      */
 131 |     |     function confirmSubmitAddressRegistration(address _voter) external;
 132 |     | 
 133 |     |     /**
 134 |     |      * Proposes a submit signatures address (called by the voter).
 135 |     |      * @param _submitSignaturesAddress Submit signatures address.
 136 |     |      */
 137 |     |     function proposeSubmitSignaturesAddress(
 138 |     |         address _submitSignaturesAddress
 139 |     |     ) external;
 140 |     | 
 141 |     |     /**
 142 |     |      * Confirms a submit signatures address registration (called by the submit signatures address).
 143 |     |      * @param _voter Voter address.
 144 |     |      */
 145 |     |     function confirmSubmitSignaturesAddressRegistration(
 146 |     |         address _voter
 147 |     |     ) external;
 148 |     | 
 149 |     |     /**
 150 |     |      * Proposes a signing policy address (called by the voter).
 151 |     |      * @param _signingPolicyAddress Signing policy address.
 152 |     |      */
 153 |     |     function proposeSigningPolicyAddress(
 154 |     |         address _signingPolicyAddress
 155 |     |     ) external;
 156 |     | 
 157 |     |     /**
 158 |     |      * Confirms a signing policy address registration (called by the signing policy address).
 159 |     |      * @param _voter Voter address.
 160 |     |      */
 161 |     |     function confirmSigningPolicyAddressRegistration(address _voter) external;
 162 |     | 
 163 |     |     /**
 164 |     |      * Gets the delegation address of a voter at a specific block number.
 165 |     |      * @param _voter Voter address.
 166 |     |      * @param _blockNumber Block number.
 167 |     |      * @return Public key.
 168 |     |      */
 169 |     |     function getDelegationAddressOfAt(
 170 |     |         address _voter,
 171 |     |         uint256 _blockNumber
 172 |     |     ) external view returns (address);
 173 |     | 
 174 |     |     /**
 175 |     |      * Gets the delegation address of a voter at the current block number.
 176 |     |      * @param _voter Voter address.
 177 |     |      * @return Public key.
 178 |     |      */
 179 |     |     function getDelegationAddressOf(
 180 |     |         address _voter
 181 |     |     ) external view returns (address);
 182 |     | 
 183 |     |     /**
 184 |     |      * Gets the node ids of a voter at a specific block number.
 185 |     |      * @param _voter Voter address.
 186 |     |      * @param _blockNumber Block number.
 187 |     |      * @return Node ids.
 188 |     |      */
 189 |     |     function getNodeIdsOfAt(
 190 |     |         address _voter,
 191 |     |         uint256 _blockNumber
 192 |     |     ) external view returns (bytes20[] memory);
 193 |     | 
 194 |     |     /**
 195 |     |      * Gets the node ids of a voter at the current block number.
 196 |     |      * @param _voter Voter address.
 197 |     |      * @return Node ids.
 198 |     |      */
 199 |     |     function getNodeIdsOf(
 200 |     |         address _voter
 201 |     |     ) external view returns (bytes20[] memory);
 202 |     | 
 203 |     |     /**
 204 |     |      * Gets the public key of a voter at a specific block number.
 205 |     |      * @param _voter Voter address.
 206 |     |      * @param _blockNumber Block number.
 207 |     |      * @return Public key.
 208 |     |      */
 209 |     |     function getPublicKeyOfAt(
 210 |     |         address _voter,
 211 |     |         uint256 _blockNumber
 212 |     |     ) external view returns (bytes32, bytes32);
 213 |     | 
 214 |     |     /**
 215 |     |      * Gets the public key of a voter at the current block number.
 216 |     |      * @param _voter Voter address.
 217 |     |      * @return Public key.
 218 |     |      */
 219 |     |     function getPublicKeyOf(
 220 |     |         address _voter
 221 |     |     ) external view returns (bytes32, bytes32);
 222 |     | 
 223 |     |     /**
 224 |     |      * Gets voter's addresses at a specific block number.
 225 |     |      * @param _voter Voter address.
 226 |     |      * @param _blockNumber Block number.
 227 |     |      * @return _addresses Voter addresses.
 228 |     |      */
 229 |     |     function getVoterAddressesAt(
 230 |     |         address _voter,
 231 |     |         uint256 _blockNumber
 232 |     |     ) external view returns (VoterAddresses memory _addresses);
 233 |     | 
 234 |     |     /**
 235 |     |      * Gets voter's addresses at the current block number.
 236 |     |      * @param _voter Voter address.
 237 |     |      * @return _addresses Voter addresses.
 238 |     |      */
 239 |     |     function getVoterAddresses(
 240 |     |         address _voter
 241 |     |     ) external view returns (VoterAddresses memory _addresses);
 242 |     | 
 243 |     |     /**
 244 |     |      * Gets voter's address for a node id at a specific block number.
 245 |     |      * @param _nodeId Node id.
 246 |     |      * @param _blockNumber Block number.
 247 |     |      * @return _voter Voter address.
 248 |     |      */
 249 |     |     function getVoterForNodeId(
 250 |     |         bytes20 _nodeId,
 251 |     |         uint256 _blockNumber
 252 |     |     ) external view returns (address _voter);
 253 |     | 
 254 |     |     /**
 255 |     |      * Gets voter's address for a public key at a specific block number.
 256 |     |      * @param _part1 First part of the public key.
 257 |     |      * @param _part2 Second part of the public key.
 258 |     |      * @param _blockNumber Block number.
 259 |     |      * @return _voter Voter address.
 260 |     |      */
 261 |     |     function getVoterForPublicKey(
 262 |     |         bytes32 _part1,
 263 |     |         bytes32 _part2,
 264 |     |         uint256 _blockNumber
 265 |     |     ) external view returns (address _voter);
 266 |     | 
 267 |     |     /**
 268 |     |      * Gets voter's address for a delegation address at a specific block number.
 269 |     |      * @param _delegationAddress Delegation address.
 270 |     |      * @param _blockNumber Block number.
 271 |     |      * @return _voter Voter address.
 272 |     |      */
 273 |     |     function getVoterForDelegationAddress(
 274 |     |         address _delegationAddress,
 275 |     |         uint256 _blockNumber
 276 |     |     ) external view returns (address _voter);
 277 |     | 
 278 |     |     /**
 279 |     |      * Gets voter's address for a submit address at a specific block number.
 280 |     |      * @param _submitAddress Submit address.
 281 |     |      * @param _blockNumber Block number.
 282 |     |      * @return _voter Voter address.
 283 |     |      */
 284 |     |     function getVoterForSubmitAddress(
 285 |     |         address _submitAddress,
 286 |     |         uint256 _blockNumber
 287 |     |     ) external view returns (address _voter);
 288 |     | 
 289 |     |     /**
 290 |     |      * Gets voter's address for a submit signatures address at a specific block number.
 291 |     |      * @param _submitSignaturesAddress Submit signatures address.
 292 |     |      * @param _blockNumber Block number.
 293 |     |      * @return _voter Voter address.
 294 |     |      */
 295 |     |     function getVoterForSubmitSignaturesAddress(
 296 |     |         address _submitSignaturesAddress,
 297 |     |         uint256 _blockNumber
 298 |     |     ) external view returns (address _voter);
 299 |     | 
 300 |     |     /**
 301 |     |      * Gets voter's address for a signing policy address at a specific block number.
 302 |     |      * @param _signingPolicyAddress Signing policy address.
 303 |     |      * @param _blockNumber Block number.
 304 |     |      * @return _voter Voter address.
 305 |     |      */
 306 |     |     function getVoterForSigningPolicyAddress(
 307 |     |         address _signingPolicyAddress,
 308 |     |         uint256 _blockNumber
 309 |     |     ) external view returns (address _voter);
 310 |     | }
 311 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFastUpdateIncentiveManager.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "./IFixedPointArithmetic.sol" as FPA;
  5 |     | import "./IFastUpdatesConfiguration.sol";
  6 |     | import "./IIncreaseManager.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * Fast update incentive manager interface.
 10 |     |  */
 11 |     | interface IFastUpdateIncentiveManager is IIncreaseManager {
 12 |     |     /// Incentive offer structure.
 13 |     |     struct IncentiveOffer {
 14 |     |         FPA.Range rangeIncrease;
 15 |     |         FPA.Range rangeLimit;
 16 |     |     }
 17 |     | 
 18 |     |     /// Event emitted when an incentive is offered.
 19 |     |     event IncentiveOffered(
 20 |     |         uint24 indexed rewardEpochId,
 21 |     |         FPA.Range rangeIncrease,
 22 |     |         FPA.SampleSize sampleSizeIncrease,
 23 |     |         FPA.Fee offerAmount
 24 |     |     );
 25 |     | 
 26 |     |     /// Event emitted when inflation rewards are offered.
 27 |     |     event InflationRewardsOffered(
 28 |     |         // reward epoch id
 29 |     |         uint24 indexed rewardEpochId,
 30 |     |         // feed configurations
 31 |     |         IFastUpdatesConfiguration.FeedConfiguration[] feedConfigurations,
 32 |     |         // amount (in wei) of reward in native coin
 33 |     |         uint256 amount
 34 |     |     );
 35 |     | 
 36 |     |     /**
 37 |     |      * The entry point for third parties to make incentive offers. It accepts a payment and, using the contents of
 38 |     |      * `_offer`, computes how much the expected sample size will be increased to apply the requested (but capped) range
 39 |     |      * increase. If the ultimate value of the range exceeds the cap, funds are returned to the sender in proportion to
 40 |     |      * the amount by which the increase is adjusted to reach the cap.
 41 |     |      * @param _offer The requested amount of per-block variation range increase,
 42 |     |      * along with a cap for the ultimate range.
 43 |     |      */
 44 |     |     function offerIncentive(IncentiveOffer calldata _offer) external payable;
 45 |     | 
 46 |     |     /// Viewer for the current value of the expected sample size.
 47 |     |     function getExpectedSampleSize() external view returns (FPA.SampleSize);
 48 |     | 
 49 |     |     /// Viewer for the current value of the unit delta's precision (the fractional part of the scale).
 50 |     |     function getPrecision() external view returns (FPA.Precision);
 51 |     | 
 52 |     |     /// Viewer for the current value of the per-block variation range.
 53 |     |     function getRange() external view returns (FPA.Range);
 54 |     | 
 55 |     |     /// Viewer for the current value of sample size increase price.
 56 |     |     function getCurrentSampleSizeIncreasePrice()
 57 |     |         external
 58 |     |         view
 59 |     |         returns (FPA.Fee);
 60 |     | 
 61 |     |     /// Viewer for the current value of the scale itself.
 62 |     |     function getScale() external view returns (FPA.Scale);
 63 |     | 
 64 |     |     /// Viewer for the base value of the scale itself.
 65 |     |     function getBaseScale() external view returns (FPA.Scale);
 66 |     | 
 67 |     |     /// The maximum amount by which the expected sample size can be increased by an incentive offer.
 68 |     |     /// This is controlled by governance and forces a minimum cost to increasing the sample size greatly,
 69 |     |     /// which would otherwise be an attack on the protocol.
 70 |     |     function sampleIncreaseLimit() external view returns (FPA.SampleSize);
 71 |     | 
 72 |     |     /// The maximum value that the range can be increased to by an incentive offer.
 73 |     |     function rangeIncreaseLimit() external view returns (FPA.Range);
 74 |     | 
 75 |     |     /// The price for increasing the per-block range of variation by 1, prorated for the actual amount of increase.
 76 |     |     function rangeIncreasePrice() external view returns (FPA.Fee);
 77 |     | }
 78 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFastUpdater.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | import {SortitionCredential} from "./ISortition.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * Fast updater interface.
   8 |     |  */
   9 |     | interface IFastUpdater {
  10 |     |     /// Signature structure
  11 |     |     struct Signature {
  12 |     |         uint8 v;
  13 |     |         bytes32 r;
  14 |     |         bytes32 s;
  15 |     |     }
  16 |     | 
  17 |     |     /// Fast update structure
  18 |     |     struct FastUpdates {
  19 |     |         uint256 sortitionBlock;
  20 |     |         SortitionCredential sortitionCredential;
  21 |     |         bytes deltas;
  22 |     |         Signature signature;
  23 |     |     }
  24 |     | 
  25 |     |     /// Event emitted when a new set of updates is submitted.
  26 |     |     event FastUpdateFeedsSubmitted(
  27 |     |         uint32 indexed votingRoundId,
  28 |     |         address indexed signingPolicyAddress
  29 |     |     );
  30 |     | 
  31 |     |     /// Event emitted when a feed is added or reset.
  32 |     |     event FastUpdateFeedReset(
  33 |     |         uint256 indexed votingRoundId,
  34 |     |         uint256 indexed index,
  35 |     |         bytes21 indexed id,
  36 |     |         uint256 value,
  37 |     |         int8 decimals
  38 |     |     );
  39 |     | 
  40 |     |     /// Event emitted when a feed is removed.
  41 |     |     event FastUpdateFeedRemoved(uint256 indexed index);
  42 |     | 
  43 |     |     /// Event emitted at the start of a new voting epoch - current feeds' values and decimals.
  44 |     |     event FastUpdateFeeds(
  45 |     |         uint256 indexed votingEpochId,
  46 |     |         uint256[] feeds,
  47 |     |         int8[] decimals
  48 |     |     );
  49 |     | 
  50 |     |     /**
  51 |     |      * The entry point for providers to submit an update transaction.
  52 |     |      * @param _updates Data of an update transaction, which in addition to the actual list of updates,
  53 |     |      * includes the sortition credential proving the provider's eligibility to make updates in the also-included
  54 |     |      * sortition round, as well as a signature allowing a single registered provider to submit from multiple
  55 |     |      * EVM accounts.
  56 |     |      */
  57 |     |     function submitUpdates(FastUpdates calldata _updates) external;
  58 |     | 
  59 |     |     /**
  60 |     |      * Public access to the stored data of all feeds.
  61 |     |      * A fee (calculated by the FeeCalculator contract) may need to be paid.
  62 |     |      * **NOTE:** Overpayment is not refunded.
  63 |     |      * @return _feedIds The list of feed ids.
  64 |     |      * @return _feeds The list of feeds.
  65 |     |      * @return _decimals The list of decimal places for feeds.
  66 |     |      * @return _timestamp The timestamp of the last update.
  67 |     |      */
  68 |     |     function fetchAllCurrentFeeds()
  69 |     |         external
  70 |     |         payable
  71 |     |         returns (
  72 |     |             bytes21[] memory _feedIds,
  73 |     |             uint256[] memory _feeds,
  74 |     |             int8[] memory _decimals,
  75 |     |             uint64 _timestamp
  76 |     |         );
  77 |     | 
  78 |     |     /**
  79 |     |      * Public access to the stored data of each feed, allowing controlled batch access to the lengthy complete data.
  80 |     |      * Feeds should be sorted for better performance.
  81 |     |      * A fee (calculated by the FeeCalculator contract) may need to be paid.
  82 |     |      * **NOTE:** Overpayment is not refunded.
  83 |     |      * @param _indices Index numbers of the feeds for which data should be returned, corresponding to `feedIds` in
  84 |     |      * the `FastUpdatesConfiguration` contract.
  85 |     |      * @return _feeds The list of data for the requested feeds, in the same order as the feed indices were given
  86 |     |      * (which may not be their sorted order).
  87 |     |      * @return _decimals The list of decimal places for the requested feeds, in the same order as the feed indices were
  88 |     |      * given (which may not be their sorted order).
  89 |     |      * @return _timestamp The timestamp of the last update.
  90 |     |      */
  91 |     |     function fetchCurrentFeeds(
  92 |     |         uint256[] calldata _indices
  93 |     |     )
  94 |     |         external
  95 |     |         payable
  96 |     |         returns (
  97 |     |             uint256[] memory _feeds,
  98 |     |             int8[] memory _decimals,
  99 |     |             uint64 _timestamp
 100 |     |         );
 101 |     | 
 102 |     |     /**
 103 |     |      * Informational getter concerning the eligibility criterion for being chosen by sortition.
 104 |     |      * @return _cutoff The upper endpoint of the acceptable range of "scores" that providers generate for sortition.
 105 |     |      * A score below the cutoff indicates eligibility to submit updates in the present sortition round.
 106 |     |      */
 107 |     |     function currentScoreCutoff() external view returns (uint256 _cutoff);
 108 |     | 
 109 |     |     /**
 110 |     |      * Informational getter concerning the eligibility criterion for being chosen by sortition in a given block.
 111 |     |      * @param _blockNum The block for which the cutoff is requested.
 112 |     |      * @return _cutoff The upper endpoint of the acceptable range of "scores" that providers generate for sortition.
 113 |     |      * A score below the cutoff indicates eligibility to submit updates in the present sortition round.
 114 |     |      */
 115 |     |     function blockScoreCutoff(
 116 |     |         uint256 _blockNum
 117 |     |     ) external view returns (uint256 _cutoff);
 118 |     | 
 119 |     |     /**
 120 |     |      * Informational getter concerning a provider's likelihood of being chosen by sortition.
 121 |     |      * @param _signingPolicyAddress The signing policy address of the specified provider. This is different from the
 122 |     |      * sender of an update transaction, due to the signature included in the `FastUpdates` type.
 123 |     |      * @return _weight The specified provider's weight for sortition purposes. This is derived from the provider's
 124 |     |      * delegation weight for the FTSO, but rescaled against a fixed number of "virtual providers", indicating how many
 125 |     |      * potential updates a single provider may make in a sortition round.
 126 |     |      */
 127 |     |     function currentSortitionWeight(
 128 |     |         address _signingPolicyAddress
 129 |     |     ) external view returns (uint256 _weight);
 130 |     | 
 131 |     |     /**
 132 |     |      * The submission window is a number of blocks forming a "grace period" after a round of sortition starts,
 133 |     |      * during which providers may submit updates for that round. In other words, each block starts a new round of
 134 |     |      * sortition and that round lasts `submissionWindow` blocks.
 135 |     |      */
 136 |     |     function submissionWindow() external view returns (uint8);
 137 |     | 
 138 |     |     /**
 139 |     |      * Id of the current reward epoch.
 140 |     |      */
 141 |     |     function currentRewardEpochId() external view returns (uint24);
 142 |     | 
 143 |     |     /**
 144 |     |      * The number of updates submitted in each block for the last `_historySize` blocks (up to `MAX_BLOCKS_HISTORY`).
 145 |     |      * @param _historySize The number of blocks for which the number of updates should be returned.
 146 |     |      * @return _noOfUpdates The number of updates submitted in each block for the last `_historySize` blocks.
 147 |     |      * The array is ordered from the current block to the oldest block.
 148 |     |      */
 149 |     |     function numberOfUpdates(
 150 |     |         uint256 _historySize
 151 |     |     ) external view returns (uint256[] memory _noOfUpdates);
 152 |     | 
 153 |     |     /**
 154 |     |      * The number of updates submitted in a block - available only for the last `MAX_BLOCKS_HISTORY` blocks.
 155 |     |      * @param _blockNumber The block number for which the number of updates should be returned.
 156 |     |      * @return _noOfUpdates The number of updates submitted in the specified block.
 157 |     |      */
 158 |     |     function numberOfUpdatesInBlock(
 159 |     |         uint256 _blockNumber
 160 |     |     ) external view returns (uint256 _noOfUpdates);
 161 |     | }
 162 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFastUpdatesConfiguration.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * FastUpdatesConfiguration interface.
  6 |     |  */
  7 |     | interface IFastUpdatesConfiguration {
  8 |     |     /**
  9 |     |      * The feed configuration struct.
 10 |     |      */
 11 |     |     struct FeedConfiguration {
 12 |     |         // feed id
 13 |     |         bytes21 feedId;
 14 |     |         // reward band value (interpreted off-chain) in relation to the median
 15 |     |         uint32 rewardBandValue;
 16 |     |         // inflation share
 17 |     |         uint24 inflationShare;
 18 |     |     }
 19 |     | 
 20 |     |     /// Event emitted when a feed is added.
 21 |     |     event FeedAdded(
 22 |     |         bytes21 indexed feedId,
 23 |     |         uint32 rewardBandValue,
 24 |     |         uint24 inflationShare,
 25 |     |         uint256 index
 26 |     |     );
 27 |     |     /// Event emitted when a feed is updated.
 28 |     |     event FeedUpdated(
 29 |     |         bytes21 indexed feedId,
 30 |     |         uint32 rewardBandValue,
 31 |     |         uint24 inflationShare,
 32 |     |         uint256 index
 33 |     |     );
 34 |     |     /// Event emitted when a feed is removed.
 35 |     |     event FeedRemoved(bytes21 indexed feedId, uint256 index);
 36 |     | 
 37 |     |     /**
 38 |     |      * Returns the index of a feed.
 39 |     |      * @param _feedId The feed id.
 40 |     |      * @return _index The index of the feed.
 41 |     |      */
 42 |     |     function getFeedIndex(
 43 |     |         bytes21 _feedId
 44 |     |     ) external view returns (uint256 _index);
 45 |     | 
 46 |     |     /**
 47 |     |      * Returns the feed id at a given index. Removed (unused) feed index will return bytes21(0).
 48 |     |      * @param _index The index.
 49 |     |      * @return _feedId The feed id.
 50 |     |      */
 51 |     |     function getFeedId(uint256 _index) external view returns (bytes21 _feedId);
 52 |     | 
 53 |     |     /**
 54 |     |      * Returns all feed ids. For removed (unused) feed indices, the feed id will be bytes21(0).
 55 |     |      */
 56 |     |     function getFeedIds() external view returns (bytes21[] memory);
 57 |     | 
 58 |     |     /**
 59 |     |      * Returns the number of feeds, including removed ones.
 60 |     |      */
 61 |     |     function getNumberOfFeeds() external view returns (uint256);
 62 |     | 
 63 |     |     /**
 64 |     |      * Returns the feed configurations, including removed ones.
 65 |     |      */
 66 |     |     function getFeedConfigurations()
 67 |     |         external
 68 |     |         view
 69 |     |         returns (FeedConfiguration[] memory);
 70 |     | 
 71 |     |     /**
 72 |     |      * Returns the unused indices - indices of removed feeds.
 73 |     |      */
 74 |     |     function getUnusedIndices() external view returns (uint256[] memory);
 75 |     | }
 76 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFdcHub.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "./IFdcInflationConfigurations.sol";
  5 |     | import "./IFdcRequestFeeConfigurations.sol";
  6 |     | 
  7 |     | /**
  8 |     |  * FdcHub interface.
  9 |     |  */
 10 |     | interface IFdcHub {
 11 |     |     // Event emitted when an attestation request is made.
 12 |     |     event AttestationRequest(bytes data, uint256 fee);
 13 |     | 
 14 |     |     // Event emitted when a requests offset is set.
 15 |     |     event RequestsOffsetSet(uint8 requestsOffsetSeconds);
 16 |     | 
 17 |     |     /// Event emitted when inflation rewards are offered.
 18 |     |     event InflationRewardsOffered(
 19 |     |         // reward epoch id
 20 |     |         uint24 indexed rewardEpochId,
 21 |     |         // fdc configurations
 22 |     |         IFdcInflationConfigurations.FdcConfiguration[] fdcConfigurations,
 23 |     |         // amount (in wei) of reward in native coin
 24 |     |         uint256 amount
 25 |     |     );
 26 |     | 
 27 |     |     /**
 28 |     |      * Method to request an attestation.
 29 |     |      * @param _data ABI encoded attestation request
 30 |     |      */
 31 |     |     function requestAttestation(bytes calldata _data) external payable;
 32 |     | 
 33 |     |     /**
 34 |     |      * The offset (in seconds) for the requests to be processed during the current voting round.
 35 |     |      */
 36 |     |     function requestsOffsetSeconds() external view returns (uint8);
 37 |     | 
 38 |     |     /**
 39 |     |      * The FDC inflation configurations contract.
 40 |     |      */
 41 |     |     function fdcInflationConfigurations()
 42 |     |         external
 43 |     |         view
 44 |     |         returns (IFdcInflationConfigurations);
 45 |     | 
 46 |     |     /**
 47 |     |      * The FDC request fee configurations contract.
 48 |     |      */
 49 |     |     function fdcRequestFeeConfigurations()
 50 |     |         external
 51 |     |         view
 52 |     |         returns (IFdcRequestFeeConfigurations);
 53 |     | }
 54 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFdcInflationConfigurations.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * FdcInflationConfigurations interface.
  6 |     |  */
  7 |     | interface IFdcInflationConfigurations {
  8 |     |     /// The FDC configuration struct.
  9 |     | 
 10 |     |     struct FdcConfiguration {
 11 |     |         // attestation type
 12 |     |         bytes32 attestationType;
 13 |     |         // source
 14 |     |         bytes32 source;
 15 |     |         // inflation share for this configuration
 16 |     |         uint24 inflationShare;
 17 |     |         // minimal reward eligibility threshold in number of request
 18 |     |         uint8 minRequestsThreshold;
 19 |     |         // mode (additional settings interpreted on the client side off-chain)
 20 |     |         uint224 mode;
 21 |     |     }
 22 |     | 
 23 |     |     /**
 24 |     |      * Returns the FDC configuration at `_index`.
 25 |     |      * @param _index The index of the FDC configuration.
 26 |     |      */
 27 |     |     function getFdcConfiguration(
 28 |     |         uint256 _index
 29 |     |     ) external view returns (FdcConfiguration memory);
 30 |     | 
 31 |     |     /**
 32 |     |      * Returns the FDC configurations.
 33 |     |      */
 34 |     |     function getFdcConfigurations()
 35 |     |         external
 36 |     |         view
 37 |     |         returns (FdcConfiguration[] memory);
 38 |     | }
 39 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFdcRequestFeeConfigurations.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * FdcRequestFeeConfigurations interface.
  6 |     |  */
  7 |     | interface IFdcRequestFeeConfigurations {
  8 |     |     // Event emitted when a type and source price is set.
  9 |     |     event TypeAndSourceFeeSet(
 10 |     |         bytes32 indexed attestationType,
 11 |     |         bytes32 indexed source,
 12 |     |         uint256 fee
 13 |     |     );
 14 |     | 
 15 |     |     // Event emitted when a type and source price is removed.
 16 |     |     event TypeAndSourceFeeRemoved(
 17 |     |         bytes32 indexed attestationType,
 18 |     |         bytes32 indexed source
 19 |     |     );
 20 |     | 
 21 |     |     /**
 22 |     |      * Method to get the base fee for an attestation request. It reverts if the request is not supported.
 23 |     |      * @param _data ABI encoded attestation request
 24 |     |      */
 25 |     |     function getRequestFee(
 26 |     |         bytes calldata _data
 27 |     |     ) external view returns (uint256);
 28 |     | }
 29 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFdcVerification.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "./IRelay.sol";
  5 |     | import "./IAddressValidityVerification.sol";
  6 |     | import "./IBalanceDecreasingTransactionVerification.sol";
  7 |     | import "./IConfirmedBlockHeightExistsVerification.sol";
  8 |     | import "./IEVMTransactionVerification.sol";
  9 |     | import "./IPaymentVerification.sol";
 10 |     | import "./IReferencedPaymentNonexistenceVerification.sol";
 11 |     | import "./IWeb2JsonVerification.sol";
 12 |     | 
 13 |     | /**
 14 |     |  * FdcVerification interface.
 15 |     |  */
 16 |     | interface IFdcVerification is
 17 |     |     IAddressValidityVerification,
 18 |     |     IBalanceDecreasingTransactionVerification,
 19 |     |     IConfirmedBlockHeightExistsVerification,
 20 |     |     IEVMTransactionVerification,
 21 |     |     IPaymentVerification,
 22 |     |     IReferencedPaymentNonexistenceVerification,
 23 |     |     IWeb2JsonVerification
 24 |     | {
 25 |     |     /**
 26 |     |      * The FDC protocol id.
 27 |     |      */
 28 |     |     function fdcProtocolId() external view returns (uint8 _fdcProtocolId);
 29 |     | 
 30 |     |     /**
 31 |     |      * Relay contract address.
 32 |     |      */
 33 |     |     function relay() external view returns (IRelay);
 34 |     | }
 35 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFeeCalculator.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * FeeCalculator interface.
  6 |     |  */
  7 |     | interface IFeeCalculator {
  8 |     |     /**
  9 |     |      * Calculates a fee that needs to be paid to fetch feeds' data.
 10 |     |      * @param _feedIds List of feed ids.
 11 |     |      */
 12 |     |     function calculateFeeByIds(
 13 |     |         bytes21[] memory _feedIds
 14 |     |     ) external view returns (uint256 _fee);
 15 |     | 
 16 |     |     /**
 17 |     |      * Calculates a fee that needs to be paid to fetch feeds' data.
 18 |     |      * @param _indices Indices of the feeds, corresponding to feed ids in
 19 |     |      * the FastUpdatesConfiguration contract.
 20 |     |      */
 21 |     |     function calculateFeeByIndices(
 22 |     |         uint256[] memory _indices
 23 |     |     ) external view returns (uint256 _fee);
 24 |     | }
 25 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFixedPointArithmetic.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /*
  5 |     |  * Opaque type synonyms to enforce arithemtic correctness.
  6 |     |  * All of these are internally uint256 to avert solc's restricted-bit-size internal handling.
  7 |     |  * Since the space is available, the fractional parts of all (except Price,
  8 |     |  * which is not controlled by us) are very wide.
  9 |     |  */
 10 |     | 
 11 |     | type Scale is uint256; // 1x127
 12 |     | type Precision is uint256; // 0x127; the fractional part of Scale, top bit always 0
 13 |     | type SampleSize is uint256; // 8x120; current gas usage and block gas limit force <32 update transactions per block
 14 |     | type Range is uint256; // 8x120, with some space for >100% fluctuations
 15 |     | // (measured volatility per block is ~1e-3 at most)
 16 |     | type Fractional is uint256; // 0x128
 17 |     | 
 18 |     | type Fee is uint256; // 128x0; same scale as currency units,restricted to bottom 128 bits
 19 |     | // (1e18 integer and fractional parts) to accommodate arithmetic
 20 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFlareAssetRegistry.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | interface IFlareAssetRegistry {
  6 |     |     /**
  7 |     |      * @notice Returns if the token is a Flare Asset
  8 |     |      * @dev All other methods that accept token address will fail if this method returns false
  9 |     |      * @param token The token to be checked
 10 |     |      */
 11 |     |     function isFlareAsset(address token) external view returns (bool);
 12 |     | 
 13 |     |     /**
 14 |     |      * Return the asset type of the token. Asset type is a hash uniquely identifying the asset type.
 15 |     |      * For example, for wrapped native token, the type is `keccak256("wrapped native")`,
 16 |     |      * and for all f-assets the type will be `keccak256("f-asset")`.
 17 |     |      */
 18 |     |     function assetType(address _token) external view returns (bytes32);
 19 |     | 
 20 |     |     /**
 21 |     |      * @notice Returns the address of the Flare Asset with the selected symbol
 22 |     |      * @param symbol The token's symbol
 23 |     |      */
 24 |     |     function assetBySymbol(
 25 |     |         string calldata symbol
 26 |     |     ) external view returns (address);
 27 |     | 
 28 |     |     /**
 29 |     |      * @notice Returns if the Flare Asset supports delegation via IVPToken interface
 30 |     |      * @param token The token to be checked
 31 |     |      */
 32 |     |     function supportsFtsoDelegation(address token) external view returns (bool);
 33 |     | 
 34 |     |     /**
 35 |     |      * @notice Returns the maximum allowed number of delegates by percent for the selected token
 36 |     |      * @param token The token to be checked
 37 |     |      */
 38 |     |     function maxDelegatesByPercent(
 39 |     |         address token
 40 |     |     ) external view returns (uint256);
 41 |     | 
 42 |     |     /**
 43 |     |      * @notice Returns the incentive pool address for the selected token
 44 |     |      * @param token The token to be checked
 45 |     |      */
 46 |     |     function incentivePoolFor(address token) external view returns (address);
 47 |     | 
 48 |     |     /**
 49 |     |      * @notice Returns the addresses of all Flare Assets
 50 |     |      */
 51 |     |     function allAssets() external view returns (address[] memory);
 52 |     | 
 53 |     |     /**
 54 |     |      * @notice Returns the addresses and associated symbols of all Flare Assets
 55 |     |      */
 56 |     |     function allAssetsWithSymbols()
 57 |     |         external
 58 |     |         view
 59 |     |         returns (address[] memory, string[] memory);
 60 |     | 
 61 |     |     /**
 62 |     |      * @notice Returns all asset types.
 63 |     |      */
 64 |     |     function allAssetTypes() external view returns (bytes32[] memory);
 65 |     | 
 66 |     |     /**
 67 |     |      * @notice Returns the addresses of all Flare Assets of given type.
 68 |     |      * @param _assetType a type hash, all returned assets will have this assetType
 69 |     |      */
 70 |     |     function allAssetsOfType(
 71 |     |         bytes32 _assetType
 72 |     |     ) external view returns (address[] memory);
 73 |     | 
 74 |     |     /**
 75 |     |      * @notice Returns the addresses and associated symbols of all Flare Assets of given type.
 76 |     |      * @param _assetType a type hash, all returned assets will have this assetType
 77 |     |      */
 78 |     |     function allAssetsOfTypeWithSymbols(
 79 |     |         bytes32 _assetType
 80 |     |     ) external view returns (address[] memory, string[] memory);
 81 |     | 
 82 |     |     /**
 83 |     |      * @notice Returns a generic asset attribute value.
 84 |     |      * @param token The token's address
 85 |     |      * @param nameHash attributes name's hash
 86 |     |      * @return defined true if the attribute is defined for this token
 87 |     |      * @return value attribute value, may have to be cast into some other type
 88 |     |      */
 89 |     |     function getAttribute(
 90 |     |         address token,
 91 |     |         bytes32 nameHash
 92 |     |     ) external view returns (bool defined, bytes32 value);
 93 |     | }
 94 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFlareContractRegistry.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | interface IFlareContractRegistry {
  6 |     |     /**
  7 |     |      * @notice Returns contract address for the given name - might be address(0)
  8 |     |      * @param _name             name of the contract
  9 |     |      */
 10 |     |     function getContractAddressByName(
 11 |     |         string calldata _name
 12 |     |     ) external view returns (address);
 13 |     | 
 14 |     |     /**
 15 |     |      * @notice Returns contract address for the given name hash - might be address(0)
 16 |     |      * @param _nameHash         hash of the contract name (keccak256(abi.encode(name))
 17 |     |      */
 18 |     |     function getContractAddressByHash(
 19 |     |         bytes32 _nameHash
 20 |     |     ) external view returns (address);
 21 |     | 
 22 |     |     /**
 23 |     |      * @notice Returns contract addresses for the given names - might be address(0)
 24 |     |      * @param _names            names of the contracts
 25 |     |      */
 26 |     |     function getContractAddressesByName(
 27 |     |         string[] calldata _names
 28 |     |     ) external view returns (address[] memory);
 29 |     | 
 30 |     |     /**
 31 |     |      * @notice Returns contract addresses for the given name hashes - might be address(0)
 32 |     |      * @param _nameHashes       hashes of the contract names (keccak256(abi.encode(name))
 33 |     |      */
 34 |     |     function getContractAddressesByHash(
 35 |     |         bytes32[] calldata _nameHashes
 36 |     |     ) external view returns (address[] memory);
 37 |     | 
 38 |     |     /**
 39 |     |      * @notice Returns all contract names and corresponding addresses
 40 |     |      */
 41 |     |     function getAllContracts()
 42 |     |         external
 43 |     |         view
 44 |     |         returns (string[] memory _names, address[] memory _addresses);
 45 |     | }
 46 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFlareSystemsCalculator.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * FlareSystemsCalculator interface.
  6 |     |  */
  7 |     | interface IFlareSystemsCalculator {
  8 |     |     /// Event emitted when the registration weight of a voter is calculated.
  9 |     |     event VoterRegistrationInfo(
 10 |     |         address indexed voter,
 11 |     |         uint24 indexed rewardEpochId,
 12 |     |         address delegationAddress,
 13 |     |         uint16 delegationFeeBIPS,
 14 |     |         uint256 wNatWeight,
 15 |     |         uint256 wNatCappedWeight,
 16 |     |         bytes20[] nodeIds,
 17 |     |         uint256[] nodeWeights
 18 |     |     );
 19 |     | 
 20 |     |     /// WNat cap used in signing policy weight.
 21 |     |     function wNatCapPPM() external view returns (uint24);
 22 |     |     /// Non-punishable time to sign new signing policy.
 23 |     |     function signingPolicySignNonPunishableDurationSeconds()
 24 |     |         external
 25 |     |         view
 26 |     |         returns (uint64);
 27 |     |     /// Number of non-punishable blocks to sign new signing policy.
 28 |     |     function signingPolicySignNonPunishableDurationBlocks()
 29 |     |         external
 30 |     |         view
 31 |     |         returns (uint64);
 32 |     |     /// Number of blocks (in addition to non-punishable blocks) after which all rewards are burned.
 33 |     |     function signingPolicySignNoRewardsDurationBlocks()
 34 |     |         external
 35 |     |         view
 36 |     |         returns (uint64);
 37 |     | }
 38 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFlareSystemsManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | import "./ProtocolsV2Interface.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * FlareSystemsManager interface.
   8 |     |  */
   9 |     | interface IFlareSystemsManager is ProtocolsV2Interface {
  10 |     |     /// Signature structure
  11 |     |     struct Signature {
  12 |     |         uint8 v;
  13 |     |         bytes32 r;
  14 |     |         bytes32 s;
  15 |     |     }
  16 |     | 
  17 |     |     /// Number of weight based claims structure
  18 |     |     struct NumberOfWeightBasedClaims {
  19 |     |         uint256 rewardManagerId;
  20 |     |         uint256 noOfWeightBasedClaims;
  21 |     |     }
  22 |     | 
  23 |     |     /// Event emitted when random acquisition phase starts.
  24 |     |     event RandomAcquisitionStarted(
  25 |     |         uint24 indexed rewardEpochId, // Reward epoch id
  26 |     |         uint64 timestamp // Timestamp when this happened
  27 |     |     );
  28 |     | 
  29 |     |     /// Event emitted when vote power block is selected.
  30 |     |     event VotePowerBlockSelected(
  31 |     |         uint24 indexed rewardEpochId, // Reward epoch id
  32 |     |         uint64 votePowerBlock, // Vote power block for given reward epoch
  33 |     |         uint64 timestamp // Timestamp when this happened
  34 |     |     );
  35 |     | 
  36 |     |     /// Event emitted when signing policy is signed.
  37 |     |     event SigningPolicySigned(
  38 |     |         uint24 indexed rewardEpochId, // Reward epoch id
  39 |     |         address indexed signingPolicyAddress, // Address which signed this
  40 |     |         address indexed voter, // Voter (entity)
  41 |     |         uint64 timestamp, // Timestamp when this happened
  42 |     |         bool thresholdReached // Indicates if signing threshold was reached
  43 |     |     );
  44 |     | 
  45 |     |     /// Event emitted when reward epoch starts.
  46 |     |     event RewardEpochStarted(
  47 |     |         uint24 indexed rewardEpochId, // Reward epoch id
  48 |     |         uint32 startVotingRoundId, // First voting round id of validity
  49 |     |         uint64 timestamp // Timestamp when this happened
  50 |     |     );
  51 |     | 
  52 |     |     /// Event emitted when it is time to sign uptime vote.
  53 |     |     event SignUptimeVoteEnabled(
  54 |     |         uint24 indexed rewardEpochId, // Reward epoch id
  55 |     |         uint64 timestamp // Timestamp when this happened
  56 |     |     );
  57 |     | 
  58 |     |     /// Event emitted when uptime vote is submitted.
  59 |     |     event UptimeVoteSubmitted(
  60 |     |         uint24 indexed rewardEpochId, // Reward epoch id
  61 |     |         address indexed signingPolicyAddress, // Address which signed this
  62 |     |         address indexed voter, // Voter (entity)
  63 |     |         bytes20[] nodeIds, // Node ids with high enough uptime
  64 |     |         uint64 timestamp // Timestamp when this happened
  65 |     |     );
  66 |     | 
  67 |     |     /// Event emitted when uptime vote is signed.
  68 |     |     event UptimeVoteSigned(
  69 |     |         uint24 indexed rewardEpochId, // Reward epoch id
  70 |     |         address indexed signingPolicyAddress, // Address which signed this
  71 |     |         address indexed voter, // Voter (entity)
  72 |     |         bytes32 uptimeVoteHash, // Uptime vote hash
  73 |     |         uint64 timestamp, // Timestamp when this happened
  74 |     |         bool thresholdReached // Indicates if signing threshold was reached
  75 |     |     );
  76 |     | 
  77 |     |     /// Event emitted when rewards are signed.
  78 |     |     event RewardsSigned(
  79 |     |         uint24 indexed rewardEpochId, // Reward epoch id
  80 |     |         address indexed signingPolicyAddress, // Address which signed this
  81 |     |         address indexed voter, // Voter (entity)
  82 |     |         bytes32 rewardsHash, // Rewards hash
  83 |     |         NumberOfWeightBasedClaims[] noOfWeightBasedClaims, // Number of weight based claims list
  84 |     |         uint64 timestamp, // Timestamp when this happened
  85 |     |         bool thresholdReached // Indicates if signing threshold was reached
  86 |     |     );
  87 |     | 
  88 |     |     /**
  89 |     |      * Method for collecting signatures for the new signing policy.
  90 |     |      * @param _rewardEpochId Reward epoch id of the new signing policy.
  91 |     |      * @param _newSigningPolicyHash New signing policy hash.
  92 |     |      * @param _signature Signature.
  93 |     |      */
  94 |     |     function signNewSigningPolicy(
  95 |     |         uint24 _rewardEpochId,
  96 |     |         bytes32 _newSigningPolicyHash,
  97 |     |         Signature calldata _signature
  98 |     |     ) external;
  99 |     | 
 100 |     |     /**
 101 |     |      * Method for submitting node ids with high enough uptime.
 102 |     |      * @param _rewardEpochId Reward epoch id of the uptime vote.
 103 |     |      * @param _nodeIds Node ids with high enough uptime.
 104 |     |      * @param _signature Signature.
 105 |     |      */
 106 |     |     function submitUptimeVote(
 107 |     |         uint24 _rewardEpochId,
 108 |     |         bytes20[] calldata _nodeIds,
 109 |     |         Signature calldata _signature
 110 |     |     ) external;
 111 |     | 
 112 |     |     /**
 113 |     |      * Method for collecting signatures for the uptime vote.
 114 |     |      * @param _rewardEpochId Reward epoch id of the uptime vote.
 115 |     |      * @param _uptimeVoteHash Uptime vote hash.
 116 |     |      * @param _signature Signature.
 117 |     |      */
 118 |     |     function signUptimeVote(
 119 |     |         uint24 _rewardEpochId,
 120 |     |         bytes32 _uptimeVoteHash,
 121 |     |         Signature calldata _signature
 122 |     |     ) external;
 123 |     | 
 124 |     |     /**
 125 |     |      * Method for collecting signatures for the rewards.
 126 |     |      * @param _rewardEpochId Reward epoch id of the rewards.
 127 |     |      * @param _noOfWeightBasedClaims Number of weight based claims list.
 128 |     |      * @param _rewardsHash Rewards hash.
 129 |     |      * @param _signature Signature.
 130 |     |      */
 131 |     |     function signRewards(
 132 |     |         uint24 _rewardEpochId,
 133 |     |         NumberOfWeightBasedClaims[] calldata _noOfWeightBasedClaims,
 134 |     |         bytes32 _rewardsHash,
 135 |     |         Signature calldata _signature
 136 |     |     ) external;
 137 |     | 
 138 |     |     /**
 139 |     |      * Returns the seed for given reward epoch id.
 140 |     |      */
 141 |     |     function getSeed(uint256 _rewardEpochId) external view returns (uint256);
 142 |     | 
 143 |     |     /**
 144 |     |      * Returns the threshold for given reward epoch id.
 145 |     |      */
 146 |     |     function getThreshold(
 147 |     |         uint256 _rewardEpochId
 148 |     |     ) external view returns (uint16);
 149 |     | 
 150 |     |     /**
 151 |     |      * Returns voter rgistration data for given reward epoch id.
 152 |     |      * @param _rewardEpochId Reward epoch id.
 153 |     |      * @return _votePowerBlock Vote power block.
 154 |     |      * @return _enabled Indicates if voter registration is enabled.
 155 |     |      */
 156 |     |     function getVoterRegistrationData(
 157 |     |         uint256 _rewardEpochId
 158 |     |     ) external view returns (uint256 _votePowerBlock, bool _enabled);
 159 |     | 
 160 |     |     /**
 161 |     |      * Indicates if voter registration is currently enabled.
 162 |     |      */
 163 |     |     function isVoterRegistrationEnabled() external view returns (bool);
 164 |     | 
 165 |     |     /**
 166 |     |      * Returns the current reward epoch id (backwards compatibility).
 167 |     |      */
 168 |     |     function getCurrentRewardEpoch() external view returns (uint256);
 169 |     | }
 170 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFtso.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | interface IFtso {
   5 |     |     enum PriceFinalizationType {
   6 |     |         // initial state
   7 |     |         NOT_FINALIZED,
   8 |     |         // median calculation used to find price
   9 |     |         WEIGHTED_MEDIAN,
  10 |     |         // low turnout - price calculated from median of trusted addresses
  11 |     |         TRUSTED_ADDRESSES,
  12 |     |         // low turnout + no votes from trusted addresses - price copied from previous epoch
  13 |     |         PREVIOUS_PRICE_COPIED,
  14 |     |         // price calculated from median of trusted addresses - triggered due to an exception
  15 |     |         TRUSTED_ADDRESSES_EXCEPTION,
  16 |     |         // previous price copied - triggered due to an exception
  17 |     |         PREVIOUS_PRICE_COPIED_EXCEPTION
  18 |     |     }
  19 |     | 
  20 |     |     event PriceRevealed(
  21 |     |         address indexed voter,
  22 |     |         uint256 indexed epochId,
  23 |     |         uint256 price,
  24 |     |         uint256 timestamp,
  25 |     |         uint256 votePowerNat,
  26 |     |         uint256 votePowerAsset
  27 |     |     );
  28 |     | 
  29 |     |     event PriceFinalized(
  30 |     |         uint256 indexed epochId,
  31 |     |         uint256 price,
  32 |     |         bool rewardedFtso,
  33 |     |         uint256 lowIQRRewardPrice,
  34 |     |         uint256 highIQRRewardPrice,
  35 |     |         uint256 lowElasticBandRewardPrice,
  36 |     |         uint256 highElasticBandRewardPrice,
  37 |     |         PriceFinalizationType finalizationType,
  38 |     |         uint256 timestamp
  39 |     |     );
  40 |     | 
  41 |     |     event PriceEpochInitializedOnFtso(
  42 |     |         uint256 indexed epochId,
  43 |     |         uint256 endTime,
  44 |     |         uint256 timestamp
  45 |     |     );
  46 |     | 
  47 |     |     event LowTurnout(
  48 |     |         uint256 indexed epochId,
  49 |     |         uint256 natTurnout,
  50 |     |         uint256 lowNatTurnoutThresholdBIPS,
  51 |     |         uint256 timestamp
  52 |     |     );
  53 |     | 
  54 |     |     /**
  55 |     |      * @notice Returns if FTSO is active
  56 |     |      */
  57 |     |     function active() external view returns (bool);
  58 |     | 
  59 |     |     /**
  60 |     |      * @notice Returns the FTSO symbol
  61 |     |      */
  62 |     |     function symbol() external view returns (string memory);
  63 |     | 
  64 |     |     /**
  65 |     |      * @notice Returns current epoch id
  66 |     |      */
  67 |     |     function getCurrentEpochId() external view returns (uint256);
  68 |     | 
  69 |     |     /**
  70 |     |      * @notice Returns id of the epoch which was opened for price submission at the specified timestamp
  71 |     |      * @param _timestamp            Timestamp as seconds from unix epoch
  72 |     |      */
  73 |     |     function getEpochId(uint256 _timestamp) external view returns (uint256);
  74 |     | 
  75 |     |     /**
  76 |     |      * @notice Returns random number of the specified epoch
  77 |     |      * @param _epochId              Id of the epoch
  78 |     |      */
  79 |     |     function getRandom(uint256 _epochId) external view returns (uint256);
  80 |     | 
  81 |     |     /**
  82 |     |      * @notice Returns asset price consented in specific epoch
  83 |     |      * @param _epochId              Id of the epoch
  84 |     |      * @return Price in USD multiplied by ASSET_PRICE_USD_DECIMALS
  85 |     |      */
  86 |     |     function getEpochPrice(uint256 _epochId) external view returns (uint256);
  87 |     | 
  88 |     |     /**
  89 |     |      * @notice Returns current epoch data
  90 |     |      * @return _epochId                 Current epoch id
  91 |     |      * @return _epochSubmitEndTime      End time of the current epoch price submission as seconds from unix epoch
  92 |     |      * @return _epochRevealEndTime      End time of the current epoch price reveal as seconds from unix epoch
  93 |     |      * @return _votePowerBlock          Vote power block for the current epoch
  94 |     |      * @return _fallbackMode            Current epoch in fallback mode - only votes from trusted addresses will be used
  95 |     |      * @dev half-closed intervals - end time not included
  96 |     |      */
  97 |     |     function getPriceEpochData()
  98 |     |         external
  99 |     |         view
 100 |     |         returns (
 101 |     |             uint256 _epochId,
 102 |     |             uint256 _epochSubmitEndTime,
 103 |     |             uint256 _epochRevealEndTime,
 104 |     |             uint256 _votePowerBlock,
 105 |     |             bool _fallbackMode
 106 |     |         );
 107 |     | 
 108 |     |     /**
 109 |     |      * @notice Returns current epoch data
 110 |     |      * @return _firstEpochStartTs           First epoch start timestamp
 111 |     |      * @return _submitPeriodSeconds         Submit period in seconds
 112 |     |      * @return _revealPeriodSeconds         Reveal period in seconds
 113 |     |      */
 114 |     |     function getPriceEpochConfiguration()
 115 |     |         external
 116 |     |         view
 117 |     |         returns (
 118 |     |             uint256 _firstEpochStartTs,
 119 |     |             uint256 _submitPeriodSeconds,
 120 |     |             uint256 _revealPeriodSeconds
 121 |     |         );
 122 |     | 
 123 |     |     /**
 124 |     |      * @notice Returns asset price submitted by voter in specific epoch
 125 |     |      * @param _epochId              Id of the epoch
 126 |     |      * @param _voter                Address of the voter
 127 |     |      * @return Price in USD multiplied by ASSET_PRICE_USD_DECIMALS
 128 |     |      */
 129 |     |     function getEpochPriceForVoter(
 130 |     |         uint256 _epochId,
 131 |     |         address _voter
 132 |     |     ) external view returns (uint256);
 133 |     | 
 134 |     |     /**
 135 |     |      * @notice Returns current asset price
 136 |     |      * @return _price               Price in USD multiplied by ASSET_PRICE_USD_DECIMALS
 137 |     |      * @return _timestamp           Time when price was updated for the last time
 138 |     |      */
 139 |     |     function getCurrentPrice()
 140 |     |         external
 141 |     |         view
 142 |     |         returns (uint256 _price, uint256 _timestamp);
 143 |     | 
 144 |     |     /**
 145 |     |      * @notice Returns current asset price and number of decimals
 146 |     |      * @return _price                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS
 147 |     |      * @return _timestamp               Time when price was updated for the last time
 148 |     |      * @return _assetPriceUsdDecimals   Number of decimals used for USD price
 149 |     |      */
 150 |     |     function getCurrentPriceWithDecimals()
 151 |     |         external
 152 |     |         view
 153 |     |         returns (
 154 |     |             uint256 _price,
 155 |     |             uint256 _timestamp,
 156 |     |             uint256 _assetPriceUsdDecimals
 157 |     |         );
 158 |     | 
 159 |     |     /**
 160 |     |      * @notice Returns current asset price calculated from trusted providers
 161 |     |      * @return _price               Price in USD multiplied by ASSET_PRICE_USD_DECIMALS
 162 |     |      * @return _timestamp           Time when price was updated for the last time
 163 |     |      */
 164 |     |     function getCurrentPriceFromTrustedProviders()
 165 |     |         external
 166 |     |         view
 167 |     |         returns (uint256 _price, uint256 _timestamp);
 168 |     | 
 169 |     |     /**
 170 |     |      * @notice Returns current asset price calculated from trusted providers and number of decimals
 171 |     |      * @return _price                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS
 172 |     |      * @return _timestamp               Time when price was updated for the last time
 173 |     |      * @return _assetPriceUsdDecimals   Number of decimals used for USD price
 174 |     |      */
 175 |     |     function getCurrentPriceWithDecimalsFromTrustedProviders()
 176 |     |         external
 177 |     |         view
 178 |     |         returns (
 179 |     |             uint256 _price,
 180 |     |             uint256 _timestamp,
 181 |     |             uint256 _assetPriceUsdDecimals
 182 |     |         );
 183 |     | 
 184 |     |     /**
 185 |     |      * @notice Returns current asset price details
 186 |     |      * @return _price                                   Price in USD multiplied by ASSET_PRICE_USD_DECIMALS
 187 |     |      * @return _priceTimestamp                          Time when price was updated for the last time
 188 |     |      * @return _priceFinalizationType                   Finalization type when price was updated for the last time
 189 |     |      * @return _lastPriceEpochFinalizationTimestamp     Time when last price epoch was finalized
 190 |     |      * @return _lastPriceEpochFinalizationType          Finalization type of last finalized price epoch
 191 |     |      */
 192 |     |     function getCurrentPriceDetails()
 193 |     |         external
 194 |     |         view
 195 |     |         returns (
 196 |     |             uint256 _price,
 197 |     |             uint256 _priceTimestamp,
 198 |     |             PriceFinalizationType _priceFinalizationType,
 199 |     |             uint256 _lastPriceEpochFinalizationTimestamp,
 200 |     |             PriceFinalizationType _lastPriceEpochFinalizationType
 201 |     |         );
 202 |     | 
 203 |     |     /**
 204 |     |      * @notice Returns current random number
 205 |     |      */
 206 |     |     function getCurrentRandom() external view returns (uint256);
 207 |     | }
 208 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFtsoFeedDecimals.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * FtsoFeedDecimals interface.
  6 |     |  */
  7 |     | interface IFtsoFeedDecimals {
  8 |     |     /// Event emitted when a feed decimals value is changed.
  9 |     |     event DecimalsChanged(
 10 |     |         bytes21 indexed feedId,
 11 |     |         int8 decimals,
 12 |     |         uint24 rewardEpochId
 13 |     |     );
 14 |     | 
 15 |     |     /// The offset in reward epochs for the decimals value to become effective.
 16 |     |     function decimalsUpdateOffset() external view returns (uint24);
 17 |     | 
 18 |     |     /// The default decimals value.
 19 |     |     function defaultDecimals() external view returns (int8);
 20 |     | 
 21 |     |     /**
 22 |     |      * Returns current decimals set for `_feedId`.
 23 |     |      * @param _feedId Feed id.
 24 |     |      */
 25 |     |     function getCurrentDecimals(bytes21 _feedId) external view returns (int8);
 26 |     | 
 27 |     |     /**
 28 |     |      * Returns the decimals of `_feedId` for given reward epoch id.
 29 |     |      * @param _feedId Feed id.
 30 |     |      * @param _rewardEpochId Reward epoch id.
 31 |     |      * **NOTE:** decimals might still change for the `current + decimalsUpdateOffset` reward epoch id.
 32 |     |      */
 33 |     |     function getDecimals(
 34 |     |         bytes21 _feedId,
 35 |     |         uint256 _rewardEpochId
 36 |     |     ) external view returns (int8);
 37 |     | 
 38 |     |     /**
 39 |     |      * Returns the scheduled decimals changes of `_feedId`.
 40 |     |      * @param _feedId Feed id.
 41 |     |      * @return _decimals Positional array of decimals.
 42 |     |      * @return _validFromEpochId Positional array of reward epoch ids the decimals settings are effective from.
 43 |     |      * @return _fixed Positional array of boolean values indicating if settings are subjected to change.
 44 |     |      */
 45 |     |     function getScheduledDecimalsChanges(
 46 |     |         bytes21 _feedId
 47 |     |     )
 48 |     |         external
 49 |     |         view
 50 |     |         returns (
 51 |     |             int8[] memory _decimals,
 52 |     |             uint256[] memory _validFromEpochId,
 53 |     |             bool[] memory _fixed
 54 |     |         );
 55 |     | 
 56 |     |     /**
 57 |     |      * Returns current decimals setting for `_feedIds`.
 58 |     |      * @param _feedIds Concatenated feed ids (each feedId bytes21).
 59 |     |      * @return _decimals Concatenated corresponding decimals (each as bytes1(uint8(int8))).
 60 |     |      */
 61 |     |     function getCurrentDecimalsBulk(
 62 |     |         bytes memory _feedIds
 63 |     |     ) external view returns (bytes memory _decimals);
 64 |     | 
 65 |     |     /**
 66 |     |      * Returns decimals setting for `_feedIds` at `_rewardEpochId`.
 67 |     |      * @param _feedIds Concatenated feed ids (each feedId bytes21).
 68 |     |      * @param _rewardEpochId Reward epoch id.
 69 |     |      * @return _decimals Concatenated corresponding decimals (each as bytes1(uint8(int8))).
 70 |     |      * **NOTE:** decimals might still change for the `current + decimalsUpdateOffset` reward epoch id.
 71 |     |      */
 72 |     |     function getDecimalsBulk(
 73 |     |         bytes memory _feedIds,
 74 |     |         uint256 _rewardEpochId
 75 |     |     ) external view returns (bytes memory _decimals);
 76 |     | }
 77 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFtsoFeedIdConverter.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * IFtsoFeedIdConverter interface.
  6 |     |  */
  7 |     | interface IFtsoFeedIdConverter {
  8 |     |     /**
  9 |     |      * Returns the feed id for given category and name.
 10 |     |      * @param _category Feed category.
 11 |     |      * @param _name Feed name.
 12 |     |      * @return Feed id.
 13 |     |      */
 14 |     |     function getFeedId(
 15 |     |         uint8 _category,
 16 |     |         string memory _name
 17 |     |     ) external view returns (bytes21);
 18 |     | 
 19 |     |     /**
 20 |     |      * Returns the feed category and name for given feed id.
 21 |     |      * @param _feedId Feed id.
 22 |     |      * @return _category Feed category.
 23 |     |      * @return _name Feed name.
 24 |     |      */
 25 |     |     function getFeedCategoryAndName(
 26 |     |         bytes21 _feedId
 27 |     |     ) external pure returns (uint8 _category, string memory _name);
 28 |     | }
 29 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFtsoFeedPublisher.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * FtsoFeedPublisher interface.
  6 |     |  */
  7 |     | interface IFtsoFeedPublisher {
  8 |     |     /// The FTSO feed struct.
  9 |     |     struct Feed {
 10 |     |         uint32 votingRoundId;
 11 |     |         bytes21 id;
 12 |     |         int32 value;
 13 |     |         uint16 turnoutBIPS;
 14 |     |         int8 decimals;
 15 |     |     }
 16 |     | 
 17 |     |     /// The FTSO random struct.
 18 |     |     struct Random {
 19 |     |         uint32 votingRoundId;
 20 |     |         uint256 value;
 21 |     |         bool isSecure;
 22 |     |     }
 23 |     | 
 24 |     |     /// The FTSO feed with proof struct.
 25 |     |     struct FeedWithProof {
 26 |     |         bytes32[] merkleProof;
 27 |     |         Feed body;
 28 |     |     }
 29 |     | 
 30 |     |     /// Event emitted when a new feed is published.
 31 |     |     event FtsoFeedPublished(
 32 |     |         uint32 indexed votingRoundId,
 33 |     |         bytes21 indexed id,
 34 |     |         int32 value,
 35 |     |         uint16 turnoutBIPS,
 36 |     |         int8 decimals
 37 |     |     );
 38 |     | 
 39 |     |     /**
 40 |     |      * Publishes feeds.
 41 |     |      * @param _proofs The FTSO feeds with proofs to publish.
 42 |     |      */
 43 |     |     function publish(FeedWithProof[] calldata _proofs) external;
 44 |     | 
 45 |     |     /**
 46 |     |      *The FTSO protocol id.
 47 |     |      */
 48 |     |     function ftsoProtocolId() external view returns (uint8);
 49 |     | 
 50 |     |     /**
 51 |     |      * The size of the feeds history.
 52 |     |      */
 53 |     |     function feedsHistorySize() external view returns (uint256);
 54 |     | 
 55 |     |     /**
 56 |     |      * Returns the current feed.
 57 |     |      * @param _feedId Feed id.
 58 |     |      */
 59 |     |     function getCurrentFeed(
 60 |     |         bytes21 _feedId
 61 |     |     ) external view returns (Feed memory);
 62 |     | 
 63 |     |     /**
 64 |     |      * Returns the feed for given voting round id.
 65 |     |      * @param _feedId Feed id.
 66 |     |      * @param _votingRoundId Voting round id.
 67 |     |      */
 68 |     |     function getFeed(
 69 |     |         bytes21 _feedId,
 70 |     |         uint256 _votingRoundId
 71 |     |     ) external view returns (Feed memory);
 72 |     | }
 73 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFtsoInflationConfigurations.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * FtsoInflationConfigurations interface.
  6 |     |  */
  7 |     | interface IFtsoInflationConfigurations {
  8 |     |     /// The FTSO configuration struct.
  9 |     |     struct FtsoConfiguration {
 10 |     |         // concatenated feed ids - i.e. category + base/quote symbol - multiple of 21 (one feedId is bytes21)
 11 |     |         bytes feedIds;
 12 |     |         // inflation share for this configuration group
 13 |     |         uint24 inflationShare;
 14 |     |         // minimal reward eligibility turnout threshold in BIPS (basis points)
 15 |     |         uint16 minRewardedTurnoutBIPS;
 16 |     |         // primary band reward share in PPM (parts per million)
 17 |     |         uint24 primaryBandRewardSharePPM;
 18 |     |         // secondary band width in PPM (parts per million) in relation to the median - multiple of 3 (uint24)
 19 |     |         bytes secondaryBandWidthPPMs;
 20 |     |         // rewards split mode (0 means equally, 1 means random,...)
 21 |     |         uint16 mode;
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * Returns the FTSO configuration at `_index`.
 26 |     |      * @param _index The index of the FTSO configuration.
 27 |     |      */
 28 |     |     function getFtsoConfiguration(
 29 |     |         uint256 _index
 30 |     |     ) external view returns (FtsoConfiguration memory);
 31 |     | 
 32 |     |     /**
 33 |     |      * Returns the FTSO configurations.
 34 |     |      */
 35 |     |     function getFtsoConfigurations()
 36 |     |         external
 37 |     |         view
 38 |     |         returns (FtsoConfiguration[] memory);
 39 |     | }
 40 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFtsoManager.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "./ftso/interfaces/IIFtso.sol";
  5 |     | import "./genesis/interfaces/IFtsoManagerGenesis.sol";
  6 |     | 
  7 |     | interface IFtsoManager is IFtsoManagerGenesis {
  8 |     |     event FtsoAdded(IIFtso ftso, bool add);
  9 |     |     event FallbackMode(bool fallbackMode);
 10 |     |     event FtsoFallbackMode(IIFtso ftso, bool fallbackMode);
 11 |     |     event RewardEpochFinalized(uint256 votepowerBlock, uint256 startBlock);
 12 |     |     event PriceEpochFinalized(address chosenFtso, uint256 rewardEpochId);
 13 |     |     event InitializingCurrentEpochStateForRevealFailed(
 14 |     |         IIFtso ftso,
 15 |     |         uint256 epochId
 16 |     |     );
 17 |     |     event FinalizingPriceEpochFailed(
 18 |     |         IIFtso ftso,
 19 |     |         uint256 epochId,
 20 |     |         IFtso.PriceFinalizationType failingType
 21 |     |     );
 22 |     |     event DistributingRewardsFailed(address ftso, uint256 epochId);
 23 |     |     event AccruingUnearnedRewardsFailed(uint256 epochId);
 24 |     |     event UseGoodRandomSet(
 25 |     |         bool useGoodRandom,
 26 |     |         uint256 maxWaitForGoodRandomSeconds
 27 |     |     );
 28 |     | 
 29 |     |     function active() external view returns (bool);
 30 |     | 
 31 |     |     function getCurrentRewardEpoch() external view returns (uint256);
 32 |     | 
 33 |     |     function getRewardEpochVotePowerBlock(
 34 |     |         uint256 _rewardEpoch
 35 |     |     ) external view returns (uint256);
 36 |     | 
 37 |     |     function getRewardEpochToExpireNext() external view returns (uint256);
 38 |     | 
 39 |     |     function getCurrentPriceEpochData()
 40 |     |         external
 41 |     |         view
 42 |     |         returns (
 43 |     |             uint256 _priceEpochId,
 44 |     |             uint256 _priceEpochStartTimestamp,
 45 |     |             uint256 _priceEpochEndTimestamp,
 46 |     |             uint256 _priceEpochRevealEndTimestamp,
 47 |     |             uint256 _currentTimestamp
 48 |     |         );
 49 |     | 
 50 |     |     function getFtsos() external view returns (IIFtso[] memory _ftsos);
 51 |     | 
 52 |     |     function getPriceEpochConfiguration()
 53 |     |         external
 54 |     |         view
 55 |     |         returns (
 56 |     |             uint256 _firstPriceEpochStartTs,
 57 |     |             uint256 _priceEpochDurationSeconds,
 58 |     |             uint256 _revealEpochDurationSeconds
 59 |     |         );
 60 |     | 
 61 |     |     function getRewardEpochConfiguration()
 62 |     |         external
 63 |     |         view
 64 |     |         returns (
 65 |     |             uint256 _firstRewardEpochStartTs,
 66 |     |             uint256 _rewardEpochDurationSeconds
 67 |     |         );
 68 |     | 
 69 |     |     function getFallbackMode()
 70 |     |         external
 71 |     |         view
 72 |     |         returns (
 73 |     |             bool _fallbackMode,
 74 |     |             IIFtso[] memory _ftsos,
 75 |     |             bool[] memory _ftsoInFallbackMode
 76 |     |         );
 77 |     | }
 78 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFtsoRegistry.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | pragma abicoder v2;
   4 |     | 
   5 |     | import "./ftso/interfaces/IIFtso.sol";
   6 |     | import "./genesis/interfaces/IFtsoRegistryGenesis.sol";
   7 |     | 
   8 |     | interface IFtsoRegistry is IFtsoRegistryGenesis {
   9 |     |     struct PriceInfo {
  10 |     |         uint256 ftsoIndex;
  11 |     |         uint256 price;
  12 |     |         uint256 decimals;
  13 |     |         uint256 timestamp;
  14 |     |     }
  15 |     | 
  16 |     |     function getFtso(
  17 |     |         uint256 _ftsoIndex
  18 |     |     ) external view returns (IIFtso _activeFtsoAddress);
  19 |     |     function getFtsoBySymbol(
  20 |     |         string memory _symbol
  21 |     |     ) external view returns (IIFtso _activeFtsoAddress);
  22 |     |     function getSupportedIndices()
  23 |     |         external
  24 |     |         view
  25 |     |         returns (uint256[] memory _supportedIndices);
  26 |     |     function getSupportedSymbols()
  27 |     |         external
  28 |     |         view
  29 |     |         returns (string[] memory _supportedSymbols);
  30 |     |     function getSupportedFtsos() external view returns (IIFtso[] memory _ftsos);
  31 |     |     function getFtsoIndex(
  32 |     |         string memory _symbol
  33 |     |     ) external view returns (uint256 _assetIndex);
  34 |     |     function getFtsoSymbol(
  35 |     |         uint256 _ftsoIndex
  36 |     |     ) external view returns (string memory _symbol);
  37 |     |     function getCurrentPrice(
  38 |     |         uint256 _ftsoIndex
  39 |     |     ) external view returns (uint256 _price, uint256 _timestamp);
  40 |     |     function getCurrentPrice(
  41 |     |         string memory _symbol
  42 |     |     ) external view returns (uint256 _price, uint256 _timestamp);
  43 |     |     function getCurrentPriceWithDecimals(
  44 |     |         uint256 _assetIndex
  45 |     |     )
  46 |     |         external
  47 |     |         view
  48 |     |         returns (
  49 |     |             uint256 _price,
  50 |     |             uint256 _timestamp,
  51 |     |             uint256 _assetPriceUsdDecimals
  52 |     |         );
  53 |     |     function getCurrentPriceWithDecimals(
  54 |     |         string memory _symbol
  55 |     |     )
  56 |     |         external
  57 |     |         view
  58 |     |         returns (
  59 |     |             uint256 _price,
  60 |     |             uint256 _timestamp,
  61 |     |             uint256 _assetPriceUsdDecimals
  62 |     |         );
  63 |     | 
  64 |     |     function getAllCurrentPrices() external view returns (PriceInfo[] memory);
  65 |     |     function getCurrentPricesByIndices(
  66 |     |         uint256[] memory _indices
  67 |     |     ) external view returns (PriceInfo[] memory);
  68 |     |     function getCurrentPricesBySymbols(
  69 |     |         string[] memory _symbols
  70 |     |     ) external view returns (PriceInfo[] memory);
  71 |     | 
  72 |     |     function getSupportedIndicesAndFtsos()
  73 |     |         external
  74 |     |         view
  75 |     |         returns (uint256[] memory _supportedIndices, IIFtso[] memory _ftsos);
  76 |     | 
  77 |     |     function getSupportedSymbolsAndFtsos()
  78 |     |         external
  79 |     |         view
  80 |     |         returns (string[] memory _supportedSymbols, IIFtso[] memory _ftsos);
  81 |     | 
  82 |     |     function getSupportedIndicesAndSymbols()
  83 |     |         external
  84 |     |         view
  85 |     |         returns (
  86 |     |             uint256[] memory _supportedIndices,
  87 |     |             string[] memory _supportedSymbols
  88 |     |         );
  89 |     | 
  90 |     |     function getSupportedIndicesSymbolsAndFtsos()
  91 |     |         external
  92 |     |         view
  93 |     |         returns (
  94 |     |             uint256[] memory _supportedIndices,
  95 |     |             string[] memory _supportedSymbols,
  96 |     |             IIFtso[] memory _ftsos
  97 |     |         );
  98 |     | }
  99 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFtsoRewardManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | interface IFtsoRewardManager {
   5 |     |     event RewardClaimed(
   6 |     |         address indexed dataProvider,
   7 |     |         address indexed whoClaimed,
   8 |     |         address indexed sentTo,
   9 |     |         uint256 rewardEpoch,
  10 |     |         uint256 amount
  11 |     |     );
  12 |     | 
  13 |     |     event UnearnedRewardsAccrued(uint256 epochId, uint256 reward);
  14 |     | 
  15 |     |     event RewardsDistributed(
  16 |     |         address indexed ftso,
  17 |     |         uint256 epochId,
  18 |     |         address[] addresses,
  19 |     |         uint256[] rewards
  20 |     |     );
  21 |     | 
  22 |     |     event RewardClaimsEnabled(uint256 rewardEpochId);
  23 |     | 
  24 |     |     event FeePercentageChanged(
  25 |     |         address indexed dataProvider,
  26 |     |         uint256 value,
  27 |     |         uint256 validFromEpoch
  28 |     |     );
  29 |     | 
  30 |     |     event RewardClaimsExpired(uint256 rewardEpochId);
  31 |     | 
  32 |     |     event FtsoRewardManagerActivated(address ftsoRewardManager);
  33 |     |     event FtsoRewardManagerDeactivated(address ftsoRewardManager);
  34 |     | 
  35 |     |     /**
  36 |     |      * @notice Allows a percentage delegator to claim rewards.
  37 |     |      * @notice This function is intended to be used to claim rewards in case of delegation by percentage.
  38 |     |      * @param _recipient            address to transfer funds to
  39 |     |      * @param _rewardEpochs         array of reward epoch numbers to claim for
  40 |     |      * @return _rewardAmount        amount of total claimed rewards
  41 |     |      * @dev Reverts if `msg.sender` is delegating by amount
  42 |     |      * @dev Claims for all unclaimed reward epochs to the 'max(_rewardEpochs)'.
  43 |     |      * @dev Retained for backward compatibility.
  44 |     |      * @dev This function is deprecated - use `claim` instead.
  45 |     |      */
  46 |     |     function claimReward(
  47 |     |         address payable _recipient,
  48 |     |         uint256[] calldata _rewardEpochs
  49 |     |     ) external returns (uint256 _rewardAmount);
  50 |     | 
  51 |     |     /**
  52 |     |      * @notice Allows the sender to claim or wrap rewards for reward owner.
  53 |     |      * @notice This function is intended to be used to claim rewards in case of delegation by percentage.
  54 |     |      * @notice The caller does not have to be the owner, but must be approved by the owner to claim on his behalf,
  55 |     |      *   this approval is done by calling `setClaimExecutors`.
  56 |     |      * @notice It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can
  57 |     |      *   call, we allow the owner to control the timing of the calls.
  58 |     |      * @notice Reward owner can claim to any `_recipient`, while the executor can only claim to the reward owner,
  59 |     |      *   reward owners's personal delegation account or one of the addresses set by `setAllowedClaimRecipients`.
  60 |     |      * @param _rewardOwner          address of the reward owner
  61 |     |      * @param _recipient            address to transfer funds to
  62 |     |      * @param _rewardEpoch          last reward epoch to claim for
  63 |     |      * @param _wrap                 should reward be wrapped immediately
  64 |     |      * @return _rewardAmount        amount of total claimed rewards
  65 |     |      * @dev Reverts if `msg.sender` is delegating by amount
  66 |     |      */
  67 |     |     function claim(
  68 |     |         address _rewardOwner,
  69 |     |         address payable _recipient,
  70 |     |         uint256 _rewardEpoch,
  71 |     |         bool _wrap
  72 |     |     ) external returns (uint256 _rewardAmount);
  73 |     | 
  74 |     |     /**
  75 |     |      * @notice Allows the sender to claim rewards from specified data providers.
  76 |     |      * @notice This function is intended to be used to claim rewards in case of delegation by amount.
  77 |     |      * @param _recipient            address to transfer funds to
  78 |     |      * @param _rewardEpochs         array of reward epoch numbers to claim for
  79 |     |      * @param _dataProviders        array of addresses representing data providers to claim the reward from
  80 |     |      * @return _rewardAmount        amount of total claimed rewards
  81 |     |      * @dev Function can only be used for explicit delegations.
  82 |     |      * @dev This function is deprecated - use `claimFromDataProviders` instead.
  83 |     |      */
  84 |     |     function claimRewardFromDataProviders(
  85 |     |         address payable _recipient,
  86 |     |         uint256[] calldata _rewardEpochs,
  87 |     |         address[] calldata _dataProviders
  88 |     |     ) external returns (uint256 _rewardAmount);
  89 |     | 
  90 |     |     /**
  91 |     |      * @notice Allows the sender to claim or wrap rewards for reward owner from specified data providers.
  92 |     |      * @notice This function is intended to be used to claim rewards in case of delegation by amount.
  93 |     |      * @notice The caller does not have to be the owner, but must be approved by the owner to claim on his behalf,
  94 |     |      *   this approval is done by calling `setClaimExecutors`.
  95 |     |      * @notice It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can
  96 |     |      *   call, we allow the owner to control the timing of the calls.
  97 |     |      * @notice Reward owner can claim to any `_recipient`, while the executor can only claim to the reward owner,
  98 |     |      *   reward owners's personal delegation account or one of the addresses set by `setAllowedClaimRecipients`.
  99 |     |      * @param _rewardOwner          address of the reward owner
 100 |     |      * @param _recipient            address to transfer funds to
 101 |     |      * @param _rewardEpochs         array of reward epoch numbers to claim for
 102 |     |      * @param _dataProviders        array of addresses representing data providers to claim the reward from
 103 |     |      * @param _wrap                 should reward be wrapped immediately
 104 |     |      * @return _rewardAmount        amount of total claimed rewards
 105 |     |      * @dev Function can only be used for explicit delegations.
 106 |     |      */
 107 |     |     function claimFromDataProviders(
 108 |     |         address _rewardOwner,
 109 |     |         address payable _recipient,
 110 |     |         uint256[] calldata _rewardEpochs,
 111 |     |         address[] calldata _dataProviders,
 112 |     |         bool _wrap
 113 |     |     ) external returns (uint256 _rewardAmount);
 114 |     | 
 115 |     |     /**
 116 |     |      * @notice Allows batch claiming for the list of '_rewardOwners' and for all unclaimed epochs <= '_rewardEpoch'.
 117 |     |      * @notice If reward owner has enabled delegation account, rewards are also claimed for that delegation account and
 118 |     |      *   total claimed amount is sent to that delegation account, otherwise claimed amount is sent to owner's account.
 119 |     |      * @notice Claimed amount is automatically wrapped.
 120 |     |      * @notice Method can be used by reward owner or executor. If executor is registered with fee > 0,
 121 |     |      *   then fee is paid to executor for each claimed address from the list.
 122 |     |      * @param _rewardOwners         list of reward owners to claim for
 123 |     |      * @param _rewardEpoch          last reward epoch to claim for
 124 |     |      */
 125 |     |     function autoClaim(
 126 |     |         address[] calldata _rewardOwners,
 127 |     |         uint256 _rewardEpoch
 128 |     |     ) external;
 129 |     | 
 130 |     |     /**
 131 |     |      * @notice Allows data provider to set (or update last) fee percentage.
 132 |     |      * @param _feePercentageBIPS    number representing fee percentage in BIPS
 133 |     |      * @return _validFromEpoch      reward epoch number when the setting becomes effective.
 134 |     |      */
 135 |     |     function setDataProviderFeePercentage(
 136 |     |         uint256 _feePercentageBIPS
 137 |     |     ) external returns (uint256 _validFromEpoch);
 138 |     | 
 139 |     |     /**
 140 |     |      * @notice Allows reward claiming
 141 |     |      */
 142 |     |     function active() external view returns (bool);
 143 |     | 
 144 |     |     /**
 145 |     |      * @notice Returns the current fee percentage of `_dataProvider`
 146 |     |      * @param _dataProvider         address representing data provider
 147 |     |      */
 148 |     |     function getDataProviderCurrentFeePercentage(
 149 |     |         address _dataProvider
 150 |     |     ) external view returns (uint256 _feePercentageBIPS);
 151 |     | 
 152 |     |     /**
 153 |     |      * @notice Returns the fee percentage of `_dataProvider` at `_rewardEpoch`
 154 |     |      * @param _dataProvider         address representing data provider
 155 |     |      * @param _rewardEpoch          reward epoch number
 156 |     |      */
 157 |     |     function getDataProviderFeePercentage(
 158 |     |         address _dataProvider,
 159 |     |         uint256 _rewardEpoch
 160 |     |     ) external view returns (uint256 _feePercentageBIPS);
 161 |     | 
 162 |     |     /**
 163 |     |      * @notice Returns the scheduled fee percentage changes of `_dataProvider`
 164 |     |      * @param _dataProvider         address representing data provider
 165 |     |      * @return _feePercentageBIPS   positional array of fee percentages in BIPS
 166 |     |      * @return _validFromEpoch      positional array of block numbers the fee settings are effective from
 167 |     |      * @return _fixed               positional array of boolean values indicating if settings are subjected to change
 168 |     |      */
 169 |     |     function getDataProviderScheduledFeePercentageChanges(
 170 |     |         address _dataProvider
 171 |     |     )
 172 |     |         external
 173 |     |         view
 174 |     |         returns (
 175 |     |             uint256[] memory _feePercentageBIPS,
 176 |     |             uint256[] memory _validFromEpoch,
 177 |     |             bool[] memory _fixed
 178 |     |         );
 179 |     | 
 180 |     |     /**
 181 |     |      * @notice Returns information on epoch reward
 182 |     |      * @param _rewardEpoch          reward epoch number
 183 |     |      * @return _totalReward         number representing the total epoch reward
 184 |     |      * @return _claimedReward       number representing the amount of total epoch reward that has been claimed
 185 |     |      */
 186 |     |     function getEpochReward(
 187 |     |         uint256 _rewardEpoch
 188 |     |     ) external view returns (uint256 _totalReward, uint256 _claimedReward);
 189 |     | 
 190 |     |     /**
 191 |     |      * @notice Returns the state of rewards for `_beneficiary` at `_rewardEpoch`
 192 |     |      * @param _beneficiary          address of reward beneficiary
 193 |     |      * @param _rewardEpoch          reward epoch number
 194 |     |      * @return _dataProviders       positional array of addresses representing data providers
 195 |     |      * @return _rewardAmounts       positional array of reward amounts
 196 |     |      * @return _claimed             positional array of boolean values indicating if reward is claimed
 197 |     |      * @return _claimable           boolean value indicating if rewards are claimable
 198 |     |      * @dev Reverts when queried with `_beneficiary` delegating by amount
 199 |     |      */
 200 |     |     function getStateOfRewards(
 201 |     |         address _beneficiary,
 202 |     |         uint256 _rewardEpoch
 203 |     |     )
 204 |     |         external
 205 |     |         view
 206 |     |         returns (
 207 |     |             address[] memory _dataProviders,
 208 |     |             uint256[] memory _rewardAmounts,
 209 |     |             bool[] memory _claimed,
 210 |     |             bool _claimable
 211 |     |         );
 212 |     | 
 213 |     |     /**
 214 |     |      * @notice Returns the state of rewards for `_beneficiary` at `_rewardEpoch` from `_dataProviders`
 215 |     |      * @param _beneficiary          address of reward beneficiary
 216 |     |      * @param _rewardEpoch          reward epoch number
 217 |     |      * @param _dataProviders        positional array of addresses representing data providers
 218 |     |      * @return _rewardAmounts       positional array of reward amounts
 219 |     |      * @return _claimed             positional array of boolean values indicating if reward is claimed
 220 |     |      * @return _claimable           boolean value indicating if rewards are claimable
 221 |     |      */
 222 |     |     function getStateOfRewardsFromDataProviders(
 223 |     |         address _beneficiary,
 224 |     |         uint256 _rewardEpoch,
 225 |     |         address[] calldata _dataProviders
 226 |     |     )
 227 |     |         external
 228 |     |         view
 229 |     |         returns (
 230 |     |             uint256[] memory _rewardAmounts,
 231 |     |             bool[] memory _claimed,
 232 |     |             bool _claimable
 233 |     |         );
 234 |     | 
 235 |     |     /**
 236 |     |      * @notice Returns the start and the end of the reward epoch range for which the reward is claimable
 237 |     |      * @param _startEpochId         the oldest epoch id that allows reward claiming
 238 |     |      * @param _endEpochId           the newest epoch id that allows reward claiming
 239 |     |      */
 240 |     |     function getEpochsWithClaimableRewards()
 241 |     |         external
 242 |     |         view
 243 |     |         returns (uint256 _startEpochId, uint256 _endEpochId);
 244 |     | 
 245 |     |     /**
 246 |     |      * @notice Returns the next claimable reward epoch for '_rewardOwner'.
 247 |     |      * @param _rewardOwner          address of the reward owner
 248 |     |      */
 249 |     |     function nextClaimableRewardEpoch(
 250 |     |         address _rewardOwner
 251 |     |     ) external view returns (uint256);
 252 |     | 
 253 |     |     /**
 254 |     |      * @notice Returns the array of claimable epoch ids for which the reward has not yet been claimed
 255 |     |      * @param _beneficiary          address of reward beneficiary
 256 |     |      * @return _epochIds            array of epoch ids
 257 |     |      * @dev Reverts when queried with `_beneficiary` delegating by amount
 258 |     |      */
 259 |     |     function getEpochsWithUnclaimedRewards(
 260 |     |         address _beneficiary
 261 |     |     ) external view returns (uint256[] memory _epochIds);
 262 |     | 
 263 |     |     /**
 264 |     |      * @notice Returns the information on claimed reward of `_dataProvider` for `_rewardEpoch` by `_claimer`
 265 |     |      * @param _rewardEpoch          reward epoch number
 266 |     |      * @param _dataProvider         address representing the data provider
 267 |     |      * @param _claimer              address representing the claimer
 268 |     |      * @return _claimed             boolean indicating if reward has been claimed
 269 |     |      * @return _amount              number representing the claimed amount
 270 |     |      */
 271 |     |     function getClaimedReward(
 272 |     |         uint256 _rewardEpoch,
 273 |     |         address _dataProvider,
 274 |     |         address _claimer
 275 |     |     ) external view returns (bool _claimed, uint256 _amount);
 276 |     | 
 277 |     |     /**
 278 |     |      * @notice Return reward epoch that will expire, when new reward epoch will start
 279 |     |      * @return Reward epoch id that will expire next
 280 |     |      */
 281 |     |     function getRewardEpochToExpireNext() external view returns (uint256);
 282 |     | 
 283 |     |     /**
 284 |     |      * @notice Return reward epoch vote power block
 285 |     |      * @param _rewardEpoch          reward epoch number
 286 |     |      */
 287 |     |     function getRewardEpochVotePowerBlock(
 288 |     |         uint256 _rewardEpoch
 289 |     |     ) external view returns (uint256);
 290 |     | 
 291 |     |     /**
 292 |     |      * @notice Return current reward epoch number
 293 |     |      */
 294 |     |     function getCurrentRewardEpoch() external view returns (uint256);
 295 |     | 
 296 |     |     /**
 297 |     |      * @notice Return initial reward epoch number
 298 |     |      */
 299 |     |     function getInitialRewardEpoch() external view returns (uint256);
 300 |     | 
 301 |     |     /**
 302 |     |      * @notice Returns the information on rewards and initial vote power of `_dataProvider` for `_rewardEpoch`
 303 |     |      * @param _rewardEpoch                      reward epoch number
 304 |     |      * @param _dataProvider                     address representing the data provider
 305 |     |      * @return _rewardAmount                    number representing the amount of rewards
 306 |     |      * @return _votePowerIgnoringRevocation     number representing the vote power ignoring revocations
 307 |     |      */
 308 |     |     function getDataProviderPerformanceInfo(
 309 |     |         uint256 _rewardEpoch,
 310 |     |         address _dataProvider
 311 |     |     )
 312 |     |         external
 313 |     |         view
 314 |     |         returns (uint256 _rewardAmount, uint256 _votePowerIgnoringRevocation);
 315 |     | }
 316 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IFtsoRewardOffersManager.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * FtsoRewardOffersManager interface.
  6 |     |  */
  7 |     | interface IFtsoRewardOffersManager {
  8 |     |     /**
  9 |     |      * Defines a reward offer.
 10 |     |      */
 11 |     |     struct Offer {
 12 |     |         // amount (in wei) of reward in native coin
 13 |     |         uint120 amount;
 14 |     |         // feed id - i.e. category + base/quote symbol
 15 |     |         bytes21 feedId;
 16 |     |         // minimal reward eligibility turnout threshold in BIPS (basis points)
 17 |     |         uint16 minRewardedTurnoutBIPS;
 18 |     |         // primary band reward share in PPM (parts per million)
 19 |     |         uint24 primaryBandRewardSharePPM;
 20 |     |         // secondary band width in PPM (parts per million) in relation to the median
 21 |     |         uint24 secondaryBandWidthPPM;
 22 |     |         // address that can claim undistributed part of the reward (or burn address)
 23 |     |         address claimBackAddress;
 24 |     |     }
 25 |     | 
 26 |     |     /// Event emitted when the minimal rewards offer value is set.
 27 |     |     event MinimalRewardsOfferValueSet(uint256 valueWei);
 28 |     | 
 29 |     |     /// Event emitted when a reward offer is received.
 30 |     |     event RewardsOffered(
 31 |     |         // reward epoch id
 32 |     |         uint24 indexed rewardEpochId,
 33 |     |         // feed id - i.e. category + base/quote symbol
 34 |     |         bytes21 feedId,
 35 |     |         // number of decimals (negative exponent)
 36 |     |         int8 decimals,
 37 |     |         // amount (in wei) of reward in native coin
 38 |     |         uint256 amount,
 39 |     |         // minimal reward eligibility turnout threshold in BIPS (basis points)
 40 |     |         uint16 minRewardedTurnoutBIPS,
 41 |     |         // primary band reward share in PPM (parts per million)
 42 |     |         uint24 primaryBandRewardSharePPM,
 43 |     |         // secondary band width in PPM (parts per million) in relation to the median
 44 |     |         uint24 secondaryBandWidthPPM,
 45 |     |         // address that can claim undistributed part of the reward (or burn address)
 46 |     |         address claimBackAddress
 47 |     |     );
 48 |     | 
 49 |     |     /// Event emitted when inflation rewards are offered.
 50 |     |     event InflationRewardsOffered(
 51 |     |         // reward epoch id
 52 |     |         uint24 indexed rewardEpochId,
 53 |     |         // feed ids - i.e. category + base/quote symbols - multiple of 21 (one feedId is bytes21)
 54 |     |         bytes feedIds,
 55 |     |         // decimals encoded to - multiple of 1 (int8)
 56 |     |         bytes decimals,
 57 |     |         // amount (in wei) of reward in native coin
 58 |     |         uint256 amount,
 59 |     |         // minimal reward eligibility turnout threshold in BIPS (basis points)
 60 |     |         uint16 minRewardedTurnoutBIPS,
 61 |     |         // primary band reward share in PPM (parts per million)
 62 |     |         uint24 primaryBandRewardSharePPM,
 63 |     |         // secondary band width in PPM (parts per million) in relation to the median - multiple of 3 (uint24)
 64 |     |         bytes secondaryBandWidthPPMs,
 65 |     |         // rewards split mode (0 means equally, 1 means random,...)
 66 |     |         uint16 mode
 67 |     |     );
 68 |     | 
 69 |     |     /**
 70 |     |      * Allows community to offer rewards.
 71 |     |      * @param _nextRewardEpochId The next reward epoch id.
 72 |     |      * @param _offers The list of offers.
 73 |     |      */
 74 |     |     function offerRewards(
 75 |     |         uint24 _nextRewardEpochId,
 76 |     |         Offer[] calldata _offers
 77 |     |     ) external payable;
 78 |     | 
 79 |     |     /**
 80 |     |      * Minimal rewards offer value (in wei).
 81 |     |      */
 82 |     |     function minimalRewardsOfferValueWei() external view returns (uint256);
 83 |     | }
 84 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IGenericRewardManager.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | interface IGenericRewardManager {
  5 |     |     event RewardClaimed(
  6 |     |         address indexed beneficiary,
  7 |     |         address indexed sentTo,
  8 |     |         uint256 amount
  9 |     |     );
 10 |     | 
 11 |     |     event RewardsDistributed(address[] addresses, uint256[] rewards);
 12 |     | 
 13 |     |     event ClaimExecutorsChanged(address rewardOwner, address[] executors);
 14 |     | 
 15 |     |     event AllowedClaimRecipientsChanged(
 16 |     |         address rewardOwner,
 17 |     |         address[] recipients
 18 |     |     );
 19 |     | 
 20 |     |     event RewardManagerActivated(address rewardManager);
 21 |     |     event RewardManagerDeactivated(address rewardManager);
 22 |     | 
 23 |     |     /**
 24 |     |      * @notice Allows the sender to claim or wrap rewards for reward owner.
 25 |     |      * @notice The caller does not have to be the owner, but must be approved by the owner to claim on his behalf.
 26 |     |      *   this approval is done by calling `setClaimExecutors`.
 27 |     |      * @notice It is actually safe for this to be called by anybody (nothing can be stolen), but by limiting who can
 28 |     |      *   call, we allow the owner to control the timing of the calls.
 29 |     |      * @notice Reward owner can claim to any `_recipient`, while the executor can only claim to the reward owner or
 30 |     |      *   one of the addresses set by `setAllowedClaimRecipients`.
 31 |     |      * @param _rewardOwner          address of the reward owner
 32 |     |      * @param _recipient            address to transfer funds to
 33 |     |      * @param _rewardAmount         amount of rewards to claim
 34 |     |      * @param _wrap                 should reward be wrapped immediately
 35 |     |      */
 36 |     |     function claim(
 37 |     |         address _rewardOwner,
 38 |     |         address payable _recipient,
 39 |     |         uint256 _rewardAmount,
 40 |     |         bool _wrap
 41 |     |     ) external;
 42 |     | 
 43 |     |     /**
 44 |     |      * Set the addresses of executors, who are allowed to call `claim`.
 45 |     |      * @param _executors The new executors. All old executors will be deleted and replaced by these.
 46 |     |      */
 47 |     |     function setClaimExecutors(address[] memory _executors) external;
 48 |     | 
 49 |     |     /**
 50 |     |      * Set the addresses of allowed recipients in the methods `claim`.
 51 |     |      * Apart from these, the reward owner is always an allowed recipient.
 52 |     |      * @param _recipients The new allowed recipients. All old recipients will be deleted and replaced by these.
 53 |     |      */
 54 |     |     function setAllowedClaimRecipients(address[] memory _recipients) external;
 55 |     | 
 56 |     |     /**
 57 |     |      * @notice Allows reward claiming
 58 |     |      */
 59 |     |     function active() external view returns (bool);
 60 |     | 
 61 |     |     /**
 62 |     |      * @notice Returns information of beneficiary rewards
 63 |     |      * @param _beneficiary          beneficiary address
 64 |     |      * @return _totalReward         number representing the total reward
 65 |     |      * @return _claimedReward       number representing the amount of total reward that has been claimed
 66 |     |      */
 67 |     |     function getStateOfRewards(
 68 |     |         address _beneficiary
 69 |     |     ) external view returns (uint256 _totalReward, uint256 _claimedReward);
 70 |     | 
 71 |     |     /**
 72 |     |      * Get the addresses of executors, who are allowed to call `claim`.
 73 |     |      */
 74 |     |     function claimExecutors(
 75 |     |         address _rewardOwner
 76 |     |     ) external view returns (address[] memory);
 77 |     | 
 78 |     |     /**
 79 |     |      * Get the addresses of allowed recipients in the methods `claim`.
 80 |     |      * Apart from these, the reward owner is always an allowed recipient.
 81 |     |      */
 82 |     |     function allowedClaimRecipients(
 83 |     |         address _rewardOwner
 84 |     |     ) external view returns (address[] memory);
 85 |     | }
 86 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IGovernanceSettings.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * A special contract that holds Flare governance address.
  6 |     |  * This contract enables updating governance address and timelock only by hard forking the network,
  7 |     |  * meaning only by updating validator code.
  8 |     |  */
  9 |     | interface IGovernanceSettings {
 10 |     |     /**
 11 |     |      * Get the governance account address.
 12 |     |      * The governance address can only be changed by a hardfork.
 13 |     |      */
 14 |     |     function getGovernanceAddress() external view returns (address);
 15 |     | 
 16 |     |     /**
 17 |     |      * Get the time in seconds that must pass between a governance call and execution.
 18 |     |      * The timelock value can only be changed by a hardfork.
 19 |     |      */
 20 |     |     function getTimelock() external view returns (uint256);
 21 |     | 
 22 |     |     /**
 23 |     |      * Get the addresses of the accounts that are allowed to execute the timelocked governance calls
 24 |     |      * once the timelock period expires.
 25 |     |      * Executors can be changed without a hardfork, via a normal governance call.
 26 |     |      */
 27 |     |     function getExecutors() external view returns (address[] memory);
 28 |     | 
 29 |     |     /**
 30 |     |      * Check whether an address is one of the executors.
 31 |     |      */
 32 |     |     function isExecutor(address _address) external view returns (bool);
 33 |     | }
 34 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IGovernanceVotePower.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * Interface for contracts delegating their governance vote power.
  6 |     |  */
  7 |     | interface IGovernanceVotePower {
  8 |     |     /**
  9 |     |      * Delegates all governance vote power of `msg.sender` to address `_to`.
 10 |     |      * @param _to The address of the recipient.
 11 |     |      */
 12 |     |     function delegate(address _to) external;
 13 |     | 
 14 |     |     /**
 15 |     |      * Undelegates all governance vote power of `msg.sender`.
 16 |     |      */
 17 |     |     function undelegate() external;
 18 |     | 
 19 |     |     /**
 20 |     |      * Gets the governance vote power of an address at a given block number, including
 21 |     |      * all delegations made to it.
 22 |     |      * @param _who The address being queried.
 23 |     |      * @param _blockNumber The block number at which to fetch the vote power.
 24 |     |      * @return Governance vote power of `_who` at `_blockNumber`.
 25 |     |      */
 26 |     |     function votePowerOfAt(
 27 |     |         address _who,
 28 |     |         uint256 _blockNumber
 29 |     |     ) external view returns (uint256);
 30 |     | 
 31 |     |     /**
 32 |     |      * Gets the governance vote power of an address at the latest block, including
 33 |     |      * all delegations made to it.
 34 |     |      * @param _who The address being queried.
 35 |     |      * @return Governance vote power of `account` at the lastest block.
 36 |     |      */
 37 |     |     function getVotes(address _who) external view returns (uint256);
 38 |     | 
 39 |     |     /**
 40 |     |      * Gets the address an account is delegating its governance vote power to, at a given block number.
 41 |     |      * @param _who The address being queried.
 42 |     |      * @param _blockNumber The block number at which to fetch the address.
 43 |     |      * @return Address where `_who` was delegating its governance vote power at block `_blockNumber`.
 44 |     |      */
 45 |     |     function getDelegateOfAt(
 46 |     |         address _who,
 47 |     |         uint256 _blockNumber
 48 |     |     ) external view returns (address);
 49 |     | 
 50 |     |     /**
 51 |     |      * Gets the address an account is delegating its governance vote power to, at the latest block number.
 52 |     |      * @param _who The address being queried.
 53 |     |      * @return Address where `_who` is currently delegating its governance vote power.
 54 |     |      */
 55 |     |     function getDelegateOfAtNow(address _who) external view returns (address);
 56 |     | }
 57 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IIncreaseManager.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * Increase manager interface.
  6 |     |  */
  7 |     | interface IIncreaseManager {
  8 |     |     function getIncentiveDuration() external view returns (uint256);
  9 |     | }
 10 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IJsonApi.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * @custom:name IJsonApi
  6 |     |  * @custom:supported WEB2
  7 |     |  * @author Flare
  8 |     |  * @notice An attestation request that fetches data from the given url and then edits the information with a
  9 |     |  * jq transformation.
 10 |     |  * @custom:verification  Data is fetched from an url `url`. The received data is then processed with jq as
 11 |     |  * the `postprocessJq` states. The structure of the final json is written in the `abi_signature`.
 12 |     |  *
 13 |     |  * The response contains an abi encoding of the final data.
 14 |     |  * @custom:lut `0xffffffffffffffff`
 15 |     |  * @custom:lut-limit `0xffffffffffffffff`
 16 |     |  */
 17 |     | interface IJsonApi {
 18 |     |     /**
 19 |     |      * @notice Toplevel request
 20 |     |      * @param attestationType ID of the attestation type.
 21 |     |      * @param sourceId ID of the data source.
 22 |     |      * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.
 23 |     |      * @param requestBody Data defining the request. Type (struct) and interpretation is determined
 24 |     |      * by the `attestationType`.
 25 |     |      */
 26 |     |     struct Request {
 27 |     |         bytes32 attestationType;
 28 |     |         bytes32 sourceId;
 29 |     |         bytes32 messageIntegrityCode;
 30 |     |         RequestBody requestBody;
 31 |     |     }
 32 |     | 
 33 |     |     /**
 34 |     |      * @notice Toplevel response
 35 |     |      * @param attestationType Extracted from the request.
 36 |     |      * @param sourceId Extracted from the request.
 37 |     |      * @param votingRound The ID of the State Connector round in which the request was considered.
 38 |     |      * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
 39 |     |      * @param requestBody Extracted from the request.
 40 |     |      * @param responseBody Data defining the response. The verification rules for the construction
 41 |     |      * of the response body and the type are defined per specific `attestationType`.
 42 |     |      */
 43 |     |     struct Response {
 44 |     |         bytes32 attestationType;
 45 |     |         bytes32 sourceId;
 46 |     |         uint64 votingRound;
 47 |     |         uint64 lowestUsedTimestamp;
 48 |     |         RequestBody requestBody;
 49 |     |         ResponseBody responseBody;
 50 |     |     }
 51 |     | 
 52 |     |     /**
 53 |     |      * @notice Toplevel proof
 54 |     |      * @param merkleProof Merkle proof corresponding to the attestation response.
 55 |     |      * @param data Attestation response.
 56 |     |      */
 57 |     |     struct Proof {
 58 |     |         bytes32[] merkleProof;
 59 |     |         Response data;
 60 |     |     }
 61 |     | 
 62 |     |     /**
 63 |     |      * @notice Request body for Payment attestation type
 64 |     |      * @param url URL of the data source
 65 |     |      * @param postprocessJq jq filter to postprocess the data
 66 |     |      * @param abi_signature ABI signature of the data
 67 |     |      */
 68 |     |     struct RequestBody {
 69 |     |         string url;
 70 |     |         string postprocessJq;
 71 |     |         string abi_signature;
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @notice Response body for Payment attestation type
 76 |     |      * @param abi_encoded_data ABI encoded data
 77 |     |      */
 78 |     |     struct ResponseBody {
 79 |     |         bytes abi_encoded_data;
 80 |     |     }
 81 |     | }
 82 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IJsonApiVerification.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "./IJsonApi.sol";
  5 |     | 
  6 |     | interface IJsonApiVerification {
  7 |     |     function verifyJsonApi(
  8 |     |         IJsonApi.Proof calldata _proof
  9 |     |     ) external view returns (bool _proved);
 10 |     | }
 11 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IPChainStakeMirror.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | pragma abicoder v2;
   4 |     | 
   5 |     | import "./IPChainVotePower.sol";
   6 |     | import "./IPChainStakeMirrorVerifier.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * Interface for the `PChainStakeMirror` contract.
  10 |     |  */
  11 |     | interface IPChainStakeMirror is IPChainVotePower {
  12 |     |     /**
  13 |     |      * Event emitted when max updates per block is set.
  14 |     |      * @param maxUpdatesPerBlock new number of max updated per block
  15 |     |      */
  16 |     |     event MaxUpdatesPerBlockSet(uint256 maxUpdatesPerBlock);
  17 |     | 
  18 |     |     /**
  19 |     |      * Event emitted when the stake is confirmed.
  20 |     |      * @param owner The address who opened the stake.
  21 |     |      * @param nodeId Node id to which the stake was added.
  22 |     |      * @param txHash Unique tx hash - keccak256(abi.encode(PChainStake.txId, PChainStake.inputAddress));
  23 |     |      * @param amountWei Stake amount (in wei).
  24 |     |      * @param pChainTxId P-chain transaction id.
  25 |     |      */
  26 |     |     event StakeConfirmed(
  27 |     |         address indexed owner,
  28 |     |         bytes20 indexed nodeId,
  29 |     |         bytes32 indexed txHash,
  30 |     |         uint256 amountWei,
  31 |     |         bytes32 pChainTxId
  32 |     |     );
  33 |     | 
  34 |     |     /**
  35 |     |      * Event emitted when the stake has ended.
  36 |     |      * @param owner The address whose stake has ended.
  37 |     |      * @param nodeId Node id from which the stake was removed.
  38 |     |      * @param txHash Unique tx hash - keccak256(abi.encode(PChainStake.txId, PChainStake.inputAddress));
  39 |     |      * @param amountWei Stake amount (in wei).
  40 |     |      */
  41 |     |     event StakeEnded(
  42 |     |         address indexed owner,
  43 |     |         bytes20 indexed nodeId,
  44 |     |         bytes32 indexed txHash,
  45 |     |         uint256 amountWei
  46 |     |     );
  47 |     | 
  48 |     |     /**
  49 |     |      * Event emitted when the stake was revoked.
  50 |     |      * @param owner The address whose stake has ended.
  51 |     |      * @param nodeId Node id from which the stake was removed.
  52 |     |      * @param txHash Unique tx hash - keccak256(abi.encode(PChainStake.txId, PChainStake.inputAddress));
  53 |     |      * @param amountWei Stake amount (in wei).
  54 |     |      */
  55 |     |     event StakeRevoked(
  56 |     |         address indexed owner,
  57 |     |         bytes20 indexed nodeId,
  58 |     |         bytes32 indexed txHash,
  59 |     |         uint256 amountWei
  60 |     |     );
  61 |     | 
  62 |     |     /**
  63 |     |      * Method for P-chain stake mirroring using `PChainStake` data and Merkle proof.
  64 |     |      * @param _stakeData Information about P-chain stake.
  65 |     |      * @param _merkleProof Merkle proof that should be used to prove the P-chain stake.
  66 |     |      */
  67 |     |     function mirrorStake(
  68 |     |         IPChainStakeMirrorVerifier.PChainStake calldata _stakeData,
  69 |     |         bytes32[] calldata _merkleProof
  70 |     |     ) external;
  71 |     | 
  72 |     |     /**
  73 |     |      * Method for checking if active stake (stake start time <= block.timestamp < stake end time) was already mirrored.
  74 |     |      * @param _txId P-chain stake transaction id.
  75 |     |      * @param _inputAddress P-chain address that opened stake.
  76 |     |      * @return True if stake is active and mirrored.
  77 |     |      */
  78 |     |     function isActiveStakeMirrored(
  79 |     |         bytes32 _txId,
  80 |     |         bytes20 _inputAddress
  81 |     |     ) external view returns (bool);
  82 |     | 
  83 |     |     /**
  84 |     |      * Total amount of tokens at current block.
  85 |     |      * @return The current total amount of tokens.
  86 |     |      **/
  87 |     |     function totalSupply() external view returns (uint256);
  88 |     | 
  89 |     |     /**
  90 |     |      * Total amount of tokens at a specific `_blockNumber`.
  91 |     |      * @param _blockNumber The block number when the totalSupply is queried.
  92 |     |      * @return The total amount of tokens at `_blockNumber`.
  93 |     |      **/
  94 |     |     function totalSupplyAt(uint _blockNumber) external view returns (uint256);
  95 |     | 
  96 |     |     /**
  97 |     |      * Queries the token balance of `_owner` at current block.
  98 |     |      * @param _owner The address from which the balance will be retrieved.
  99 |     |      * @return The current balance.
 100 |     |      **/
 101 |     |     function balanceOf(address _owner) external view returns (uint256);
 102 |     | 
 103 |     |     /**
 104 |     |      * Queries the token balance of `_owner` at a specific `_blockNumber`.
 105 |     |      * @param _owner The address from which the balance will be retrieved.
 106 |     |      * @param _blockNumber The block number when the balance is queried.
 107 |     |      * @return The balance at `_blockNumber`.
 108 |     |      **/
 109 |     |     function balanceOfAt(
 110 |     |         address _owner,
 111 |     |         uint _blockNumber
 112 |     |     ) external view returns (uint256);
 113 |     | }
 114 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IPChainStakeMirrorVerifier.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | /**
  6 |     |  * Interface with structure for P-chain stake mirror verifications.
  7 |     |  */
  8 |     | interface IPChainStakeMirrorVerifier {
  9 |     |     /**
 10 |     |      * Structure describing the P-chain stake.
 11 |     |      */
 12 |     |     struct PChainStake {
 13 |     |         // Hash of the transaction on the underlying chain.
 14 |     |         bytes32 txId;
 15 |     |         // Type of the staking/delegation transaction: '0' for 'ADD_VALIDATOR_TX' and '1' for 'ADD_DELEGATOR_TX'.
 16 |     |         uint8 stakingType;
 17 |     |         // Input address that triggered the staking or delegation transaction.
 18 |     |         // See https://support.avax.network/en/articles/4596397-what-is-an-address for address definition for P-chain.
 19 |     |         bytes20 inputAddress;
 20 |     |         // NodeID to which staking or delegation is done.
 21 |     |         // For definitions, see https://github.com/ava-labs/avalanchego/blob/master/ids/node_id.go.
 22 |     |         bytes20 nodeId;
 23 |     |         // Start time of the staking/delegation in seconds (Unix epoch).
 24 |     |         uint64 startTime;
 25 |     |         // End time of the staking/delegation in seconds (Unix epoch).
 26 |     |         uint64 endTime;
 27 |     |         // Staked or delegated amount in Gwei (nano FLR).
 28 |     |         uint64 weight;
 29 |     |     }
 30 |     | }
 31 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IPChainVotePower.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | /**
   5 |     |  * Interface for the vote power part of the `PChainStakeMirror` contract.
   6 |     |  */
   7 |     | interface IPChainVotePower {
   8 |     |     /**
   9 |     |      * Event triggered when a stake is confirmed or at the time it ends.
  10 |     |      * Definition: `votePowerFromTo(owner, nodeId)` is `changed` from `priorVotePower` to `newVotePower`.
  11 |     |      * @param owner The account that has changed the amount of vote power it is staking.
  12 |     |      * @param nodeId The node id whose received vote power has changed.
  13 |     |      * @param priorVotePower The vote power originally on that node id.
  14 |     |      * @param newVotePower The new vote power that triggered this event.
  15 |     |      */
  16 |     |     event VotePowerChanged(
  17 |     |         address indexed owner,
  18 |     |         bytes20 indexed nodeId,
  19 |     |         uint256 priorVotePower,
  20 |     |         uint256 newVotePower
  21 |     |     );
  22 |     | 
  23 |     |     /**
  24 |     |      * Emitted when a vote power cache entry is created.
  25 |     |      * Allows history cleaners to track vote power cache cleanup opportunities off-chain.
  26 |     |      * @param nodeId The node id whose vote power has just been cached.
  27 |     |      * @param blockNumber The block number at which the vote power has been cached.
  28 |     |      */
  29 |     |     event VotePowerCacheCreated(bytes20 nodeId, uint256 blockNumber);
  30 |     | 
  31 |     |     /**
  32 |     |      * Get the vote power of `_owner` at block `_blockNumber` using cache.
  33 |     |      *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.
  34 |     |      *   Can only be used if _blockNumber is in the past, otherwise reverts.
  35 |     |      * @param _owner The node id to get voting power.
  36 |     |      * @param _blockNumber The block number at which to fetch.
  37 |     |      * @return Vote power of `_owner` at `_blockNumber`.
  38 |     |      */
  39 |     |     function votePowerOfAtCached(
  40 |     |         bytes20 _owner,
  41 |     |         uint256 _blockNumber
  42 |     |     ) external returns (uint256);
  43 |     | 
  44 |     |     /**
  45 |     |      * Get the total vote power at block `_blockNumber` using cache.
  46 |     |      *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.
  47 |     |      *   Can only be used if `_blockNumber` is in the past, otherwise reverts.
  48 |     |      * @param _blockNumber The block number at which to fetch.
  49 |     |      * @return The total vote power at the block (sum of all accounts' vote powers).
  50 |     |      */
  51 |     |     function totalVotePowerAtCached(
  52 |     |         uint256 _blockNumber
  53 |     |     ) external returns (uint256);
  54 |     | 
  55 |     |     /**
  56 |     |      * Get the current total vote power.
  57 |     |      * @return The current total vote power (sum of all accounts' vote powers).
  58 |     |      */
  59 |     |     function totalVotePower() external view returns (uint256);
  60 |     | 
  61 |     |     /**
  62 |     |      * Get the total vote power at block `_blockNumber`
  63 |     |      * @param _blockNumber The block number at which to fetch.
  64 |     |      * @return The total vote power at the block  (sum of all accounts' vote powers).
  65 |     |      */
  66 |     |     function totalVotePowerAt(
  67 |     |         uint _blockNumber
  68 |     |     ) external view returns (uint256);
  69 |     | 
  70 |     |     /**
  71 |     |      * Get the amounts and node ids being staked to by a vote power owner.
  72 |     |      * @param _owner The address being queried.
  73 |     |      * @return _nodeIds Array of node ids.
  74 |     |      * @return _amounts Array of staked amounts, for each node id.
  75 |     |      */
  76 |     |     function stakesOf(
  77 |     |         address _owner
  78 |     |     )
  79 |     |         external
  80 |     |         view
  81 |     |         returns (bytes20[] memory _nodeIds, uint256[] memory _amounts);
  82 |     | 
  83 |     |     /**
  84 |     |      * Get the amounts and node ids being staked to by a vote power owner,
  85 |     |      * at a given block.
  86 |     |      * @param _owner The address being queried.
  87 |     |      * @param _blockNumber The block number being queried.
  88 |     |      * @return _nodeIds Array of node ids.
  89 |     |      * @return _amounts Array of staked amounts, for each node id.
  90 |     |      */
  91 |     |     function stakesOfAt(
  92 |     |         address _owner,
  93 |     |         uint256 _blockNumber
  94 |     |     )
  95 |     |         external
  96 |     |         view
  97 |     |         returns (bytes20[] memory _nodeIds, uint256[] memory _amounts);
  98 |     | 
  99 |     |     /**
 100 |     |      * Get the current vote power of `_nodeId`.
 101 |     |      * @param _nodeId The node id to get voting power.
 102 |     |      * @return Current vote power of `_nodeId`.
 103 |     |      */
 104 |     |     function votePowerOf(bytes20 _nodeId) external view returns (uint256);
 105 |     | 
 106 |     |     /**
 107 |     |      * Get the vote power of `_nodeId` at block `_blockNumber`
 108 |     |      * @param _nodeId The node id to get voting power.
 109 |     |      * @param _blockNumber The block number at which to fetch.
 110 |     |      * @return Vote power of `_nodeId` at `_blockNumber`.
 111 |     |      */
 112 |     |     function votePowerOfAt(
 113 |     |         bytes20 _nodeId,
 114 |     |         uint256 _blockNumber
 115 |     |     ) external view returns (uint256);
 116 |     | 
 117 |     |     /**
 118 |     |      * Get current staked vote power from `_owner` staked to `_nodeId`.
 119 |     |      * @param _owner Address of vote power owner.
 120 |     |      * @param _nodeId Node id.
 121 |     |      * @return The staked vote power.
 122 |     |      */
 123 |     |     function votePowerFromTo(
 124 |     |         address _owner,
 125 |     |         bytes20 _nodeId
 126 |     |     ) external view returns (uint256);
 127 |     | 
 128 |     |     /**
 129 |     |      * Get current staked vote power from `_owner` staked to `_nodeId` at `_blockNumber`.
 130 |     |      * @param _owner Address of vote power owner.
 131 |     |      * @param _nodeId Node id.
 132 |     |      * @param _blockNumber The block number at which to fetch.
 133 |     |      * @return The staked vote power.
 134 |     |      */
 135 |     |     function votePowerFromToAt(
 136 |     |         address _owner,
 137 |     |         bytes20 _nodeId,
 138 |     |         uint _blockNumber
 139 |     |     ) external view returns (uint256);
 140 |     | 
 141 |     |     /**
 142 |     |      * Return vote powers for several node ids in a batch.
 143 |     |      * @param _nodeIds The list of node ids to fetch vote power of.
 144 |     |      * @param _blockNumber The block number at which to fetch.
 145 |     |      * @return A list of vote powers.
 146 |     |      */
 147 |     |     function batchVotePowerOfAt(
 148 |     |         bytes20[] memory _nodeIds,
 149 |     |         uint256 _blockNumber
 150 |     |     ) external view returns (uint256[] memory);
 151 |     | }
 152 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IPayment.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | /**
   5 |     |  * @custom:name IPayment
   6 |     |  * @custom:id 0x01
   7 |     |  * @custom:supported BTC, DOGE, XRP
   8 |     |  * @author Flare
   9 |     |  * @notice A relay of a transaction on an external chain that is considered a payment in a native currency.
  10 |     |  * Various blockchains support different types of native payments. For each blockchain, it is specified how a payment
  11 |     |  * transaction should be formed to be provable by this attestation type.
  12 |     |  * The provable payments emulate traditional banking payments from entity A to entity B in native currency with an
  13 |     |  * optional payment reference.
  14 |     |  * @custom:verification The transaction with `transactionId` is fetched from the API of the blockchain node or
  15 |     |  * relevant indexer.
  16 |     |  * If the transaction cannot be fetched or the transaction is in a block that does not have a sufficient
  17 |     |  * [number of confirmations](/specs/attestations/configs.md#finalityconfirmation), the attestation request is rejected.
  18 |     |  *
  19 |     |  * Once the transaction is received, the payment summary is computed according to the rules for the source chain.
  20 |     |  * If the summary is successfully calculated, the response is assembled from the summary.
  21 |     |  * `blockNumber` and `blockTimestamp` are retrieved from the block if they are not included in the transaction data.
  22 |     |  * For Bitcoin and Dogecoin, `blockTimestamp` is mediantime of the block.
  23 |     |  * For XRPL, `blockTimestamp` is close time of the ledger converted to UNIX time.
  24 |     |  *
  25 |     |  * If the summary is not successfully calculated, the attestation request is rejected.
  26 |     |  * @custom:lut `blockTimestamp`
  27 |     |  * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`
  28 |     |  */
  29 |     | interface IPayment {
  30 |     |     /**
  31 |     |      * @notice Toplevel request
  32 |     |      * @param attestationType ID of the attestation type.
  33 |     |      * @param sourceId ID of the data source.
  34 |     |      * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.
  35 |     |      * @param requestBody Data defining the request. Type (struct) and interpretation is determined
  36 |     |      * by the `attestationType`.
  37 |     |      */
  38 |     |     struct Request {
  39 |     |         bytes32 attestationType;
  40 |     |         bytes32 sourceId;
  41 |     |         bytes32 messageIntegrityCode;
  42 |     |         RequestBody requestBody;
  43 |     |     }
  44 |     | 
  45 |     |     /**
  46 |     |      * @notice Toplevel response
  47 |     |      * @param attestationType Extracted from the request.
  48 |     |      * @param sourceId Extracted from the request.
  49 |     |      * @param votingRound The ID of the State Connector round in which the request was considered.
  50 |     |      * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
  51 |     |      * @param requestBody Extracted from the request.
  52 |     |      * @param responseBody Data defining the response. The verification rules for the construction
  53 |     |      * of the response body and the type are defined per specific `attestationType`.
  54 |     |      */
  55 |     |     struct Response {
  56 |     |         bytes32 attestationType;
  57 |     |         bytes32 sourceId;
  58 |     |         uint64 votingRound;
  59 |     |         uint64 lowestUsedTimestamp;
  60 |     |         RequestBody requestBody;
  61 |     |         ResponseBody responseBody;
  62 |     |     }
  63 |     | 
  64 |     |     /**
  65 |     |      * @notice Toplevel proof
  66 |     |      * @param merkleProof Merkle proof corresponding to the attestation response.
  67 |     |      * @param data Attestation response.
  68 |     |      */
  69 |     |     struct Proof {
  70 |     |         bytes32[] merkleProof;
  71 |     |         Response data;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @notice Request body for Payment attestation type
  76 |     |      * @param transactionId ID of the payment transaction.
  77 |     |      * @param inUtxo For UTXO chains, this is the index of the transaction input with source address.
  78 |     |      * Always 0 for the non-utxo chains.
  79 |     |      * @param utxo For UTXO chains, this is the index of the transaction output with receiving address.
  80 |     |      * Always 0 for the non-utxo chains.
  81 |     |      */
  82 |     |     struct RequestBody {
  83 |     |         bytes32 transactionId;
  84 |     |         uint256 inUtxo;
  85 |     |         uint256 utxo;
  86 |     |     }
  87 |     | 
  88 |     |     /**
  89 |     |      * @notice Response body for Payment attestation type
  90 |     |      * @param blockNumber Number of the block in which the transaction is included.
  91 |     |      * @param blockTimestamp The timestamp of the block in which the transaction is included.
  92 |     |      * @param sourceAddressHash Standard address hash of the source address.
  93 |     |      * @param sourceAddressesRoot The root of the Merkle tree of the source addresses.
  94 |     |      * @param receivingAddressHash Standard address hash of the receiving address.
  95 |     |      * The zero 32-byte string if there is no receivingAddress (if `status` is not success).
  96 |     |      * @param intendedReceivingAddressHash Standard address hash of the intended receiving address.
  97 |     |      * Relevant if the transaction is unsuccessful.
  98 |     |      * @param spentAmount Amount in minimal units spent by the source address.
  99 |     |      * @param intendedSpentAmount Amount in minimal units to be spent by the source address.
 100 |     |      * Relevant if the transaction status is unsuccessful.
 101 |     |      * @param receivedAmount Amount in minimal units received by the receiving address.
 102 |     |      * @param intendedReceivedAmount Amount in minimal units intended to be received by the receiving address.
 103 |     |      * Relevant if the transaction is unsuccessful.
 104 |     |      * @param standardPaymentReference Standard payment reference of the transaction.
 105 |     |      * @param oneToOne Indicator whether only one source and one receiver are involved in the transaction.
 106 |     |      * @param status Succes status of the transaction: 0 - success, 1 - failed by sender's fault,
 107 |     |      * 2 - failed by receiver's fault.
 108 |     |      */
 109 |     |     struct ResponseBody {
 110 |     |         uint64 blockNumber;
 111 |     |         uint64 blockTimestamp;
 112 |     |         bytes32 sourceAddressHash;
 113 |     |         bytes32 sourceAddressesRoot;
 114 |     |         bytes32 receivingAddressHash;
 115 |     |         bytes32 intendedReceivingAddressHash;
 116 |     |         int256 spentAmount;
 117 |     |         int256 intendedSpentAmount;
 118 |     |         int256 receivedAmount;
 119 |     |         int256 intendedReceivedAmount;
 120 |     |         bytes32 standardPaymentReference;
 121 |     |         bool oneToOne;
 122 |     |         uint8 status;
 123 |     |     }
 124 |     | }
 125 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IPaymentVerification.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "./IPayment.sol";
  5 |     | 
  6 |     | interface IPaymentVerification {
  7 |     |     function verifyPayment(
  8 |     |         IPayment.Proof calldata _proof
  9 |     |     ) external view returns (bool _proved);
 10 |     | }
 11 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IPriceSubmitter.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "./genesis/interfaces/IFtsoGenesis.sol";
  5 |     | import "./genesis/interfaces/IFtsoRegistryGenesis.sol";
  6 |     | import "./genesis/interfaces/IFtsoManagerGenesis.sol";
  7 |     | 
  8 |     | interface IPriceSubmitter {
  9 |     |     /**
 10 |     |      * Event emitted when hash was submitted through PriceSubmitter.
 11 |     |      * @param submitter the address of the sender
 12 |     |      * @param epochId current price epoch id
 13 |     |      * @param hash the submitted hash
 14 |     |      * @param timestamp current block timestamp
 15 |     |      */
 16 |     |     event HashSubmitted(
 17 |     |         address indexed submitter,
 18 |     |         uint256 indexed epochId,
 19 |     |         bytes32 hash,
 20 |     |         uint256 timestamp
 21 |     |     );
 22 |     | 
 23 |     |     /**
 24 |     |      * Event emitted when prices were revealed through PriceSubmitter.
 25 |     |      * @param voter the address of the sender
 26 |     |      * @param epochId id of the epoch in which the price hash was submitted
 27 |     |      * @param ftsos array of ftsos that correspond to the indexes in the call
 28 |     |      * @param prices the submitted prices
 29 |     |      * @param timestamp current block timestamp
 30 |     |      */
 31 |     |     event PricesRevealed(
 32 |     |         address indexed voter,
 33 |     |         uint256 indexed epochId,
 34 |     |         IFtsoGenesis[] ftsos,
 35 |     |         uint256[] prices,
 36 |     |         uint256 random,
 37 |     |         uint256 timestamp
 38 |     |     );
 39 |     | 
 40 |     |     /**
 41 |     |      * @notice Submits hash for current epoch
 42 |     |      * @param _epochId              Target epoch id to which hash is submitted
 43 |     |      * @param _hash                 Hash of ftso indices, prices, random number and voter address
 44 |     |      * @notice Emits HashSubmitted event
 45 |     |      */
 46 |     |     function submitHash(uint256 _epochId, bytes32 _hash) external;
 47 |     | 
 48 |     |     /**
 49 |     |      * @notice Reveals submitted prices during epoch reveal period
 50 |     |      * @param _epochId              Id of the epoch in which the price hashes was submitted
 51 |     |      * @param _ftsoIndices          List of increasing ftso indices
 52 |     |      * @param _prices               List of submitted prices in USD
 53 |     |      * @param _random               Submitted random number
 54 |     |      * @notice The hash of ftso indices, prices, random number and voter address must be equal to the submitted hash
 55 |     |      * @notice Emits PricesRevealed event
 56 |     |      */
 57 |     |     function revealPrices(
 58 |     |         uint256 _epochId,
 59 |     |         uint256[] memory _ftsoIndices,
 60 |     |         uint256[] memory _prices,
 61 |     |         uint256 _random
 62 |     |     ) external;
 63 |     | 
 64 |     |     /**
 65 |     |      * Returns bitmap of all ftso's for which `_voter` is allowed to submit prices/hashes.
 66 |     |      * If voter is allowed to vote for ftso at index (see *_FTSO_INDEX), the corrsponding
 67 |     |      * bit in the result will be 1.
 68 |     |      */
 69 |     |     function voterWhitelistBitmap(
 70 |     |         address _voter
 71 |     |     ) external view returns (uint256);
 72 |     | 
 73 |     |     function getVoterWhitelister() external view returns (address);
 74 |     |     function getFtsoRegistry() external view returns (IFtsoRegistryGenesis);
 75 |     |     function getFtsoManager() external view returns (IFtsoManagerGenesis);
 76 |     | 
 77 |     |     /**
 78 |     |      * @notice Returns current random number
 79 |     |      */
 80 |     |     function getCurrentRandom() external view returns (uint256);
 81 |     | 
 82 |     |     /**
 83 |     |      * @notice Returns random number of the specified epoch
 84 |     |      * @param _epochId              Id of the epoch
 85 |     |      */
 86 |     |     function getRandom(uint256 _epochId) external view returns (uint256);
 87 |     | }
 88 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IRandomProvider.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * Random provider interface.
  6 |     |  */
  7 |     | interface IRandomProvider {
  8 |     |     /**
  9 |     |      * Returns current random number. Method reverts if random number was not generated securely.
 10 |     |      * @return _randomNumber Current random number.
 11 |     |      */
 12 |     |     function getCurrentRandom() external view returns (uint256 _randomNumber);
 13 |     | 
 14 |     |     /**
 15 |     |      * Returns current random number and a flag indicating if it was securely generated.
 16 |     |      * It is up to the caller to decide whether to use the returned random number or not.
 17 |     |      * @return _randomNumber Current random number.
 18 |     |      * @return _isSecureRandom Indicates if current random number is secure.
 19 |     |      */
 20 |     |     function getCurrentRandomWithQuality()
 21 |     |         external
 22 |     |         view
 23 |     |         returns (uint256 _randomNumber, bool _isSecureRandom);
 24 |     | 
 25 |     |     /**
 26 |     |      * Returns current random number, a flag indicating if it was securely generated and its timestamp.
 27 |     |      * It is up to the caller to decide whether to use the returned random number or not.
 28 |     |      * @return _randomNumber Current random number.
 29 |     |      * @return _isSecureRandom Indicates if current random number is secure.
 30 |     |      * @return _randomTimestamp Random timestamp.
 31 |     |      */
 32 |     |     function getCurrentRandomWithQualityAndTimestamp()
 33 |     |         external
 34 |     |         view
 35 |     |         returns (
 36 |     |             uint256 _randomNumber,
 37 |     |             bool _isSecureRandom,
 38 |     |             uint256 _randomTimestamp
 39 |     |         );
 40 |     | }
 41 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IRedemptionTimeExtension.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | interface IRedemptionTimeExtension {
  5 |     |     function setRedemptionPaymentExtensionSeconds(uint256 _value) external;
  6 |     | 
  7 |     |     function redemptionPaymentExtensionSeconds()
  8 |     |         external
  9 |     |         view
 10 |     |         returns (uint256);
 11 |     | }
 12 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IReferencedPaymentNonexistence.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | /**
   5 |     |  * @custom:name IReferencedPaymentNonexistence
   6 |     |  * @custom:id 0x04
   7 |     |  * @custom:supported BTC, DOGE, XRP
   8 |     |  * @author Flare
   9 |     |  * @notice Assertion that an agreed-upon payment has not been made by a certain deadline.
  10 |     |  * A confirmed request shows that a transaction meeting certain criteria (address, amount, reference)
  11 |     |  * did not appear in the specified block range.
  12 |     |  *
  13 |     |  *
  14 |     |  * This type of attestation can be used to e.g. provide grounds to liquidate funds locked by a smart
  15 |     |  * contract on Flare when a payment is missed.
  16 |     |  *
  17 |     |  * @custom:verification If `firstOverflowBlock` cannot be determined or does not have a sufficient
  18 |     |  * number of confirmations, the attestation request is rejected.
  19 |     |  * If `firstOverflowBlockNumber` is higher or equal to `minimalBlockNumber`, the request is rejected.
  20 |     |  * The search range are blocks between heights including `minimalBlockNumber` and excluding `firstOverflowBlockNumber`.
  21 |     |  * If the verifier does not have a view of all blocks from `minimalBlockNumber` to `firstOverflowBlockNumber`,
  22 |     |  * the attestation request is rejected.
  23 |     |  *
  24 |     |  * The request is confirmed if no transaction meeting the specified criteria is found in the search range.
  25 |     |  * The criteria and timestamp are chain specific.
  26 |     |  * ### UTXO (Bitcoin and Dogecoin)
  27 |     |  *
  28 |     |  *
  29 |     |  * Criteria for the transaction:
  30 |     |  *
  31 |     |  *
  32 |     |  * - It is not coinbase transaction.
  33 |     |  * - The transaction has the specified standardPaymentReference.
  34 |     |  * - The sum of values of all outputs with the specified address minus the sum of values of all inputs with
  35 |     |  * the specified address is greater than `amount` (in practice the sum of all values of the inputs with the
  36 |     |  * specified address is zero).
  37 |     |  *
  38 |     |  *
  39 |     |  * Timestamp is `mediantime`.
  40 |     |  * ### XRPL
  41 |     |  *
  42 |     |  *
  43 |     |  *
  44 |     |  * Criteria for the transaction:
  45 |     |  * - The transaction is of type payment.
  46 |     |  * - The transaction has the specified standardPaymentReference,
  47 |     |  * - One of the following is true:
  48 |     |  *   - Transaction status is `SUCCESS` and the amount received by the specified destination address is
  49 |     |  * greater than the specified `value`.
  50 |     |  *   - Transaction status is `RECEIVER_FAILURE` and the specified destination address would receive an
  51 |     |  * amount greater than the specified `value` had the transaction been successful.
  52 |     |  *
  53 |     |  *
  54 |     |  * Timestamp is `close_time` converted to UNIX time.
  55 |     |  *
  56 |     |  * @custom:lut `minimalBlockTimestamp`
  57 |     |  * @custom:lutlimit `0x127500`, `0x127500`, `0x127500`
  58 |     |  */
  59 |     | interface IReferencedPaymentNonexistence {
  60 |     |     /**
  61 |     |      * @notice Toplevel request
  62 |     |      * @param attestationType ID of the attestation type.
  63 |     |      * @param sourceId ID of the data source.
  64 |     |      * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response as defined.
  65 |     |      * @param requestBody Data defining the request. Type and interpretation is determined by the `attestationType`.
  66 |     |      */
  67 |     |     struct Request {
  68 |     |         bytes32 attestationType;
  69 |     |         bytes32 sourceId;
  70 |     |         bytes32 messageIntegrityCode;
  71 |     |         RequestBody requestBody;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @notice Toplevel response
  76 |     |      * @param attestationType Extracted from the request.
  77 |     |      * @param sourceId Extracted from the request.
  78 |     |      * @param votingRound The ID of the State Connector round in which the request was considered.
  79 |     |      * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
  80 |     |      * @param requestBody Extracted from the request.
  81 |     |      * @param responseBody Data defining the response. The verification rules for the construction of the response
  82 |     |      * body and the type are defined per specific `attestationType`.
  83 |     |      */
  84 |     |     struct Response {
  85 |     |         bytes32 attestationType;
  86 |     |         bytes32 sourceId;
  87 |     |         uint64 votingRound;
  88 |     |         uint64 lowestUsedTimestamp;
  89 |     |         RequestBody requestBody;
  90 |     |         ResponseBody responseBody;
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @notice Toplevel proof
  95 |     |      * @param merkleProof Merkle proof corresponding to the attestation response.
  96 |     |      * @param data Attestation response.
  97 |     |      */
  98 |     |     struct Proof {
  99 |     |         bytes32[] merkleProof;
 100 |     |         Response data;
 101 |     |     }
 102 |     | 
 103 |     |     /**
 104 |     |      * @notice Request body for ReferencePaymentNonexistence attestation type
 105 |     |      * @param minimalBlockNumber The start block of the search range.
 106 |     |      * @param deadlineBlockNumber The blockNumber to be included in the search range.
 107 |     |      * @param deadlineTimestamp The timestamp to be included in the search range.
 108 |     |      * @param destinationAddressHash The standard address hash of the address to which the payment had to be done.
 109 |     |      * @param amount The requested amount in minimal units that had to be payed.
 110 |     |      * @param standardPaymentReference The requested standard payment reference.
 111 |     |      * @param checkSourceAddresses If true, the source address root is checked (only full match).
 112 |     |      * @param sourceAddressesRoot The root of the Merkle tree of the source addresses.
 113 |     |      * @custom:below The `standardPaymentReference` should not be zero (as a 32-byte sequence).
 114 |     |      */
 115 |     |     struct RequestBody {
 116 |     |         uint64 minimalBlockNumber;
 117 |     |         uint64 deadlineBlockNumber;
 118 |     |         uint64 deadlineTimestamp;
 119 |     |         bytes32 destinationAddressHash;
 120 |     |         uint256 amount;
 121 |     |         bytes32 standardPaymentReference;
 122 |     |         bool checkSourceAddresses;
 123 |     |         bytes32 sourceAddressesRoot;
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @notice Response body for ReferencePaymentNonexistence attestation type.
 128 |     |      * @param minimalBlockTimestamp The timestamp of the minimalBlock.
 129 |     |      * @param firstOverflowBlockNumber The height of the firstOverflowBlock.
 130 |     |      * @param firstOverflowBlockTimestamp The timestamp of the firstOverflowBlock.
 131 |     |      * @custom:below `firstOverflowBlock` is the first block that has block number higher than
 132 |     |      * `deadlineBlockNumber` and timestamp later than `deadlineTimestamp`.
 133 |     |      * The specified search range are blocks between heights including `minimalBlockNumber`
 134 |     |      * and excluding `firstOverflowBlockNumber`.
 135 |     |      */
 136 |     |     struct ResponseBody {
 137 |     |         uint64 minimalBlockTimestamp;
 138 |     |         uint64 firstOverflowBlockNumber;
 139 |     |         uint64 firstOverflowBlockTimestamp;
 140 |     |     }
 141 |     | }
 142 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IReferencedPaymentNonexistenceVerification.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "./IReferencedPaymentNonexistence.sol";
  5 |     | 
  6 |     | interface IReferencedPaymentNonexistenceVerification {
  7 |     |     function verifyReferencedPaymentNonexistence(
  8 |     |         IReferencedPaymentNonexistence.Proof calldata _proof
  9 |     |     ) external view returns (bool _proved);
 10 |     | }
 11 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IRelay.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | import "./RandomNumberV2Interface.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * Relay interface.
   8 |     |  */
   9 |     | interface IRelay is RandomNumberV2Interface {
  10 |     |     struct FeeConfig {
  11 |     |         uint8 protocolId; // Protocol id for which the fee is set
  12 |     |         uint256 feeInWei; // Fee in wei
  13 |     |     }
  14 |     | 
  15 |     |     struct RelayInitialConfig {
  16 |     |         uint32 initialRewardEpochId; // The initial reward epoch id.
  17 |     |         uint32 startingVotingRoundIdForInitialRewardEpochId; // The starting voting round id for the initial
  18 |     |         // reward epoch.
  19 |     |         bytes32 initialSigningPolicyHash; // The initial signing policy hash.
  20 |     |         uint8 randomNumberProtocolId; // The protocol id of the random number protocol.
  21 |     |         uint32 firstVotingRoundStartTs; // The timestamp of the first voting round start.
  22 |     |         uint8 votingEpochDurationSeconds; // The duration of a voting epoch in seconds.
  23 |     |         uint32 firstRewardEpochStartVotingRoundId; // The start voting round id of the first reward epoch.
  24 |     |         uint16 rewardEpochDurationInVotingEpochs; // The duration of a reward epoch in voting epochs.
  25 |     |         uint16 thresholdIncreaseBIPS; // The threshold increase in BIPS for signing with
  26 |     |         // old signing policy.
  27 |     |         uint32 messageFinalizationWindowInRewardEpochs; // The window of reward epochs for finalizing
  28 |     |         // the protocol messages.
  29 |     |         address payable feeCollectionAddress; // Fee collection address
  30 |     |         FeeConfig[] feeConfigs; // Fee configurations
  31 |     |     }
  32 |     | 
  33 |     |     struct RelayGovernanceConfig {
  34 |     |         bytes32 descriptionHash; // Description hash (should be keccak256("RelayGovernance")
  35 |     |         uint256 chainId; // Chain id on which is the relay is deployed
  36 |     |         FeeConfig[] newFeeConfigs; // Fee configurations
  37 |     |     }
  38 |     | 
  39 |     |     // Event is emitted when a new signing policy is initialized by the signing policy setter.
  40 |     |     event SigningPolicyInitialized(
  41 |     |         uint24 indexed rewardEpochId, // Reward epoch id
  42 |     |         uint32 startVotingRoundId, // First voting round id of validity.
  43 |     |         // Usually it is the first voting round of reward epoch rewardEpochId.
  44 |     |         // It can be later,
  45 |     |         // if the confirmation of the signing policy on Flare blockchain gets delayed.
  46 |     |         uint16 threshold, // Confirmation threshold (absolute value of noramalised weights).
  47 |     |         uint256 seed, // Random seed.
  48 |     |         address[] voters, // The list of eligible voters in the canonical order.
  49 |     |         uint16[] weights, // The corresponding list of normalised signing weights of eligible voters.
  50 |     |         // Normalisation is done by compressing the weights from 32-byte values to
  51 |     |         // 2 bytes, while approximately keeping the weight relations.
  52 |     |         bytes signingPolicyBytes, // The full signing policy byte encoded.
  53 |     |         uint64 timestamp // Timestamp when this happened
  54 |     |     );
  55 |     | 
  56 |     |     // Event is emitted when a signing policy is relayed.
  57 |     |     // It contains minimalistic data in order to save gas. Data about the signing policy are
  58 |     |     // extractable from the calldata, assuming prefered usage of direct top-level call to relay().
  59 |     |     event SigningPolicyRelayed(
  60 |     |         uint256 indexed rewardEpochId // Reward epoch id
  61 |     |     );
  62 |     | 
  63 |     |     // Event is emitted when a protocol message is relayed.
  64 |     |     event ProtocolMessageRelayed(
  65 |     |         uint8 indexed protocolId, // Protocol id
  66 |     |         uint32 indexed votingRoundId, // Voting round id
  67 |     |         bool isSecureRandom, // Secure random flag
  68 |     |         bytes32 merkleRoot // Merkle root of the protocol message
  69 |     |     );
  70 |     | 
  71 |     |     /**
  72 |     |      * Checks the relay message for sufficient weight of signatures for the _messageHash
  73 |     |      * signed for protocol message Merkle root of the form (1, 0, 0, _messageHash).
  74 |     |      * If the check is successful, reward epoch id of the signing policy is returned.
  75 |     |      * Otherwise the function reverts.
  76 |     |      * @param _relayMessage The relay message.
  77 |     |      * @param _messageHash The hash of the message.
  78 |     |      * @return _rewardEpochId The reward epoch id of the signing policy.
  79 |     |      */
  80 |     |     function verifyCustomSignature(
  81 |     |         bytes calldata _relayMessage,
  82 |     |         bytes32 _messageHash
  83 |     |     ) external returns (uint256 _rewardEpochId);
  84 |     | 
  85 |     |     /**
  86 |     |      * Checks the relay message for sufficient weight of signatures of the hash of the _config data.
  87 |     |      * If the check is successful, the relay contract is configured with the new _config data, which
  88 |     |      * in particular means that fee configurations are updated.
  89 |     |      * Otherwise the function reverts.
  90 |     |      * @param _relayMessage The relay message.
  91 |     |      * @param _config The new relay configuration.
  92 |     |      */
  93 |     |     function governanceFeeSetup(
  94 |     |         bytes calldata _relayMessage,
  95 |     |         RelayGovernanceConfig calldata _config
  96 |     |     ) external;
  97 |     | 
  98 |     |     /**
  99 |     |      * Finalization function for new signing policies and protocol messages.
 100 |     |      * It can be used as finalization contract on Flare chain or as relay contract on other EVM chain.
 101 |     |      * Can be called in two modes. It expects calldata that is parsed in a custom manner.
 102 |     |      * Hence the transaction calls should assemble relevant calldata in the 'data' field.
 103 |     |      * Depending on the data provided, the contract operations in essentially two modes:
 104 |     |      * (1) Relaying signing policy. The structure of the calldata is:
 105 |     |      *        function signature (4 bytes) + active signing policy
 106 |     |      *             + 0 (1 byte) + new signing policy,
 107 |     |      *     total of exactly 4423 bytes.
 108 |     |      * (2) Relaying signed message. The structure of the calldata is:
 109 |     |      *        function signature (4 bytes) + signing policy
 110 |     |      *           + signed message (38 bytes) + ECDSA signatures with indices (67 bytes each)
 111 |     |      *     This case splits into two subcases:
 112 |     |      *     - protocolMessageId = 1: Message id must be of the form (protocolMessageId, 0, 0, merkleRoot).
 113 |     |      *       The validity of the signatures of sufficient weight is checked and if
 114 |     |      *       successful, the merkleRoot from the message is returned (32 bytes) and the
 115 |     |      *       reward epoch id of the signing policy as well (additional 3 bytes)
 116 |     |      *     - protocolMessageId > 1: The validity of the signatures of sufficient weight is checked and if
 117 |     |      *       it is valid, the merkleRoot is published for protocolId and votingRoundId.
 118 |     |      * Reverts if relaying is not successful.
 119 |     |      */
 120 |     |     function relay() external returns (bytes memory);
 121 |     | 
 122 |     |     /**
 123 |     |      * Verifies the leaf (or intermediate node) with the Merkle proof against the Merkle root
 124 |     |      * for given protocol id and voting round id.
 125 |     |      * A fee may need to be paid. It is protocol specific.
 126 |     |      * **NOTE:** Overpayment is not refunded.
 127 |     |      * @param _protocolId The protocol id.
 128 |     |      * @param _votingRoundId The voting round id.
 129 |     |      * @param _leaf The leaf (or intermediate node) to verify.
 130 |     |      * @param _proof The Merkle proof.
 131 |     |      * @return True if the verification is successful.
 132 |     |      */
 133 |     |     function verify(
 134 |     |         uint256 _protocolId,
 135 |     |         uint256 _votingRoundId,
 136 |     |         bytes32 _leaf,
 137 |     |         bytes32[] calldata _proof
 138 |     |     ) external payable returns (bool);
 139 |     | 
 140 |     |     /**
 141 |     |      * Returns the signing policy hash for given reward epoch id.
 142 |     |      * The function is reverted if signingPolicySetter is set, hence on all
 143 |     |      * deployments where the contract is used as a pure relay.
 144 |     |      * @param _rewardEpochId The reward epoch id.
 145 |     |      * @return _signingPolicyHash The signing policy hash.
 146 |     |      */
 147 |     |     function toSigningPolicyHash(
 148 |     |         uint256 _rewardEpochId
 149 |     |     ) external view returns (bytes32 _signingPolicyHash);
 150 |     | 
 151 |     |     /**
 152 |     |      * Returns true if there is finalization for a given protocol id and voting round id.
 153 |     |      * @param _protocolId The protocol id.
 154 |     |      * @param _votingRoundId The voting round id.
 155 |     |      */
 156 |     |     function isFinalized(
 157 |     |         uint256 _protocolId,
 158 |     |         uint256 _votingRoundId
 159 |     |     ) external view returns (bool);
 160 |     | 
 161 |     |     /**
 162 |     |      * Returns the Merkle root for given protocol id and voting round id.
 163 |     |      * The function is reverted if signingPolicySetter is set, hence on all
 164 |     |      * deployments where the contract is used as a pure relay.
 165 |     |      * @param _protocolId The protocol id.
 166 |     |      * @param _votingRoundId The voting round id.
 167 |     |      * @return _merkleRoot The Merkle root.
 168 |     |      */
 169 |     |     function merkleRoots(
 170 |     |         uint256 _protocolId,
 171 |     |         uint256 _votingRoundId
 172 |     |     ) external view returns (bytes32 _merkleRoot);
 173 |     | 
 174 |     |     /**
 175 |     |      * Returns the start voting round id for given reward epoch id.
 176 |     |      * @param _rewardEpochId The reward epoch id.
 177 |     |      * @return _startingVotingRoundId The start voting round id.
 178 |     |      */
 179 |     |     function startingVotingRoundIds(
 180 |     |         uint256 _rewardEpochId
 181 |     |     ) external view returns (uint256 _startingVotingRoundId);
 182 |     | 
 183 |     |     /**
 184 |     |      * Returns the voting round id for given timestamp.
 185 |     |      * @param _timestamp The timestamp.
 186 |     |      * @return _votingRoundId The voting round id.
 187 |     |      */
 188 |     |     function getVotingRoundId(
 189 |     |         uint256 _timestamp
 190 |     |     ) external view returns (uint256 _votingRoundId);
 191 |     | 
 192 |     |     /**
 193 |     |      * Returns last initialized reward epoch data.
 194 |     |      * @return _lastInitializedRewardEpoch Last initialized reward epoch.
 195 |     |      * @return _startingVotingRoundIdForLastInitializedRewardEpoch Starting voting round id for it.
 196 |     |      */
 197 |     |     function lastInitializedRewardEpochData()
 198 |     |         external
 199 |     |         view
 200 |     |         returns (
 201 |     |             uint32 _lastInitializedRewardEpoch,
 202 |     |             uint32 _startingVotingRoundIdForLastInitializedRewardEpoch
 203 |     |         );
 204 |     | 
 205 |     |     /**
 206 |     |      * Returns fee collection address.
 207 |     |      */
 208 |     |     function feeCollectionAddress() external view returns (address payable);
 209 |     | 
 210 |     |     /**
 211 |     |      * Returns fee in wei for one verification of a given protocol id.
 212 |     |      * @param _protocolId The protocol id.
 213 |     |      */
 214 |     |     function protocolFeeInWei(
 215 |     |         uint256 _protocolId
 216 |     |     ) external view returns (uint256);
 217 |     | }
 218 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IRewardManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | import "./RewardsV2Interface.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * RewardManager interface.
   8 |     |  */
   9 |     | interface IRewardManager is RewardsV2Interface {
  10 |     |     /// Struct used for storing unclaimed reward data.
  11 |     |     struct UnclaimedRewardState {
  12 |     |         bool initialised; // Information if already initialised
  13 |     |         // amount and weight might be 0 if all users already claimed
  14 |     |         uint120 amount; // Total unclaimed amount.
  15 |     |         uint128 weight; // Total unclaimed weight.
  16 |     |     }
  17 |     | 
  18 |     |     /**
  19 |     |      * Emitted when rewards are claimed.
  20 |     |      * @param beneficiary Address of the beneficiary (voter or node id) that accrued the reward.
  21 |     |      * @param rewardOwner Address that was eligible for the rewards.
  22 |     |      * @param recipient Address that received the reward.
  23 |     |      * @param rewardEpochId Id of the reward epoch where the reward was accrued.
  24 |     |      * @param claimType Claim type
  25 |     |      * @param amount Amount of rewarded native tokens (wei).
  26 |     |      */
  27 |     |     event RewardClaimed(
  28 |     |         address indexed beneficiary,
  29 |     |         address indexed rewardOwner,
  30 |     |         address indexed recipient,
  31 |     |         uint24 rewardEpochId,
  32 |     |         ClaimType claimType,
  33 |     |         uint120 amount
  34 |     |     );
  35 |     | 
  36 |     |     /**
  37 |     |      * Unclaimed rewards have expired and are now inaccessible.
  38 |     |      *
  39 |     |      * `getUnclaimedRewardState()` can be used to retrieve more information.
  40 |     |      * @param rewardEpochId Id of the reward epoch that has just expired.
  41 |     |      */
  42 |     |     event RewardClaimsExpired(uint256 indexed rewardEpochId);
  43 |     | 
  44 |     |     /**
  45 |     |      * Emitted when reward claims have been enabled.
  46 |     |      * @param rewardEpochId First claimable reward epoch.
  47 |     |      */
  48 |     |     event RewardClaimsEnabled(uint256 indexed rewardEpochId);
  49 |     | 
  50 |     |     /**
  51 |     |      * Claim rewards for `_rewardOwners` and their PDAs.
  52 |     |      * Rewards are deposited to the WNAT (to reward owner or PDA if enabled).
  53 |     |      * It can be called by reward owner or its authorized executor.
  54 |     |      * Only claiming from weight based claims is supported.
  55 |     |      * @param _rewardOwners Array of reward owners.
  56 |     |      * @param _rewardEpochId Id of the reward epoch up to which the rewards are claimed.
  57 |     |      * @param _proofs Array of reward claims with merkle proofs.
  58 |     |      */
  59 |     |     function autoClaim(
  60 |     |         address[] calldata _rewardOwners,
  61 |     |         uint24 _rewardEpochId,
  62 |     |         RewardClaimWithProof[] calldata _proofs
  63 |     |     ) external;
  64 |     | 
  65 |     |     /**
  66 |     |      * Initialises weight based claims.
  67 |     |      * @param _proofs Array of reward claims with merkle proofs.
  68 |     |      */
  69 |     |     function initialiseWeightBasedClaims(
  70 |     |         RewardClaimWithProof[] calldata _proofs
  71 |     |     ) external;
  72 |     | 
  73 |     |     /**
  74 |     |      * Returns the reward manager id.
  75 |     |      */
  76 |     |     function rewardManagerId() external view returns (uint256);
  77 |     | 
  78 |     |     /**
  79 |     |      * Returns the number of weight based claims that have been initialised.
  80 |     |      * @param _rewardEpochId Reward epoch id.
  81 |     |      */
  82 |     |     function noOfInitialisedWeightBasedClaims(
  83 |     |         uint256 _rewardEpochId
  84 |     |     ) external view returns (uint256);
  85 |     | 
  86 |     |     /**
  87 |     |      * Get the current cleanup block number.
  88 |     |      * @return The currently set cleanup block number.
  89 |     |      */
  90 |     |     function cleanupBlockNumber() external view returns (uint256);
  91 |     | 
  92 |     |     /**
  93 |     |      * Returns the state of rewards for a given address at a specific reward epoch.
  94 |     |      * @param _rewardOwner Address of the reward owner.
  95 |     |      * @param _rewardEpochId Reward epoch id.
  96 |     |      * @return _rewardStates Array of reward states.
  97 |     |      */
  98 |     |     function getStateOfRewardsAt(
  99 |     |         address _rewardOwner,
 100 |     |         uint24 _rewardEpochId
 101 |     |     ) external view returns (RewardState[] memory _rewardStates);
 102 |     | 
 103 |     |     /**
 104 |     |      * Gets the unclaimed reward state for a beneficiary, reward epoch id and claim type.
 105 |     |      * @param _beneficiary Address of the beneficiary to query.
 106 |     |      * @param _rewardEpochId Id of the reward epoch to query.
 107 |     |      * @param _claimType Claim type to query.
 108 |     |      * @return _state Unclaimed reward state.
 109 |     |      */
 110 |     |     function getUnclaimedRewardState(
 111 |     |         address _beneficiary,
 112 |     |         uint24 _rewardEpochId,
 113 |     |         ClaimType _claimType
 114 |     |     ) external view returns (UnclaimedRewardState memory _state);
 115 |     | 
 116 |     |     /**
 117 |     |      * Returns totals.
 118 |     |      * @return _totalRewardsWei Total rewards (wei).
 119 |     |      * @return _totalInflationRewardsWei Total inflation rewards (wei).
 120 |     |      * @return _totalClaimedWei Total claimed rewards (wei).
 121 |     |      * @return _totalBurnedWei Total burned rewards (wei).
 122 |     |      */
 123 |     |     function getTotals()
 124 |     |         external
 125 |     |         view
 126 |     |         returns (
 127 |     |             uint256 _totalRewardsWei,
 128 |     |             uint256 _totalInflationRewardsWei,
 129 |     |             uint256 _totalClaimedWei,
 130 |     |             uint256 _totalBurnedWei
 131 |     |         );
 132 |     | 
 133 |     |     /**
 134 |     |      * Returns reward epoch totals.
 135 |     |      * @param _rewardEpochId Reward epoch id.
 136 |     |      * @return _totalRewardsWei Total rewards (inflation + community) for the epoch (wei).
 137 |     |      * @return _totalInflationRewardsWei Total inflation rewards for the epoch (wei).
 138 |     |      * @return _initialisedRewardsWei Initialised rewards of all claim types for the epoch (wei).
 139 |     |      * @return _claimedRewardsWei Claimed rewards for the epoch (wei).
 140 |     |      * @return _burnedRewardsWei Burned rewards for the epoch (wei).
 141 |     |      */
 142 |     |     function getRewardEpochTotals(
 143 |     |         uint24 _rewardEpochId
 144 |     |     )
 145 |     |         external
 146 |     |         view
 147 |     |         returns (
 148 |     |             uint256 _totalRewardsWei,
 149 |     |             uint256 _totalInflationRewardsWei,
 150 |     |             uint256 _initialisedRewardsWei,
 151 |     |             uint256 _claimedRewardsWei,
 152 |     |             uint256 _burnedRewardsWei
 153 |     |         );
 154 |     | 
 155 |     |     /**
 156 |     |      * Returns current reward epoch id.
 157 |     |      */
 158 |     |     function getCurrentRewardEpochId() external view returns (uint24);
 159 |     | 
 160 |     |     /**
 161 |     |      * Returns initial reward epoch id.
 162 |     |      */
 163 |     |     function getInitialRewardEpochId() external view returns (uint256);
 164 |     | 
 165 |     |     /**
 166 |     |      * Returns the reward epoch id that will expire next once a new reward epoch starts.
 167 |     |      */
 168 |     |     function getRewardEpochIdToExpireNext() external view returns (uint256);
 169 |     | 
 170 |     |     /**
 171 |     |      * The first reward epoch id that was claimable.
 172 |     |      */
 173 |     |     function firstClaimableRewardEpochId() external view returns (uint24);
 174 |     | }
 175 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/ISortition.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import {G1Point} from "./IBn256.sol";
  5 |     | 
  6 |     | struct SortitionCredential {
  7 |     |     uint256 replicate;
  8 |     |     G1Point gamma;
  9 |     |     uint256 c;
 10 |     |     uint256 s;
 11 |     | }
 12 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/ISubmission.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "./IRandomProvider.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * Submission interface.
  8 |     |  */
  9 |     | interface ISubmission is IRandomProvider {
 10 |     |     /// Event emitted when a new voting round is initiated.
 11 |     |     event NewVotingRoundInitiated();
 12 |     | 
 13 |     |     /**
 14 |     |      * Submit1 method. Used in multiple protocols (i.e. as FTSO commit method).
 15 |     |      */
 16 |     |     function submit1() external returns (bool);
 17 |     | 
 18 |     |     /**
 19 |     |      * Submit2 method. Used in multiple protocols (i.e. as FTSO reveal method).
 20 |     |      */
 21 |     |     function submit2() external returns (bool);
 22 |     | 
 23 |     |     /**
 24 |     |      * Submit3 method. Future usage.
 25 |     |      */
 26 |     |     function submit3() external returns (bool);
 27 |     | 
 28 |     |     /**
 29 |     |      * SubmitSignatures method. Used in multiple protocols (i.e. as FTSO submit signature method).
 30 |     |      */
 31 |     |     function submitSignatures() external returns (bool);
 32 |     | 
 33 |     |     /**
 34 |     |      * SubmitAndPass method. Future usage.
 35 |     |      * @param _data The data to pass to the submitAndPassContract.
 36 |     |      */
 37 |     |     function submitAndPass(bytes calldata _data) external returns (bool);
 38 |     | }
 39 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IVPContractEvents.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | interface IVPContractEvents {
  5 |     |     /**
  6 |     |      * Event triggered when an account delegates or undelegates another account.
  7 |     |      * Definition: `votePowerFromTo(from, to)` is `changed` from `priorVotePower` to `newVotePower`.
  8 |     |      * For undelegation, `newVotePower` is 0.
  9 |     |      *
 10 |     |      * Note: the event is always emitted from VPToken's `writeVotePowerContract`.
 11 |     |      */
 12 |     |     event Delegate(
 13 |     |         address indexed from,
 14 |     |         address indexed to,
 15 |     |         uint256 priorVotePower,
 16 |     |         uint256 newVotePower
 17 |     |     );
 18 |     | 
 19 |     |     /**
 20 |     |      * Event triggered only when account `delegator` revokes delegation to `delegatee`
 21 |     |      * for a single block in the past (typically the current vote block).
 22 |     |      *
 23 |     |      * Note: the event is always emitted from VPToken's `writeVotePowerContract` and/or `readVotePowerContract`.
 24 |     |      */
 25 |     |     event Revoke(
 26 |     |         address indexed delegator,
 27 |     |         address indexed delegatee,
 28 |     |         uint256 votePower,
 29 |     |         uint256 blockNumber
 30 |     |     );
 31 |     | }
 32 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IVPToken.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   5 |     | import {IGovernanceVotePower} from "./IGovernanceVotePower.sol";
   6 |     | import {IVPContractEvents} from "./IVPContractEvents.sol";
   7 |     | 
   8 |     | interface IVPToken is IERC20 {
   9 |     |     /**
  10 |     |      * @notice Delegate by percentage `_bips` of voting power to `_to` from `msg.sender`.
  11 |     |      * @param _to The address of the recipient
  12 |     |      * @param _bips The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).
  13 |     |      *   Not cumulative - every call resets the delegation value (and value of 0 undelegates `to`).
  14 |     |      **/
  15 |     |     function delegate(address _to, uint256 _bips) external;
  16 |     | 
  17 |     |     /**
  18 |     |      * @notice Undelegate all percentage delegations from the sender and then delegate corresponding
  19 |     |      *   `_bips` percentage of voting power from the sender to each member of `_delegatees`.
  20 |     |      * @param _delegatees The addresses of the new recipients.
  21 |     |      * @param _bips The percentages of voting power to be delegated expressed in basis points (1/100 of one percent).
  22 |     |      *   Total of all `_bips` values must be at most 10000.
  23 |     |      **/
  24 |     |     function batchDelegate(
  25 |     |         address[] memory _delegatees,
  26 |     |         uint256[] memory _bips
  27 |     |     ) external;
  28 |     | 
  29 |     |     /**
  30 |     |      * @notice Explicitly delegate `_amount` of voting power to `_to` from `msg.sender`.
  31 |     |      * @param _to The address of the recipient
  32 |     |      * @param _amount An explicit vote power amount to be delegated.
  33 |     |      *   Not cumulative - every call resets the delegation value (and value of 0 undelegates `to`).
  34 |     |      **/
  35 |     |     function delegateExplicit(address _to, uint _amount) external;
  36 |     | 
  37 |     |     /**
  38 |     |      * @notice Revoke all delegation from sender to `_who` at given block.
  39 |     |      *    Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.
  40 |     |      *    Block `_blockNumber` must be in the past.
  41 |     |      *    This method should be used only to prevent rogue delegate voting in the current voting block.
  42 |     |      *    To stop delegating use delegate/delegateExplicit with value of 0 or undelegateAll/undelegateAllExplicit.
  43 |     |      * @param _who Address of the delegatee
  44 |     |      * @param _blockNumber The block number at which to revoke delegation.
  45 |     |      */
  46 |     |     function revokeDelegationAt(address _who, uint _blockNumber) external;
  47 |     | 
  48 |     |     /**
  49 |     |      * @notice Undelegate all voting power for delegates of `msg.sender`
  50 |     |      *    Can only be used with percentage delegation.
  51 |     |      *    Does not reset delegation mode back to NOTSET.
  52 |     |      **/
  53 |     |     function undelegateAll() external;
  54 |     | 
  55 |     |     /**
  56 |     |      * @notice Undelegate all explicit vote power by amount delegates for `msg.sender`.
  57 |     |      *    Can only be used with explicit delegation.
  58 |     |      *    Does not reset delegation mode back to NOTSET.
  59 |     |      * @param _delegateAddresses Explicit delegation does not store delegatees' addresses,
  60 |     |      *   so the caller must supply them.
  61 |     |      * @return The amount still delegated (in case the list of delegates was incomplete).
  62 |     |      */
  63 |     |     function undelegateAllExplicit(
  64 |     |         address[] memory _delegateAddresses
  65 |     |     ) external returns (uint256);
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev Should be compatible with ERC20 method
  69 |     |      */
  70 |     |     function name() external view returns (string memory);
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Should be compatible with ERC20 method
  74 |     |      */
  75 |     |     function symbol() external view returns (string memory);
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Should be compatible with ERC20 method
  79 |     |      */
  80 |     |     function decimals() external view returns (uint8);
  81 |     | 
  82 |     |     /**
  83 |     |      * @notice Total amount of tokens at a specific `_blockNumber`.
  84 |     |      * @param _blockNumber The block number when the totalSupply is queried
  85 |     |      * @return The total amount of tokens at `_blockNumber`
  86 |     |      **/
  87 |     |     function totalSupplyAt(uint _blockNumber) external view returns (uint256);
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Queries the token balance of `_owner` at a specific `_blockNumber`.
  91 |     |      * @param _owner The address from which the balance will be retrieved.
  92 |     |      * @param _blockNumber The block number when the balance is queried.
  93 |     |      * @return The balance at `_blockNumber`.
  94 |     |      **/
  95 |     |     function balanceOfAt(
  96 |     |         address _owner,
  97 |     |         uint _blockNumber
  98 |     |     ) external view returns (uint256);
  99 |     | 
 100 |     |     /**
 101 |     |      * @notice Get the current total vote power.
 102 |     |      * @return The current total vote power (sum of all accounts' vote powers).
 103 |     |      */
 104 |     |     function totalVotePower() external view returns (uint256);
 105 |     | 
 106 |     |     /**
 107 |     |      * @notice Get the total vote power at block `_blockNumber`
 108 |     |      * @param _blockNumber The block number at which to fetch.
 109 |     |      * @return The total vote power at the block  (sum of all accounts' vote powers).
 110 |     |      */
 111 |     |     function totalVotePowerAt(
 112 |     |         uint _blockNumber
 113 |     |     ) external view returns (uint256);
 114 |     | 
 115 |     |     /**
 116 |     |      * @notice Get the current vote power of `_owner`.
 117 |     |      * @param _owner The address to get voting power.
 118 |     |      * @return Current vote power of `_owner`.
 119 |     |      */
 120 |     |     function votePowerOf(address _owner) external view returns (uint256);
 121 |     | 
 122 |     |     /**
 123 |     |      * @notice Get the vote power of `_owner` at block `_blockNumber`
 124 |     |      * @param _owner The address to get voting power.
 125 |     |      * @param _blockNumber The block number at which to fetch.
 126 |     |      * @return Vote power of `_owner` at `_blockNumber`.
 127 |     |      */
 128 |     |     function votePowerOfAt(
 129 |     |         address _owner,
 130 |     |         uint256 _blockNumber
 131 |     |     ) external view returns (uint256);
 132 |     | 
 133 |     |     /**
 134 |     |      * @notice Get the vote power of `_owner` at block `_blockNumber`, ignoring revocation information (and cache).
 135 |     |      * @param _owner The address to get voting power.
 136 |     |      * @param _blockNumber The block number at which to fetch.
 137 |     |      * @return Vote power of `_owner` at `_blockNumber`. Result doesn't change if vote power is revoked.
 138 |     |      */
 139 |     |     function votePowerOfAtIgnoringRevocation(
 140 |     |         address _owner,
 141 |     |         uint256 _blockNumber
 142 |     |     ) external view returns (uint256);
 143 |     | 
 144 |     |     /**
 145 |     |      * @notice Get the delegation mode for '_who'. This mode determines whether vote power is
 146 |     |      *  allocated by percentage or by explicit value. Once the delegation mode is set,
 147 |     |      *  it never changes, even if all delegations are removed.
 148 |     |      * @param _who The address to get delegation mode.
 149 |     |      * @return delegation mode: 0 = NOTSET, 1 = PERCENTAGE, 2 = AMOUNT (i.e. explicit)
 150 |     |      */
 151 |     |     function delegationModeOf(address _who) external view returns (uint256);
 152 |     | 
 153 |     |     /**
 154 |     |      * @notice Get current delegated vote power `_from` delegator delegated `_to` delegatee.
 155 |     |      * @param _from Address of delegator
 156 |     |      * @param _to Address of delegatee
 157 |     |      * @return The delegated vote power.
 158 |     |      */
 159 |     |     function votePowerFromTo(
 160 |     |         address _from,
 161 |     |         address _to
 162 |     |     ) external view returns (uint256);
 163 |     | 
 164 |     |     /**
 165 |     |      * @notice Get delegated the vote power `_from` delegator delegated `_to` delegatee at `_blockNumber`.
 166 |     |      * @param _from Address of delegator
 167 |     |      * @param _to Address of delegatee
 168 |     |      * @param _blockNumber The block number at which to fetch.
 169 |     |      * @return The delegated vote power.
 170 |     |      */
 171 |     |     function votePowerFromToAt(
 172 |     |         address _from,
 173 |     |         address _to,
 174 |     |         uint _blockNumber
 175 |     |     ) external view returns (uint256);
 176 |     | 
 177 |     |     /**
 178 |     |      * @notice Compute the current undelegated vote power of `_owner`
 179 |     |      * @param _owner The address to get undelegated voting power.
 180 |     |      * @return The unallocated vote power of `_owner`
 181 |     |      */
 182 |     |     function undelegatedVotePowerOf(
 183 |     |         address _owner
 184 |     |     ) external view returns (uint256);
 185 |     | 
 186 |     |     /**
 187 |     |      * @notice Get the undelegated vote power of `_owner` at given block.
 188 |     |      * @param _owner The address to get undelegated voting power.
 189 |     |      * @param _blockNumber The block number at which to fetch.
 190 |     |      * @return The undelegated vote power of `_owner` (= owner's own balance minus all delegations from owner)
 191 |     |      */
 192 |     |     function undelegatedVotePowerOfAt(
 193 |     |         address _owner,
 194 |     |         uint256 _blockNumber
 195 |     |     ) external view returns (uint256);
 196 |     | 
 197 |     |     /**
 198 |     |      * @notice Get the vote power delegation `delegationAddresses`
 199 |     |      *  and `_bips` of `_who`. Returned in two separate positional arrays.
 200 |     |      * @param _who The address to get delegations.
 201 |     |      * @return _delegateAddresses Positional array of delegation addresses.
 202 |     |      * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)
 203 |     |      * @return _count The number of delegates.
 204 |     |      * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).
 205 |     |      */
 206 |     |     function delegatesOf(
 207 |     |         address _who
 208 |     |     )
 209 |     |         external
 210 |     |         view
 211 |     |         returns (
 212 |     |             address[] memory _delegateAddresses,
 213 |     |             uint256[] memory _bips,
 214 |     |             uint256 _count,
 215 |     |             uint256 _delegationMode
 216 |     |         );
 217 |     | 
 218 |     |     /**
 219 |     |      * @notice Get the vote power delegation `delegationAddresses`
 220 |     |      *  and `pcts` of `_who`. Returned in two separate positional arrays.
 221 |     |      * @param _who The address to get delegations.
 222 |     |      * @param _blockNumber The block for which we want to know the delegations.
 223 |     |      * @return _delegateAddresses Positional array of delegation addresses.
 224 |     |      * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)
 225 |     |      * @return _count The number of delegates.
 226 |     |      * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).
 227 |     |      */
 228 |     |     function delegatesOfAt(
 229 |     |         address _who,
 230 |     |         uint256 _blockNumber
 231 |     |     )
 232 |     |         external
 233 |     |         view
 234 |     |         returns (
 235 |     |             address[] memory _delegateAddresses,
 236 |     |             uint256[] memory _bips,
 237 |     |             uint256 _count,
 238 |     |             uint256 _delegationMode
 239 |     |         );
 240 |     | 
 241 |     |     /**
 242 |     |      * Returns VPContract used for readonly operations (view methods).
 243 |     |      * The only non-view method that might be called on it is `revokeDelegationAt`.
 244 |     |      *
 245 |     |      * @notice `readVotePowerContract` is almost always equal to `writeVotePowerContract`
 246 |     |      * except during upgrade from one VPContract to a new version (which should happen
 247 |     |      * rarely or never and will be anounced before).
 248 |     |      *
 249 |     |      * @notice You shouldn't call any methods on VPContract directly, all are exposed
 250 |     |      * via VPToken (and state changing methods are forbidden from direct calls).
 251 |     |      * This is the reason why this method returns `IVPContractEvents` - it should only be used
 252 |     |      * for listening to events (`Revoke` only).
 253 |     |      */
 254 |     |     function readVotePowerContract() external view returns (IVPContractEvents);
 255 |     | 
 256 |     |     /**
 257 |     |      * Returns VPContract used for state changing operations (non-view methods).
 258 |     |      * The only non-view method that might be called on it is `revokeDelegationAt`.
 259 |     |      *
 260 |     |      * @notice `writeVotePowerContract` is almost always equal to `readVotePowerContract`
 261 |     |      * except during upgrade from one VPContract to a new version (which should happen
 262 |     |      * rarely or never and will be anounced before). In the case of upgrade,
 263 |     |      * `writeVotePowerContract` will be replaced first to establish delegations, and
 264 |     |      * after some perio (e.g. after a reward epoch ends) `readVotePowerContract` will be set equal to it.
 265 |     |      *
 266 |     |      * @notice You shouldn't call any methods on VPContract directly, all are exposed
 267 |     |      * via VPToken (and state changing methods are forbidden from direct calls).
 268 |     |      * This is the reason why this method returns `IVPContractEvents` - it should only be used
 269 |     |      * for listening to events (`Delegate` and `Revoke` only).
 270 |     |      */
 271 |     |     function writeVotePowerContract() external view returns (IVPContractEvents);
 272 |     | 
 273 |     |     /**
 274 |     |      * When set, allows token owners to participate in governance voting
 275 |     |      * and delegate governance vote power.
 276 |     |      */
 277 |     |     function governanceVotePower() external view returns (IGovernanceVotePower);
 278 |     | }
 279 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IVoterRegistry.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | /**
   5 |     |  * VoterRegistry interface.
   6 |     |  */
   7 |     | interface IVoterRegistry {
   8 |     |     /// Signature data.
   9 |     |     struct Signature {
  10 |     |         uint8 v;
  11 |     |         bytes32 r;
  12 |     |         bytes32 s;
  13 |     |     }
  14 |     | 
  15 |     |     /// Event emitted when a beneficiary (c-chain address or node id) is chilled.
  16 |     |     event BeneficiaryChilled(
  17 |     |         bytes20 indexed beneficiary,
  18 |     |         uint256 untilRewardEpochId
  19 |     |     );
  20 |     | 
  21 |     |     /// Event emitted when a voter is removed.
  22 |     |     event VoterRemoved(address indexed voter, uint256 indexed rewardEpochId);
  23 |     | 
  24 |     |     /// Event emitted when a voter is registered.
  25 |     |     event VoterRegistered(
  26 |     |         address indexed voter,
  27 |     |         uint24 indexed rewardEpochId,
  28 |     |         address indexed signingPolicyAddress,
  29 |     |         address submitAddress,
  30 |     |         address submitSignaturesAddress,
  31 |     |         bytes32 publicKeyPart1,
  32 |     |         bytes32 publicKeyPart2,
  33 |     |         uint256 registrationWeight
  34 |     |     );
  35 |     | 
  36 |     |     /**
  37 |     |      * Registers a voter if the weight is high enough.
  38 |     |      * @param _voter The voter address.
  39 |     |      * @param _signature The signature.
  40 |     |      */
  41 |     |     function registerVoter(
  42 |     |         address _voter,
  43 |     |         Signature calldata _signature
  44 |     |     ) external;
  45 |     | 
  46 |     |     /**
  47 |     |      * Maximum number of voters in one reward epoch.
  48 |     |      */
  49 |     |     function maxVoters() external view returns (uint256);
  50 |     | 
  51 |     |     /**
  52 |     |      * In case of providing bad votes (e.g. ftso collusion), the beneficiary can be chilled for a few reward epochs.
  53 |     |      * If beneficiary is chilled, the vote power assigned to it is zero.
  54 |     |      * @param _beneficiary The beneficiary (c-chain address or node id).
  55 |     |      * @return _rewardEpochId The reward epoch id until which the voter is chilled.
  56 |     |      */
  57 |     |     function chilledUntilRewardEpochId(
  58 |     |         bytes20 _beneficiary
  59 |     |     ) external view returns (uint256 _rewardEpochId);
  60 |     | 
  61 |     |     /**
  62 |     |      * Returns the block number of the start of the new signing policy initialisation for a given reward epoch.
  63 |     |      * It is a snaphost block of the voters' addresses (it is zero if the reward epoch is not supported).
  64 |     |      * @param _rewardEpochId The reward epoch id.
  65 |     |      */
  66 |     |     function newSigningPolicyInitializationStartBlockNumber(
  67 |     |         uint256 _rewardEpochId
  68 |     |     ) external view returns (uint256);
  69 |     | 
  70 |     |     /**
  71 |     |      * Indicates if the voter must have the public key set when registering.
  72 |     |      */
  73 |     |     function publicKeyRequired() external view returns (bool);
  74 |     | 
  75 |     |     /**
  76 |     |      * Returns the list of registered voters for a given reward epoch.
  77 |     |      * List can be empty if the reward epoch is not supported (before initial reward epoch or future reward epoch).
  78 |     |      * List for the next reward epoch can still change until the signing policy snapshot is created.
  79 |     |      * @param _rewardEpochId The reward epoch id.
  80 |     |      */
  81 |     |     function getRegisteredVoters(
  82 |     |         uint256 _rewardEpochId
  83 |     |     ) external view returns (address[] memory);
  84 |     | 
  85 |     |     /**
  86 |     |      * Returns the number of registered voters for a given reward epoch.
  87 |     |      * Size can be zero if the reward epoch is not supported (before initial reward epoch or future reward epoch).
  88 |     |      * Size for the next reward epoch can still change until the signing policy snapshot is created.
  89 |     |      * @param _rewardEpochId The reward epoch id.
  90 |     |      */
  91 |     |     function getNumberOfRegisteredVoters(
  92 |     |         uint256 _rewardEpochId
  93 |     |     ) external view returns (uint256);
  94 |     | 
  95 |     |     /**
  96 |     |      * Returns true if a voter was (is currently) registered in a given reward epoch.
  97 |     |      * @param _voter The voter address.
  98 |     |      * @param _rewardEpochId The reward epoch id.
  99 |     |      */
 100 |     |     function isVoterRegistered(
 101 |     |         address _voter,
 102 |     |         uint256 _rewardEpochId
 103 |     |     ) external view returns (bool);
 104 |     | }
 105 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IVoterWhitelister.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | interface IVoterWhitelister {
  5 |     |     /**
  6 |     |      * Raised when an account is removed from the voter whitelist.
  7 |     |      */
  8 |     |     event VoterWhitelisted(address voter, uint256 ftsoIndex);
  9 |     | 
 10 |     |     /**
 11 |     |      * Raised when an account is removed from the voter whitelist.
 12 |     |      */
 13 |     |     event VoterRemovedFromWhitelist(address voter, uint256 ftsoIndex);
 14 |     | 
 15 |     |     /**
 16 |     |      * Raised when an account is chilled from the voter whitelist.
 17 |     |      */
 18 |     |     event VoterChilled(address voter, uint256 untilRewardEpoch);
 19 |     | 
 20 |     |     /**
 21 |     |      * Request to whitelist `_voter` account to ftso at `_ftsoIndex`. Will revert if vote power too low.
 22 |     |      * May be called by any address.
 23 |     |      */
 24 |     |     function requestWhitelistingVoter(
 25 |     |         address _voter,
 26 |     |         uint256 _ftsoIndex
 27 |     |     ) external;
 28 |     | 
 29 |     |     /**
 30 |     |      * Request to whitelist `_voter` account to all active ftsos.
 31 |     |      * May be called by any address.
 32 |     |      * It returns an array of supported ftso indices and success flag per index.
 33 |     |      */
 34 |     |     function requestFullVoterWhitelisting(
 35 |     |         address _voter
 36 |     |     )
 37 |     |         external
 38 |     |         returns (uint256[] memory _supportedIndices, bool[] memory _success);
 39 |     | 
 40 |     |     /**
 41 |     |      * Maximum number of voters in the whitelist for a new FTSO.
 42 |     |      */
 43 |     |     function defaultMaxVotersForFtso() external view returns (uint256);
 44 |     | 
 45 |     |     /**
 46 |     |      * Maximum number of voters in the whitelist for FTSO at index `_ftsoIndex`.
 47 |     |      */
 48 |     |     function maxVotersForFtso(
 49 |     |         uint256 _ftsoIndex
 50 |     |     ) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * Get whitelisted price providers for ftso with `_symbol`
 54 |     |      */
 55 |     |     function getFtsoWhitelistedPriceProvidersBySymbol(
 56 |     |         string memory _symbol
 57 |     |     ) external view returns (address[] memory);
 58 |     | 
 59 |     |     /**
 60 |     |      * Get whitelisted price providers for ftso at `_ftsoIndex`
 61 |     |      */
 62 |     |     function getFtsoWhitelistedPriceProviders(
 63 |     |         uint256 _ftsoIndex
 64 |     |     ) external view returns (address[] memory);
 65 |     | 
 66 |     |     /**
 67 |     |      * In case of providing bad prices (e.g. collusion), the voter can be chilled for a few reward epochs.
 68 |     |      * A voter can whitelist again from a returned reward epoch onwards.
 69 |     |      */
 70 |     |     function chilledUntilRewardEpoch(
 71 |     |         address _voter
 72 |     |     ) external view returns (uint256);
 73 |     | }
 74 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IWNat.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | interface IWNat {
  5 |     |     /**
  6 |     |      * @notice Deposit native token and mint WNAT ERC20.
  7 |     |      */
  8 |     |     function deposit() external payable;
  9 |     | 
 10 |     |     /**
 11 |     |      * @notice Withdraw native token and burn WNAT ERC20.
 12 |     |      * @param _amount The amount to withdraw.
 13 |     |      */
 14 |     |     function withdraw(uint256 _amount) external;
 15 |     | 
 16 |     |     /**
 17 |     |      * @notice Deposit native token from msg.sender and mint WNAT ERC20.
 18 |     |      * @param _recipient An address to receive minted WNAT.
 19 |     |      */
 20 |     |     function depositTo(address _recipient) external payable;
 21 |     | 
 22 |     |     /**
 23 |     |      * @notice Withdraw WNAT from an owner and send NAT to msg.sender given an allowance.
 24 |     |      * @param _owner An address spending the native tokens.
 25 |     |      * @param _amount The amount to spend.
 26 |     |      *
 27 |     |      * Requirements:
 28 |     |      *
 29 |     |      * - `_owner` must have a balance of at least `_amount`.
 30 |     |      * - the caller must have allowance for `_owners`'s tokens of at least
 31 |     |      * `_amount`.
 32 |     |      */
 33 |     |     function withdrawFrom(address _owner, uint256 _amount) external;
 34 |     | }
 35 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IWNatDelegationFee.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * WNatDelegationFee interface.
  6 |     |  */
  7 |     | interface IWNatDelegationFee {
  8 |     |     /// Event emitted when a voter fee percentage value is changed.
  9 |     |     event FeePercentageChanged(
 10 |     |         address indexed voter,
 11 |     |         uint16 value,
 12 |     |         uint24 validFromEpochId
 13 |     |     );
 14 |     | 
 15 |     |     /**
 16 |     |      * Allows voter to set (or update last) fee percentage.
 17 |     |      * @param _feePercentageBIPS Number representing fee percentage in BIPS.
 18 |     |      * @return Returns the reward epoch number when the value becomes effective.
 19 |     |      */
 20 |     |     function setVoterFeePercentage(
 21 |     |         uint16 _feePercentageBIPS
 22 |     |     ) external returns (uint256);
 23 |     | 
 24 |     |     /// The offset in reward epochs for the fee percentage value to become effective.
 25 |     |     function feePercentageUpdateOffset() external view returns (uint24);
 26 |     | 
 27 |     |     /// The default fee percentage value.
 28 |     |     function defaultFeePercentageBIPS() external view returns (uint16);
 29 |     | 
 30 |     |     /**
 31 |     |      * Returns the current fee percentage of `_voter`.
 32 |     |      * @param _voter Voter address.
 33 |     |      */
 34 |     |     function getVoterCurrentFeePercentage(
 35 |     |         address _voter
 36 |     |     ) external view returns (uint16);
 37 |     | 
 38 |     |     /**
 39 |     |      * Returns the fee percentage of `_voter` for given reward epoch id.
 40 |     |      * @param _voter Voter address.
 41 |     |      * @param _rewardEpochId Reward epoch id.
 42 |     |      * **NOTE:** fee percentage might still change for the `current + feePercentageUpdateOffset` reward epoch id
 43 |     |      */
 44 |     |     function getVoterFeePercentage(
 45 |     |         address _voter,
 46 |     |         uint256 _rewardEpochId
 47 |     |     ) external view returns (uint16);
 48 |     | 
 49 |     |     /**
 50 |     |      * Returns the scheduled fee percentage changes of `_voter`.
 51 |     |      * @param _voter Voter address.
 52 |     |      * @return _feePercentageBIPS Positional array of fee percentages in BIPS.
 53 |     |      * @return _validFromEpochId Positional array of reward epoch ids the fee setings are effective from.
 54 |     |      * @return _fixed Positional array of boolean values indicating if settings are subjected to change.
 55 |     |      */
 56 |     |     function getVoterScheduledFeePercentageChanges(
 57 |     |         address _voter
 58 |     |     )
 59 |     |         external
 60 |     |         view
 61 |     |         returns (
 62 |     |             uint256[] memory _feePercentageBIPS,
 63 |     |             uint256[] memory _validFromEpochId,
 64 |     |             bool[] memory _fixed
 65 |     |         );
 66 |     | }
 67 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IWeb2Json.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * @custom:name IWeb2Json
  6 |     |  * @custom:supported WEB2
  7 |     |  * @author Flare
  8 |     |  * @notice An attestation request that fetches JSON data from the given URL,
  9 |     |  * applies a jq filter to transform the returned result, and returns the structured data as ABI encoded data.
 10 |     |  * @custom:verification  Data is fetched from an URL `url`. The received data is then processed with jq as
 11 |     |  * the `postProcessJq` states. The structure of the final JSON is written in the `abiSignature`.
 12 |     |  *
 13 |     |  * The response contains an abi encoding of the final data.
 14 |     |  * @custom:lut `0xffffffffffffffff`
 15 |     |  * @custom:lut-limit `0xffffffffffffffff`
 16 |     |  */
 17 |     | interface IWeb2Json {
 18 |     |     /**
 19 |     |      * @notice Toplevel request
 20 |     |      * @param attestationType ID of the attestation type.
 21 |     |      * @param sourceId ID of the data source.
 22 |     |      * @param messageIntegrityCode `MessageIntegrityCode` that is derived from the expected response.
 23 |     |      * @param requestBody Data defining the request. Type (struct) and interpretation is determined
 24 |     |      * by the `attestationType`.
 25 |     |      */
 26 |     |     struct Request {
 27 |     |         bytes32 attestationType;
 28 |     |         bytes32 sourceId;
 29 |     |         bytes32 messageIntegrityCode;
 30 |     |         RequestBody requestBody;
 31 |     |     }
 32 |     | 
 33 |     |     /**
 34 |     |      * @notice Toplevel response
 35 |     |      * @param attestationType Extracted from the request.
 36 |     |      * @param sourceId Extracted from the request.
 37 |     |      * @param votingRound The ID of the State Connector round in which the request was considered.
 38 |     |      * @param lowestUsedTimestamp The lowest timestamp used to generate the response.
 39 |     |      * @param requestBody Extracted from the request.
 40 |     |      * @param responseBody Data defining the response. The verification rules for the construction
 41 |     |      * of the response body and the type are defined per specific `attestationType`.
 42 |     |      */
 43 |     |     struct Response {
 44 |     |         bytes32 attestationType;
 45 |     |         bytes32 sourceId;
 46 |     |         uint64 votingRound;
 47 |     |         uint64 lowestUsedTimestamp;
 48 |     |         RequestBody requestBody;
 49 |     |         ResponseBody responseBody;
 50 |     |     }
 51 |     | 
 52 |     |     /**
 53 |     |      * @notice Toplevel proof
 54 |     |      * @param merkleProof Merkle proof corresponding to the attestation response.
 55 |     |      * @param data Attestation response.
 56 |     |      */
 57 |     |     struct Proof {
 58 |     |         bytes32[] merkleProof;
 59 |     |         Response data;
 60 |     |     }
 61 |     | 
 62 |     |     /**
 63 |     |      * @notice Request body for Web2Json attestation type
 64 |     |      * @param url URL of the data source
 65 |     |      * @param httpMethod HTTP method to be used to fetch from URL source.
 66 |     |      * Supported methods: GET, POST, PUT, PATCH, DELETE.
 67 |     |      * @param headers Headers to be included to fetch from URL source. Use `{}` if no headers are needed.
 68 |     |      * @param queryParams Query parameters to be included to fetch from URL source.
 69 |     |      * Use `{}` if no query parameters are needed.
 70 |     |      * @param body Request body to be included to fetch from URL source. Use '{}' if no request body is required.
 71 |     |      * @param postProcessJq jq filter used to post-process the JSON response from the URL.
 72 |     |      * @param abiSignature ABI signature of the struct used to encode the data after jq post-processing.
 73 |     |      */
 74 |     |     struct RequestBody {
 75 |     |         string url;
 76 |     |         string httpMethod;
 77 |     |         string headers;
 78 |     |         string queryParams;
 79 |     |         string body;
 80 |     |         string postProcessJq;
 81 |     |         string abiSignature;
 82 |     |     }
 83 |     | 
 84 |     |     /**
 85 |     |      * @notice Response body for Web2Json attestation type
 86 |     |      * @param abiEncodedData Raw binary data encoded to match the function parameters in ABI.
 87 |     |      */
 88 |     |     struct ResponseBody {
 89 |     |         bytes abiEncodedData;
 90 |     |     }
 91 |     | }
 92 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/IWeb2JsonVerification.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "./IWeb2Json.sol";
  5 |     | 
  6 |     | interface IWeb2JsonVerification {
  7 |     |     function verifyWeb2Json(
  8 |     |         IWeb2Json.Proof calldata _proof
  9 |     |     ) external view returns (bool _proved);
 10 |     | }
 11 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/ProtocolsV2Interface.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * Protocols V2 long term support interface.
  6 |     |  */
  7 |     | interface ProtocolsV2Interface {
  8 |     |     /**
  9 |     |      * Timestamp when the first reward epoch started, in seconds since UNIX epoch.
 10 |     |      */
 11 |     |     function firstRewardEpochStartTs() external view returns (uint64);
 12 |     | 
 13 |     |     /**
 14 |     |      * Duration of reward epoch, in seconds.
 15 |     |      */
 16 |     |     function rewardEpochDurationSeconds() external view returns (uint64);
 17 |     | 
 18 |     |     /**
 19 |     |      * Timestamp when the first voting epoch started, in seconds since UNIX epoch.
 20 |     |      */
 21 |     |     function firstVotingRoundStartTs() external view returns (uint64);
 22 |     | 
 23 |     |     /**
 24 |     |      * Duration of voting epoch, in seconds.
 25 |     |      */
 26 |     |     function votingEpochDurationSeconds() external view returns (uint64);
 27 |     | 
 28 |     |     /**
 29 |     |      * Returns the vote power block for given reward epoch id.
 30 |     |      */
 31 |     |     function getVotePowerBlock(
 32 |     |         uint256 _rewardEpochId
 33 |     |     ) external view returns (uint64 _votePowerBlock);
 34 |     | 
 35 |     |     /**
 36 |     |      * Returns the start voting round id for given reward epoch id.
 37 |     |      */
 38 |     |     function getStartVotingRoundId(
 39 |     |         uint256 _rewardEpochId
 40 |     |     ) external view returns (uint32);
 41 |     | 
 42 |     |     /**
 43 |     |      * Returns the current reward epoch id.
 44 |     |      */
 45 |     |     function getCurrentRewardEpochId() external view returns (uint24);
 46 |     | 
 47 |     |     /**
 48 |     |      * Returns the current voting epoch id.
 49 |     |      */
 50 |     |     function getCurrentVotingEpochId() external view returns (uint32);
 51 |     | }
 52 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/RandomNumberV2Interface.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * Random number V2 long term support interface.
  6 |     |  */
  7 |     | interface RandomNumberV2Interface {
  8 |     |     /**
  9 |     |      * Returns the current random number, its timestamp and the flag indicating if it is secure.
 10 |     |      * @return _randomNumber The current random number.
 11 |     |      * @return _isSecureRandom The flag indicating if the random number is secure.
 12 |     |      * @return _randomTimestamp The timestamp of the random number.
 13 |     |      */
 14 |     |     function getRandomNumber()
 15 |     |         external
 16 |     |         view
 17 |     |         returns (
 18 |     |             uint256 _randomNumber,
 19 |     |             bool _isSecureRandom,
 20 |     |             uint256 _randomTimestamp
 21 |     |         );
 22 |     | 
 23 |     |     /**
 24 |     |      * Returns the historical random number for a given _votingRoundId,
 25 |     |      * its timestamp and the flag indicating if it is secure.
 26 |     |      * If no finalization in the _votingRoundId, the function reverts.
 27 |     |      * @param _votingRoundId The voting round id.
 28 |     |      * @return _randomNumber The current random number.
 29 |     |      * @return _isSecureRandom The flag indicating if the random number is secure.
 30 |     |      * @return _randomTimestamp The timestamp of the random number.
 31 |     |      */
 32 |     |     function getRandomNumberHistorical(
 33 |     |         uint256 _votingRoundId
 34 |     |     )
 35 |     |         external
 36 |     |         view
 37 |     |         returns (
 38 |     |             uint256 _randomNumber,
 39 |     |             bool _isSecureRandom,
 40 |     |             uint256 _randomTimestamp
 41 |     |         );
 42 |     | }
 43 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/RewardsV2Interface.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | /**
  5 |     |  * Rewards V2 long term support interface.
  6 |     |  */
  7 |     | interface RewardsV2Interface {
  8 |     |     /// Claim type enum.
  9 |     |     enum ClaimType {
 10 |     |         DIRECT,
 11 |     |         FEE,
 12 |     |         WNAT,
 13 |     |         MIRROR,
 14 |     |         CCHAIN
 15 |     |     }
 16 |     | 
 17 |     |     /// Struct used for claiming rewards with Merkle proof.
 18 |     |     struct RewardClaimWithProof {
 19 |     |         bytes32[] merkleProof;
 20 |     |         RewardClaim body;
 21 |     |     }
 22 |     | 
 23 |     |     /// Struct used in Merkle tree for storing reward claims.
 24 |     |     struct RewardClaim {
 25 |     |         uint24 rewardEpochId;
 26 |     |         bytes20 beneficiary; // c-chain address or node id (bytes20) in case of type MIRROR
 27 |     |         uint120 amount; // in wei
 28 |     |         ClaimType claimType;
 29 |     |     }
 30 |     | 
 31 |     |     /// Struct used for returning state of rewards.
 32 |     |     struct RewardState {
 33 |     |         uint24 rewardEpochId;
 34 |     |         bytes20 beneficiary; // c-chain address or node id (bytes20) in case of type MIRROR
 35 |     |         uint120 amount; // in wei
 36 |     |         ClaimType claimType;
 37 |     |         bool initialised;
 38 |     |     }
 39 |     | 
 40 |     |     /**
 41 |     |      * Claim rewards for `_rewardOwner` and transfer them to `_recipient`.
 42 |     |      * It can be called by reward owner or its authorized executor.
 43 |     |      * @param _rewardOwner Address of the reward owner.
 44 |     |      * @param _recipient Address of the reward recipient.
 45 |     |      * @param _rewardEpochId Id of the reward epoch up to which the rewards are claimed.
 46 |     |      * @param _wrap Indicates if the reward should be wrapped (deposited) to the WNAT contract.
 47 |     |      * @param _proofs Array of reward claims with merkle proofs.
 48 |     |      * @return _rewardAmountWei Amount of rewarded native tokens (wei).
 49 |     |      */
 50 |     |     function claim(
 51 |     |         address _rewardOwner,
 52 |     |         address payable _recipient,
 53 |     |         uint24 _rewardEpochId,
 54 |     |         bool _wrap,
 55 |     |         RewardClaimWithProof[] calldata _proofs
 56 |     |     ) external returns (uint256 _rewardAmountWei);
 57 |     | 
 58 |     |     /**
 59 |     |      * Indicates if the contract is active - claims are enabled.
 60 |     |      */
 61 |     |     function active() external view returns (bool);
 62 |     | 
 63 |     |     /**
 64 |     |      * Returns the start and the end of the reward epoch range for which the reward is claimable.
 65 |     |      * @return _startEpochId The oldest epoch id that allows reward claiming.
 66 |     |      * @return _endEpochId The newest epoch id that allows reward claiming.
 67 |     |      */
 68 |     |     function getRewardEpochIdsWithClaimableRewards()
 69 |     |         external
 70 |     |         view
 71 |     |         returns (uint24 _startEpochId, uint24 _endEpochId);
 72 |     | 
 73 |     |     /**
 74 |     |      * Returns the next claimable reward epoch for a reward owner.
 75 |     |      * @param _rewardOwner Address of the reward owner to query.
 76 |     |      */
 77 |     |     function getNextClaimableRewardEpochId(
 78 |     |         address _rewardOwner
 79 |     |     ) external view returns (uint256);
 80 |     | 
 81 |     |     /**
 82 |     |      * Returns the state of rewards for a given address for all unclaimed reward epochs with claimable rewards.
 83 |     |      * @param _rewardOwner Address of the reward owner.
 84 |     |      * @return _rewardStates Array of reward states.
 85 |     |      */
 86 |     |     function getStateOfRewards(
 87 |     |         address _rewardOwner
 88 |     |     ) external view returns (RewardState[][] memory _rewardStates);
 89 |     | }
 90 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/TestFtsoV2Interface.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | /**
   5 |     |  * FtsoV2 long term support interface.
   6 |     |  */
   7 |     | interface TestFtsoV2Interface {
   8 |     |     /// Feed data structure
   9 |     |     struct FeedData {
  10 |     |         uint32 votingRoundId;
  11 |     |         bytes21 id;
  12 |     |         int32 value;
  13 |     |         uint16 turnoutBIPS;
  14 |     |         int8 decimals;
  15 |     |     }
  16 |     | 
  17 |     |     /// Feed data with proof structure
  18 |     |     struct FeedDataWithProof {
  19 |     |         bytes32[] proof;
  20 |     |         FeedData body;
  21 |     |     }
  22 |     | 
  23 |     |     /// Feed id change structure
  24 |     |     struct FeedIdChange {
  25 |     |         bytes21 oldFeedId;
  26 |     |         bytes21 newFeedId;
  27 |     |     }
  28 |     | 
  29 |     |     /// Event emitted when a feed id is changed (e.g. feed renamed).
  30 |     |     event FeedIdChanged(bytes21 indexed oldFeedId, bytes21 indexed newFeedId);
  31 |     | 
  32 |     |     /**
  33 |     |      * Returns the FTSO protocol id.
  34 |     |      */
  35 |     |     function getFtsoProtocolId() external view returns (uint256);
  36 |     | 
  37 |     |     /**
  38 |     |      * Returns the list of supported feed ids (currently active feed ids).
  39 |     |      * To get the list of all available feed ids, combine with `getFeedIdChanges()`.
  40 |     |      * @return _feedIds The list of supported feed ids.
  41 |     |      */
  42 |     |     function getSupportedFeedIds()
  43 |     |         external
  44 |     |         view
  45 |     |         returns (bytes21[] memory _feedIds);
  46 |     | 
  47 |     |     /**
  48 |     |      * Returns the list of feed id changes.
  49 |     |      * @return _feedIdChanges The list of changed feed id pairs (old and new feed id).
  50 |     |      */
  51 |     |     function getFeedIdChanges()
  52 |     |         external
  53 |     |         view
  54 |     |         returns (FeedIdChange[] memory _feedIdChanges);
  55 |     | 
  56 |     |     /**
  57 |     |      * Calculates the fee for fetching a feed.
  58 |     |      * @param _feedId The id of the feed.
  59 |     |      * @return _fee The fee for fetching the feed.
  60 |     |      */
  61 |     |     function calculateFeeById(
  62 |     |         bytes21 _feedId
  63 |     |     ) external view returns (uint256 _fee);
  64 |     | 
  65 |     |     /**
  66 |     |      * Calculates the fee for fetching feeds.
  67 |     |      * @param _feedIds The list of feed ids.
  68 |     |      * @return _fee The fee for fetching the feeds.
  69 |     |      */
  70 |     |     function calculateFeeByIds(
  71 |     |         bytes21[] memory _feedIds
  72 |     |     ) external view returns (uint256 _fee);
  73 |     | 
  74 |     |     /**
  75 |     |      * Returns stored data of a feed.
  76 |     |      * A fee (calculated by the FeeCalculator contract) may need to be paid.
  77 |     |      * @param _feedId The id of the feed.
  78 |     |      * @return _value The value for the requested feed.
  79 |     |      * @return _decimals The decimal places for the requested feed.
  80 |     |      * @return _timestamp The timestamp of the last update.
  81 |     |      */
  82 |     |     function getFeedById(
  83 |     |         bytes21 _feedId
  84 |     |     ) external view returns (uint256 _value, int8 _decimals, uint64 _timestamp);
  85 |     | 
  86 |     |     /**
  87 |     |      * Returns stored data of each feed.
  88 |     |      * A fee (calculated by the FeeCalculator contract) may need to be paid.
  89 |     |      * @param _feedIds The list of feed ids.
  90 |     |      * @return _values The list of values for the requested feeds.
  91 |     |      * @return _decimals The list of decimal places for the requested feeds.
  92 |     |      * @return _timestamp The timestamp of the last update.
  93 |     |      */
  94 |     |     function getFeedsById(
  95 |     |         bytes21[] memory _feedIds
  96 |     |     )
  97 |     |         external
  98 |     |         view
  99 |     |         returns (
 100 |     |             uint256[] memory _values,
 101 |     |             int8[] memory _decimals,
 102 |     |             uint64 _timestamp
 103 |     |         );
 104 |     | 
 105 |     |     /**
 106 |     |      * Returns value in wei and timestamp of a feed.
 107 |     |      * A fee (calculated by the FeeCalculator contract) may need to be paid.
 108 |     |      * @param _feedId The id of the feed.
 109 |     |      * @return _value The value for the requested feed in wei (i.e. with 18 decimal places).
 110 |     |      * @return _timestamp The timestamp of the last update.
 111 |     |      */
 112 |     |     function getFeedByIdInWei(
 113 |     |         bytes21 _feedId
 114 |     |     ) external view returns (uint256 _value, uint64 _timestamp);
 115 |     | 
 116 |     |     /** Returns value of each feed and a timestamp.
 117 |     |      * For some feeds, a fee (calculated by the FeeCalculator contract) may need to be paid.
 118 |     |      * @param _feedIds Ids of the feeds.
 119 |     |      * @return _values The list of values for the requested feeds in wei (i.e. with 18 decimal places).
 120 |     |      * @return _timestamp The timestamp of the last update.
 121 |     |      */
 122 |     |     function getFeedsByIdInWei(
 123 |     |         bytes21[] memory _feedIds
 124 |     |     ) external view returns (uint256[] memory _values, uint64 _timestamp);
 125 |     | 
 126 |     |     /**
 127 |     |      * Checks if the feed data is valid (i.e. is part of the confirmed Merkle tree).
 128 |     |      * @param _feedData Structure containing data about the feed (FeedData structure) and Merkle proof.
 129 |     |      * @return true if the feed data is valid.
 130 |     |      */
 131 |     |     function verifyFeedData(
 132 |     |         FeedDataWithProof calldata _feedData
 133 |     |     ) external view returns (bool);
 134 |     | }
 135 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/data/AgentInfo.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   5 |     | 
   6 |     | library AgentInfo {
   7 |     |     enum Status {
   8 |     |         // agent is operating normally
   9 |     |         NORMAL,
  10 |     |         // liquidation due to collateral ratio - ends when agent is healthy
  11 |     |         LIQUIDATION,
  12 |     |         // illegal payment liquidation - always liquidates all and then agent must close vault
  13 |     |         FULL_LIQUIDATION,
  14 |     |         // agent announced destroy, cannot mint again; all existing mintings have been redeemed before
  15 |     |         DESTROYING,
  16 |     |         // agent has been destroyed, cannot do anything except return info
  17 |     |         // owner can still withdraw tokens from the vault
  18 |     |         DESTROYED
  19 |     |     }
  20 |     | 
  21 |     |     struct Info {
  22 |     |         // Current agent's status.
  23 |     |         AgentInfo.Status status;
  24 |     |         // Agent vault owner's management address, used for occasional administration.
  25 |     |         // Immutable.
  26 |     |         address ownerManagementAddress;
  27 |     |         // Agent vault owner's work address, used for automatic operations.
  28 |     |         // Can be changed by a call from the owner's management address.
  29 |     |         address ownerWorkAddress;
  30 |     |         // Agent's collateral pool address
  31 |     |         address collateralPool;
  32 |     |         // Agent collateral pool's pool token address
  33 |     |         address collateralPoolToken;
  34 |     |         // Underlying address as string - to be used for minting payments.
  35 |     |         // For most other purposes, you use underlyingAddressHash, which is `keccak256(underlyingAddressString)`.
  36 |     |         string underlyingAddressString;
  37 |     |         // If true, anybody can mint against this agent.
  38 |     |         // If false, the agent can only self-mint.
  39 |     |         // Once minted, all redemption tickets go to the same (public) queue, regardless of this flag.
  40 |     |         bool publiclyAvailable;
  41 |     |         // Current fee the agent charges for minting (paid in underlying currency).
  42 |     |         uint256 feeBIPS;
  43 |     |         // Share of the minting fee that goes to the pool as percentage of the minting fee.
  44 |     |         // This share of fee is minted as f-assets and belongs to the pool.
  45 |     |         uint256 poolFeeShareBIPS;
  46 |     |         // The token identifier of the agent's current vault collateral.
  47 |     |         // Token identifier can be used to call AssetManager.getCollateralType().
  48 |     |         IERC20 vaultCollateralToken;
  49 |     |         // Amount, set by agent, at which locked and free collateral are calculated for new mintings.
  50 |     |         // For agent's vault collateral.
  51 |     |         uint256 mintingVaultCollateralRatioBIPS;
  52 |     |         // Amount, set by agent, at which locked and free collateral are calculated for new mintings.
  53 |     |         // For pool collateral.
  54 |     |         uint256 mintingPoolCollateralRatioBIPS;
  55 |     |         // The maximum number of lots that the agent can mint.
  56 |     |         // This can change any moment due to minting, redemption or price changes.
  57 |     |         uint256 freeCollateralLots;
  58 |     |         // Total amount of vault collateral in agent's vault.
  59 |     |         uint256 totalVaultCollateralWei;
  60 |     |         // Free collateral, available for new mintings.
  61 |     |         // Note: this value doesn't tell you anything about agent being near liquidation, since it is
  62 |     |         // calculated at agentMinCollateralRatio, not minCollateralRatio.
  63 |     |         // Use collateralRatioBIPS to see whether the agent is near liquidation.
  64 |     |         uint256 freeVaultCollateralWei;
  65 |     |         // The actual agent's collateral ratio, as it is used in liquidation.
  66 |     |         // For calculation, the system checks both FTSO prices and trusted provider's prices and uses
  67 |     |         // the ones that give higher ratio.
  68 |     |         uint256 vaultCollateralRatioBIPS;
  69 |     |         // The token identifier of the agent's current vault collateral.
  70 |     |         // Token identifier can be used to call AssetManager.getCollateralType().
  71 |     |         IERC20 poolWNatToken;
  72 |     |         // Total amount of NAT collateral in agent's pool.
  73 |     |         uint256 totalPoolCollateralNATWei;
  74 |     |         // Free NAT pool collateral (see vault collateral for details).
  75 |     |         uint256 freePoolCollateralNATWei;
  76 |     |         // The actual pool collateral ratio (see vault collateral for details).
  77 |     |         uint256 poolCollateralRatioBIPS;
  78 |     |         // The amount of pool tokens that belong to agent's vault. This limits the amount of possible
  79 |     |         // minting: to be able to mint, the NAT value of all backed fassets together with new ones, times
  80 |     |         // mintingPoolHoldingsRequiredBIPS, must be smaller than the agent's pool tokens amount converted to NAT.
  81 |     |         // Note: the amount of agent's pool tokens only affects minting, not liquidation.
  82 |     |         uint256 totalAgentPoolTokensWei;
  83 |     |         // The amount of vault collateral that will be withdrawn by the agent.
  84 |     |         uint256 announcedVaultCollateralWithdrawalWei;
  85 |     |         // The amount of pool tokens that will be withdrawn by the agent.
  86 |     |         uint256 announcedPoolTokensWithdrawalWei;
  87 |     |         // Free agent's pool tokens.
  88 |     |         uint256 freeAgentPoolTokensWei;
  89 |     |         // Total amount of minted f-assets.
  90 |     |         uint256 mintedUBA;
  91 |     |         // Total amount reserved for ongoing mintings.
  92 |     |         uint256 reservedUBA;
  93 |     |         // Total amount of ongoing redemptions.
  94 |     |         uint256 redeemingUBA;
  95 |     |         // Total amount of ongoing redemptions that lock the pool collateral.
  96 |     |         // (In pool self-close exits, pool collateral is not locked. So the amount of locked
  97 |     |         // collateral in the pool can be less than the amount of locked vault collateral.)
  98 |     |         uint256 poolRedeemingUBA;
  99 |     |         // Total amount of dust (unredeemable minted f-assets).
 100 |     |         // Note: dustUBA is part of mintedUBA, so the amount of redeemable f-assets is calculated as
 101 |     |         // `mintedUBA - dustUBA`
 102 |     |         uint256 dustUBA;
 103 |     |         // Liquidation info
 104 |     |         // If the agent is in LIQUIDATION or FULL_LIQUIDATION, the time agent entered liquidation.
 105 |     |         // If status is neither of that, returns 0.
 106 |     |         // Can be used for calculating current liquidation premium, which depends on time since liquidation started.
 107 |     |         uint256 liquidationStartTimestamp;
 108 |     |         // When agent is in liquidation, this is the amount o FAssets that need to be liquidated to bring the agent's
 109 |     |         // position to safety. When performing liquidation, only up to this amount of FAssets will be liquidated.
 110 |     |         // If not in liquidation, this value is 0.
 111 |     |         // Since the liquidation state may need to be upgraded by, call `startLiquidation` before
 112 |     |         // `getAgentInfo` to get the value that will actually be used in liquidation.
 113 |     |         uint256 maxLiquidationAmountUBA;
 114 |     |         // When agent is in liquidation, this is the factor (in BIPS) of the converted value of the liquidated
 115 |     |         // FAssets paid by the vault collateral. If not in liquidation, this value is 0.
 116 |     |         uint256 liquidationPaymentFactorVaultBIPS;
 117 |     |         // When agent is in liquidation, this is the factor (in BIPS) of the converted value of the liquidated
 118 |     |         // FAssets paid by the pool collateral. If not in liquidation, this value is 0.
 119 |     |         uint256 liquidationPaymentFactorPoolBIPS;
 120 |     |         // Total underlying balance (backing and free).
 121 |     |         int256 underlyingBalanceUBA;
 122 |     |         // The minimum underlying balance that has to be held by the agent. Below this, agent is liquidated.
 123 |     |         uint256 requiredUnderlyingBalanceUBA;
 124 |     |         // Underlying balance not backing anything (can be used for gas/fees or withdrawn after announcement).
 125 |     |         int256 freeUnderlyingBalanceUBA;
 126 |     |         // Current underlying withdrawal announcement (or 0 if no announcement was made).
 127 |     |         uint256 announcedUnderlyingWithdrawalId;
 128 |     |         // The factor set by the agent to multiply the price at which agent buys f-assets from pool
 129 |     |         // token holders on self-close exit (when requested or the redeemed amount is less than 1 lot).
 130 |     |         uint256 buyFAssetByAgentFactorBIPS;
 131 |     |         // The minimum collateral ratio above which a staker can exit the pool
 132 |     |         // (this is CR that must be left after exit).
 133 |     |         // Must be higher than system minimum collateral ratio for pool collateral.
 134 |     |         uint256 poolExitCollateralRatioBIPS;
 135 |     |         // The redemption fee share paid to the pool (as FAssets).
 136 |     |         // In redemption dominated situations (when agent requests return from core vault to earn
 137 |     |         // from redemption fees), pool can get some share to make it sustainable for pool users.
 138 |     |         // NOTE: the pool fee share is locked at the redemption request time, but is charged at the redemption
 139 |     |         // confirmation time. If agent uses all the redemption fee for transaction fees, this could make the
 140 |     |         // agent's free underlying balance negative.
 141 |     |         uint256 redemptionPoolFeeShareBIPS;
 142 |     |     }
 143 |     | }
 144 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/data/AgentSettings.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  5 |     | 
  6 |     | library AgentSettings {
  7 |     |     struct Data {
  8 |     |         // The token used as vault collateral. Must be one of the tokens obtained by `getCollateralTypes()`,
  9 |     |         // with class VAULT.
 10 |     |         IERC20 vaultCollateralToken;
 11 |     |         // The suffix to pool token name and symbol that identifies new vault's collateral pool token.
 12 |     |         // Must be unique within an asset manager.
 13 |     |         string poolTokenSuffix;
 14 |     |         // Minting fee. Normally charged to minters for publicly available agents, but must be set
 15 |     |         // also for self-minting agents to pay part of it to collateral pool.
 16 |     |         // Fee is paid in underlying currency along with backing assets.
 17 |     |         uint256 feeBIPS;
 18 |     |         // Share of the minting fee that goes to the pool as percentage of the minting fee.
 19 |     |         // This share of fee is minted as f-assets and belongs to the pool.
 20 |     |         uint256 poolFeeShareBIPS;
 21 |     |         // Collateral ratio at which we calculate locked collateral and collateral available for minting.
 22 |     |         // Agent may set own value for minting collateral ratio on creation.
 23 |     |         // The value must always be greater than system minimum collateral ratio for vault collateral.
 24 |     |         // Warning: having this value near global min collateral ratio can quickly lead to liquidation for public
 25 |     |         // agents, so it is advisable to set it significantly higher.
 26 |     |         uint256 mintingVaultCollateralRatioBIPS;
 27 |     |         // Collateral ratio at which we calculate locked collateral and collateral available for minting.
 28 |     |         // Agent may set own value for minting collateral ratio on creation.
 29 |     |         // The value must always be greater than system minimum collateral ratio for pool collateral.
 30 |     |         // Warning: having this value near global min collateral ratio can quickly lead to liquidation for public
 31 |     |         // agents, so it is advisable to set it significantly higher.
 32 |     |         uint256 mintingPoolCollateralRatioBIPS;
 33 |     |         // The factor set by the agent to multiply the price at which agent buys f-assets from pool
 34 |     |         // token holders on self-close exit (when requested or the redeemed amount is less than 1 lot).
 35 |     |         uint256 buyFAssetByAgentFactorBIPS;
 36 |     |         // The minimum collateral ratio above which a staker can exit the pool
 37 |     |         // (this is CR that must be left after exit).
 38 |     |         // Must be higher than system minimum collateral ratio for pool collateral.
 39 |     |         uint256 poolExitCollateralRatioBIPS;
 40 |     |         // The redemption fee share paid to the pool (as FAssets).
 41 |     |         // In redemption dominated situations (when agent requests return from core vault to earn
 42 |     |         // from redemption fees), pool can get some share to make it sustainable for pool users.
 43 |     |         // NOTE: the pool fee share is locked at the redemption request time, but is charged at the redemption
 44 |     |         // confirmation time. If agent uses all the redemption fee for transaction fees, this could make the
 45 |     |         // agent's free underlying balance negative.
 46 |     |         uint256 redemptionPoolFeeShareBIPS;
 47 |     |     }
 48 |     | }
 49 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/data/AssetManagerSettings.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | library AssetManagerSettings {
   5 |     |     struct Data {
   6 |     |         // Required contracts.
   7 |     |         // Only used to verify that calls come from assetManagerController.
   8 |     |         // Type: AssetManagerController
   9 |     |         // changed via address updater
  10 |     |         address assetManagerController;
  11 |     |         // The f-asset contract managed by this asset manager.
  12 |     |         // Type: IIFAsset
  13 |     |         // immutable
  14 |     |         address fAsset;
  15 |     |         // Factory for creating new agent vaults.
  16 |     |         // Type: IIAgentVaultFactory
  17 |     |         // timelocked
  18 |     |         address agentVaultFactory;
  19 |     |         // Factory for creating new agent collateral pools.
  20 |     |         // Type: IICollateralPoolFactory
  21 |     |         // timelocked
  22 |     |         address collateralPoolFactory;
  23 |     |         // Factory for creating new agent collateral pool tokens.
  24 |     |         // Type: IICollateralPoolTokenFactory
  25 |     |         // timelocked
  26 |     |         address collateralPoolTokenFactory;
  27 |     |         // The suffix to pool token name and symbol that identifies new vault's collateral pool token.
  28 |     |         // When vault is created, the owner passes own suffix which will be appended to this.
  29 |     |         string poolTokenSuffix;
  30 |     |         // If set, the whitelist contains a list of accounts that can call public methods
  31 |     |         // (minting, redeeming, challenging, etc.)
  32 |     |         // This can be `address(0)`, in which case no whitelist checks are done.
  33 |     |         // Type: IWhitelist
  34 |     |         // timelocked
  35 |     |         address __whitelist; // only storage placeholder
  36 |     |         // If set, the owner address registry contains a list of allowed agent owner's
  37 |     |         // management addresses and mappings from management to work address.
  38 |     |         // Type: IAgentOwnerRegistry
  39 |     |         // timelocked
  40 |     |         address agentOwnerRegistry;
  41 |     |         // Attestation client verifies and decodes attestation proofs.
  42 |     |         // Type: IFdcVerification
  43 |     |         // changed via address updater
  44 |     |         address fdcVerification;
  45 |     |         // The address where burned NAT is sent.
  46 |     |         // immutable
  47 |     |         address payable burnAddress;
  48 |     |         // The contract that reads prices from FTSO system in an FTSO version independent way.
  49 |     |         // Type: IPriceReader
  50 |     |         // timelocked
  51 |     |         address priceReader;
  52 |     |         // Same as assetToken.decimals()
  53 |     |         // immutable
  54 |     |         uint8 assetDecimals;
  55 |     |         // Number of decimals of precision of minted amounts.
  56 |     |         // assetMintingGranularityUBA = 10 ** (assetDecimals - assetMintingDecimals)
  57 |     |         // immutable
  58 |     |         uint8 assetMintingDecimals;
  59 |     |         // Must match attestation data chainId.
  60 |     |         // immutable
  61 |     |         bytes32 chainId;
  62 |     |         // Average time between two successive blocks on the underlying chain, in milliseconds.
  63 |     |         // rate-limited
  64 |     |         uint32 averageBlockTimeMS;
  65 |     |         // The minimum amount of pool tokens the agent must hold to be able to mint.
  66 |     |         // To be able to mint, the NAT value of all backed fassets together with new ones times this percentage
  67 |     |         // must be smaller than the agent's pool tokens' amount converted to NAT.
  68 |     |         // rate-limited
  69 |     |         uint32 mintingPoolHoldingsRequiredBIPS;
  70 |     |         // Collateral reservation fee that must be paid by the minter.
  71 |     |         // Payment is in NAT, but is proportional to the value of assets to be minted.
  72 |     |         // rate-limited
  73 |     |         uint16 collateralReservationFeeBIPS;
  74 |     |         // Asset unit value (e.g. 1 BTC or 1 ETH) in UBA = 10 ** assetToken.decimals()
  75 |     |         // immutable
  76 |     |         uint64 assetUnitUBA;
  77 |     |         // The granularity in which lots are measured = the value of AMG (asset minting granularity) in UBA.
  78 |     |         // Can only be changed via redeploy of AssetManager.
  79 |     |         // AMG is used internally instead of UBA so that minted quantities fit into 64bits to reduce storage.
  80 |     |         // So assetMintingGranularityUBA should be set so that the max supply in AMG of this currency
  81 |     |         // in foreseeable time (say 100yr) cannot overflow 64 bits.
  82 |     |         // immutable
  83 |     |         uint64 assetMintingGranularityUBA;
  84 |     |         // Lot size in asset minting granularity. May change, which affects subsequent mintings and redemptions.
  85 |     |         // timelocked
  86 |     |         uint64 lotSizeAMG;
  87 |     |         // The percentage of minted f-assets that the agent must hold in his underlying address.
  88 |     |         uint16 __minUnderlyingBackingBIPS; // only storage placeholder
  89 |     |         // for some chains (e.g. Ethereum) we require that agent proves that underlying address is an EOA address
  90 |     |         // this must be done by presenting a payment proof from that address
  91 |     |         // immutable
  92 |     |         bool __requireEOAAddressProof; // only storage placeholder
  93 |     |         // Maximum minted amount of the f-asset.
  94 |     |         // rate-limited
  95 |     |         uint64 mintingCapAMG;
  96 |     |         // Number of underlying blocks that the minter or agent is allowed to pay underlying value.
  97 |     |         // If payment not reported in that time, minting/redemption can be challenged and default action triggered.
  98 |     |         // CAREFUL: Count starts from the current proved block height, so the minters and agents should
  99 |     |         // make sure that current block height is fresh, otherwise they might not have enough time for payment.
 100 |     |         // timelocked
 101 |     |         uint64 underlyingBlocksForPayment;
 102 |     |         // Minimum time to allow agent to pay for redemption or minter to pay for minting.
 103 |     |         // This is useful for fast chains, when there can be more than one block per second.
 104 |     |         // Redemption/minting payment failure can be called only after underlyingSecondsForPayment have elapsed
 105 |     |         // on underlying chain.
 106 |     |         // CAREFUL: Count starts from the current proved block timestamp, so the minters and agents should
 107 |     |         // make sure that current block timestamp is fresh, otherwise they might not have enough time for payment.
 108 |     |         // This is partially mitigated by adding local duration since the last block height update to
 109 |     |         // the current underlying block timestamp.
 110 |     |         // timelocked
 111 |     |         uint64 underlyingSecondsForPayment;
 112 |     |         // Redemption fee in underlying currency base amount (UBA).
 113 |     |         // rate-limited
 114 |     |         uint16 redemptionFeeBIPS;
 115 |     |         // On redemption underlying payment failure, redeemer is compensated with
 116 |     |         // redemption value recalculated in flare/sgb times redemption failure factor.
 117 |     |         // Expressed in BIPS, e.g. 12000 for factor of 1.2.
 118 |     |         // This is the part of factor paid from agent's vault collateral.
 119 |     |         // rate-limited
 120 |     |         uint32 redemptionDefaultFactorVaultCollateralBIPS;
 121 |     |         // This is the part of redemption factor paid from agent's pool collateral.
 122 |     |         // rate-limited
 123 |     |         uint32 __redemptionDefaultFactorPoolBIPS; // only storage placeholder
 124 |     |         // If the agent or redeemer becomes unresponsive, we still need payment or non-payment confirmations
 125 |     |         // to be presented eventually to properly track agent's underlying balance.
 126 |     |         // Therefore we allow anybody to confirm payments/non-payments this many seconds after request was made.
 127 |     |         // rate-limited
 128 |     |         uint64 confirmationByOthersAfterSeconds;
 129 |     |         // The user who makes abandoned redemption confirmations gets rewarded by the following amount.
 130 |     |         // rate-limited
 131 |     |         uint128 confirmationByOthersRewardUSD5;
 132 |     |         // To prevent unbounded work, the number of tickets redeemed in a single request is limited.
 133 |     |         // rate-limited
 134 |     |         // >= 1
 135 |     |         uint16 maxRedeemedTickets;
 136 |     |         // Challenge reward can be composed of two part - fixed and proportional (any of them can be zero).
 137 |     |         // This is the proportional part (in BIPS).
 138 |     |         // rate-limited
 139 |     |         uint16 paymentChallengeRewardBIPS;
 140 |     |         // Challenge reward can be composed of two part - fixed and proportional (any of them can be zero).
 141 |     |         // This is the fixed part (in vault collateral token wei).
 142 |     |         // rate-limited
 143 |     |         uint128 paymentChallengeRewardUSD5;
 144 |     |         // Agent has to announce any collateral withdrawal ar vault destroy and then wait for at least
 145 |     |         // withdrawalWaitMinSeconds. This prevents challenged agent to remove all collateral before
 146 |     |         // challenge can be proved.
 147 |     |         // rate-limited
 148 |     |         uint64 withdrawalWaitMinSeconds;
 149 |     |         // Maximum age that trusted price feed is valid.
 150 |     |         // Otherwise (if there were no trusted votes for that long) just use generic ftso price feed.
 151 |     |         // rate-limited
 152 |     |         uint64 maxTrustedPriceAgeSeconds;
 153 |     |         // Agent can remain in CCB for this much time, after that liquidation starts automatically.
 154 |     |         // rate-limited
 155 |     |         uint64 __ccbTimeSeconds; // only storage placeholder
 156 |     |         // Amount of seconds (typically 1 day) that the payment/non-payment proofs must be available.
 157 |     |         // This setting is used in `unstickMinting` and `finishRedemptionWithoutPayment` to prove that the time when
 158 |     |         // payment/non-payment could be proved has already passed.
 159 |     |         // rate-limited
 160 |     |         uint64 attestationWindowSeconds;
 161 |     |         // Minimum time after an update of a setting before the same setting can be updated again.
 162 |     |         // timelocked
 163 |     |         uint64 minUpdateRepeatTimeSeconds;
 164 |     |         // Ratio at which the agents can buy back their collateral when f-asset is terminated.
 165 |     |         // Typically a bit more than 1 to incentivize agents to buy f-assets and self-close instead.
 166 |     |         // immutable
 167 |     |         uint64 __buybackCollateralFactorBIPS; // only storage placeholder
 168 |     |         // Minimum time that has to pass between underlying withdrawal announcement and the confirmation.
 169 |     |         // Any value is ok, but higher values give more security against multiple announcement attack by a miner.
 170 |     |         // Shouldn't be much bigger than Flare data connector response time, so that payments can be confirmed without
 171 |     |         // extra wait. Should be smaller than confirmationByOthersAfterSeconds (e.g. less than 1 hour).
 172 |     |         // rate-limited
 173 |     |         uint64 __announcedUnderlyingConfirmationMinSeconds; // only storage placeholder
 174 |     |         // Minimum time from the moment token is deprecated to when it becomes invalid and agents still using
 175 |     |         // it as vault collateral get liquidated.
 176 |     |         // timelocked
 177 |     |         uint64 __tokenInvalidationTimeMinSeconds; // only storage placeholder
 178 |     |         // On some rare occasions (stuck minting), the agent has to unlock collateral.
 179 |     |         // For this, part of collateral corresponding to FTSO asset value is burned and the rest is released.
 180 |     |         // However, we cannot burn typical vault collateral (stablecoins), so the agent must buy them for NAT
 181 |     |         // at FTSO price multiplied with this factor (should be a bit above 1) and then we burn the NATs.
 182 |     |         // timelocked
 183 |     |         uint32 vaultCollateralBuyForFlareFactorBIPS;
 184 |     |         // Amount of seconds that have to pass between available list exit announcement and execution.
 185 |     |         // rate-limited
 186 |     |         uint64 agentExitAvailableTimelockSeconds;
 187 |     |         // Amount of seconds that have to pass between agent fee and pool fee share change announcement and execution.
 188 |     |         // rate-limited
 189 |     |         uint64 agentFeeChangeTimelockSeconds;
 190 |     |         // Amount of seconds that have to pass between agent-set minting collateral ratio (vault or pool)
 191 |     |         // change announcement and execution.
 192 |     |         // rate-limited
 193 |     |         uint64 agentMintingCRChangeTimelockSeconds;
 194 |     |         // Amount of seconds that have to pass between agent-set settings for pool exit collateral ratio
 195 |     |         // change announcement and execution.
 196 |     |         // rate-limited
 197 |     |         uint64 poolExitCRChangeTimelockSeconds;
 198 |     |         // Amount of seconds that an agent is allowed to execute an update once it is allowed.
 199 |     |         // rate-limited
 200 |     |         uint64 agentTimelockedOperationWindowSeconds;
 201 |     |         // duration of the timelock for collateral pool tokens after minting
 202 |     |         uint32 collateralPoolTokenTimelockSeconds;
 203 |     |         // If there was no liquidator for the current liquidation offer,
 204 |     |         // go to the next step of liquidation after a certain period of time.
 205 |     |         // rate-limited
 206 |     |         uint64 liquidationStepSeconds;
 207 |     |         // Factor with which to multiply the asset price in native currency to obtain the payment
 208 |     |         // to the liquidator.
 209 |     |         // Expressed in BIPS, e.g. [12000, 16000, 20000] means that the liquidator will be paid 1.2, 1.6 and 2.0
 210 |     |         // times the market price of the liquidated assets after each `liquidationStepSeconds`.
 211 |     |         // Values in the array must increase and be greater than 100%.
 212 |     |         // rate-limited
 213 |     |         uint256[] liquidationCollateralFactorBIPS;
 214 |     |         // How much of the liquidation is paid in vault collateral.
 215 |     |         // The remainder will be paid in pool NAT collateral.
 216 |     |         uint256[] liquidationFactorVaultCollateralBIPS;
 217 |     |         // Minimum time that the system must wait before performing diamond cut.
 218 |     |         // The actual timelock is the maximum of this setting and GovernanceSettings.timelock.
 219 |     |         uint64 diamondCutMinTimelockSeconds;
 220 |     |         // The maximum total pause that can be triggered by non-governance (but governance allowed) caller.
 221 |     |         // The duration count can be reset by the governance.
 222 |     |         uint64 maxEmergencyPauseDurationSeconds;
 223 |     |         // The amount of time since last emergency pause after which the total pause duration counter
 224 |     |         // will reset automatically.
 225 |     |         uint64 emergencyPauseDurationResetAfterSeconds;
 226 |     |         // The amount of time after which the collateral reservation can be cancelled if the
 227 |     |         // handshake is not completed.
 228 |     |         // rate-limited
 229 |     |         uint64 __cancelCollateralReservationAfterSeconds; // only storage placeholder
 230 |     |         // The amount of collateral reservation fee returned to the minter in case of rejection or cancellation.
 231 |     |         // Expressed in BIPS, e.g. 9500 for factor of 0.95, max 10000 for factor of 1.0.
 232 |     |         // rate-limited
 233 |     |         uint16 __rejectOrCancelCollateralReservationReturnFactorBIPS; // only storage placeholder
 234 |     |         // Time window inside which the agent can reject the redemption request.
 235 |     |         // rate-limited
 236 |     |         uint64 __rejectRedemptionRequestWindowSeconds; // only storage placeholder
 237 |     |         // Time window inside which the agent can take over the redemption request from another agent
 238 |     |         // that has rejected it.
 239 |     |         // rate-limited
 240 |     |         uint64 __takeOverRedemptionRequestWindowSeconds; // only storage placeholder
 241 |     |         // On redemption rejection, without take over, redeemer is compensated with
 242 |     |         // redemption value recalculated in flare/sgb times redemption failure factor.
 243 |     |         // Expressed in BIPS, e.g. 12000 for factor of 1.2.
 244 |     |         // This is the part of factor paid from agent's vault collateral.
 245 |     |         // rate-limited
 246 |     |         uint32 __rejectedRedemptionDefaultFactorVaultCollateralBIPS; // only storage placeholder
 247 |     |         // This is the part of rejected redemption factor paid from agent's pool collateral.
 248 |     |         // rate-limited
 249 |     |         uint32 __rejectedRedemptionDefaultFactorPoolBIPS; // only storage placeholder
 250 |     |     }
 251 |     | }
 252 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/data/AvailableAgentInfo.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import {AgentInfo} from "./AgentInfo.sol";
  5 |     | 
  6 |     | library AvailableAgentInfo {
  7 |     |     struct Data {
  8 |     |         // Agent vault address.
  9 |     |         address agentVault;
 10 |     |         // The management address of the agent vault's owner.
 11 |     |         address ownerManagementAddress;
 12 |     |         // Agent's minting fee in BIPS.
 13 |     |         uint256 feeBIPS;
 14 |     |         // Minimum agent vault collateral ratio needed for minting.
 15 |     |         uint256 mintingVaultCollateralRatioBIPS;
 16 |     |         // Minimum pool collateral ratio needed for minting.
 17 |     |         uint256 mintingPoolCollateralRatioBIPS;
 18 |     |         // The number of lots that can be minted by this agent.
 19 |     |         // Note: the value is only informative since it can can change at any time
 20 |     |         // due to price changes, reservation, minting, redemption, or even lot size change.
 21 |     |         uint256 freeCollateralLots;
 22 |     |         // The agent status, as for getAgentInfo().
 23 |     |         AgentInfo.Status status;
 24 |     |     }
 25 |     | }
 26 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/data/CollateralReservationInfo.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | library CollateralReservationInfo {
  5 |     |     enum Status {
  6 |     |         ACTIVE, // the minting process hasn't finished yet
  7 |     |         SUCCESSFUL, // the payment has been confirmed and the FAssets minted
  8 |     |         DEFAULTED, // the payment has defaulted and the agent received the collateral reservation fee
  9 |     |         EXPIRED // the confirmation time has expired and the agent called unstickMinting
 10 |     |     }
 11 |     | 
 12 |     |     struct Data {
 13 |     |         // The id used for executing or defaulting the minting.
 14 |     |         uint64 collateralReservationId;
 15 |     |         // The agent vault whose collateral is reserved.
 16 |     |         address agentVault;
 17 |     |         // The minter address - the address that will receive the minted FAssets.
 18 |     |         address minter;
 19 |     |         // The agent's underlying address to which the underlying assets should be paid by the minter.
 20 |     |         string paymentAddress;
 21 |     |         // Payment reference that must be part of the agent's redemption payment.
 22 |     |         bytes32 paymentReference;
 23 |     |         // The amount of FAssets that the minter will receive. Always a whole number of lots.
 24 |     |         uint256 valueUBA;
 25 |     |         // The underlying fee. The total amount the minter has to deposit is `valueUBA + mintingFeeUBA`.
 26 |     |         // Part of the fee is minted as pool fee share and the rest becomes agent's free underlying.
 27 |     |         uint128 mintingFeeUBA;
 28 |     |         // The fee that was paid at the collateral reservation time.
 29 |     |         // Part of the fee is goes to the pool and the rest to the agent vault as WNAT.
 30 |     |         uint128 reservationFeeNatWei;
 31 |     |         // Proportion of the mintingFeeUBA and reservationFeeNatWei that belongs to the collateral pool.
 32 |     |         uint16 poolFeeShareBIPS;
 33 |     |         // The underlying block (approximate - as known by the asset manager) when the reservation occurred.
 34 |     |         uint64 firstUnderlyingBlock;
 35 |     |         // The last underlying block and timestamp for redemption payment. Redemption is defaulted if
 36 |     |         // there is no payment by the time BOTH lastUnderlyingBlock and lastUnderlyingTimestamp have passed.
 37 |     |         uint64 lastUnderlyingBlock;
 38 |     |         uint64 lastUnderlyingTimestamp;
 39 |     |         // The executor, optionally assigned by the minter to execute the minting.
 40 |     |         // (Only minter, agent or executor may execute the minting.)
 41 |     |         address executor;
 42 |     |         // The fee in NAT that the executor receives if they successfully execute the minting.
 43 |     |         uint256 executorFeeNatWei;
 44 |     |         // If the minting process has finished, indication of success/default. Otherwise ACTIVE.
 45 |     |         CollateralReservationInfo.Status status;
 46 |     |     }
 47 |     | }
 48 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/data/CollateralType.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  5 |     | 
  6 |     | library CollateralType {
  7 |     |     enum Class {
  8 |     |         NONE, // unused
  9 |     |         POOL, // pool collateral type
 10 |     |         VAULT // usable as vault collateral
 11 |     |     }
 12 |     | 
 13 |     |     // Collateral token is uniquely identified by the pair (collateralClass, token).
 14 |     |     struct Data {
 15 |     |         // The kind of collateral for this token.
 16 |     |         CollateralType.Class collateralClass;
 17 |     |         // The ERC20 token contract for this collateral type.
 18 |     |         IERC20 token;
 19 |     |         // Same as token.decimals(), when that exists.
 20 |     |         uint256 decimals;
 21 |     |         // Token invalidation time. Should always be 0 since token invalidation is deprecated.
 22 |     |         uint256 validUntil;
 23 |     |         // When `true`, the FTSO with symbol `assetFtsoSymbol` returns asset price relative to this token
 24 |     |         // (such FTSO's will probably exist for major stablecoins).
 25 |     |         // When `false`, the FTSOs with symbols `assetFtsoSymbol` and `tokenFtsoSymbol` give asset and token
 26 |     |         // price relative to the same reference currency and the asset/token price is calculated as their ratio.
 27 |     |         bool directPricePair;
 28 |     |         // FTSO symbol for the asset, relative to this token or a reference currency
 29 |     |         // (it depends on the value of `directPricePair`).
 30 |     |         string assetFtsoSymbol;
 31 |     |         // FTSO symbol for this token in reference currency.
 32 |     |         // Used for asset/token price calculation when `directPricePair` is `false`.
 33 |     |         // Otherwise it is irrelevant to asset/token price calculation, but if it is nonempty,
 34 |     |         // it is still used in calculation of challenger and confirmation rewards
 35 |     |         // (otherwise we assume it approximates the value of USD and pay directly the USD amount in vault collateral).
 36 |     |         string tokenFtsoSymbol;
 37 |     |         // Minimum collateral ratio for healthy agents.
 38 |     |         uint256 minCollateralRatioBIPS;
 39 |     |         // Minimum collateral ratio required to get agent out of liquidation.
 40 |     |         // Will always be greater than minCollateralRatioBIPS.
 41 |     |         uint256 safetyMinCollateralRatioBIPS;
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/data/EmergencyPause.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | library EmergencyPause {
  5 |     |     enum Level {
  6 |     |         // Pause is not active.
  7 |     |         NONE,
  8 |     |         // Prevent starting mint, redeem, liquidation and core vault transfer/return.
  9 |     |         START_OPERATIONS,
 10 |     |         // Everything from START_OPERATIONS, plus prevent finishing or defulating already started mints and redeems.
 11 |     |         FULL,
 12 |     |         // Everything from FULL, plus prevent FAsset transfers.
 13 |     |         FULL_AND_TRANSFER
 14 |     |     }
 15 |     | }
 16 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/data/RedemptionRequestInfo.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | library RedemptionRequestInfo {
  5 |     |     enum Status {
  6 |     |         ACTIVE, // waiting for confirmation/default
  7 |     |         DEFAULTED_UNCONFIRMED, // default called, failed or late payment can still be confirmed
  8 |     |         // final statuses - there can be no valid payment for this redemption anymore
  9 |     |         SUCCESSFUL, // successful payment confirmed
 10 |     |         DEFAULTED_FAILED, // payment failed   (default was paid)
 11 |     |         BLOCKED, // payment blocked
 12 |     |         REJECTED // redemption request rejected due to invalid redeemer's address
 13 |     |     }
 14 |     | 
 15 |     |     struct Data {
 16 |     |         // The id used for confirming or defaulting the request.
 17 |     |         uint64 redemptionRequestId;
 18 |     |         // Redemption status. Note that on payment confirmation the request is deleted, so there is no success status.
 19 |     |         RedemptionRequestInfo.Status status;
 20 |     |         // The redeemed agent vault.
 21 |     |         address agentVault;
 22 |     |         // Native redeemer address - the address that receives collateral in case of default.
 23 |     |         address redeemer;
 24 |     |         // The underlying address to which the redeemed assets should be paid by the agent.
 25 |     |         string paymentAddress;
 26 |     |         // Payment reference that must be part of the agent's redemption payment.
 27 |     |         bytes32 paymentReference;
 28 |     |         // The amount of the FAsset the redeemer has burned. Note that this is not the amount of underlying
 29 |     |         // the redeemer will receive - the redemption payment amount is this minus the underlyingFeeUBA.
 30 |     |         uint128 valueUBA;
 31 |     |         // The redemption fee that remain on agent's underlying address.
 32 |     |         // Part of it will be reminted as pool fee share and the rest becomes the agent's free underlying.
 33 |     |         uint128 feeUBA;
 34 |     |         // Proportional part of the underlyingFeeUBA that is re-minted on successful redemption
 35 |     |         // and goes to the collateral pool.
 36 |     |         uint16 poolFeeShareBIPS;
 37 |     |         // The underlying block (approximate - as known by the asset manager) when the request occurred.
 38 |     |         uint64 firstUnderlyingBlock;
 39 |     |         // The last underlying block and timestamp for redemption payment. Redemption is defaulted if
 40 |     |         // there is no payment by the time BOTH lastUnderlyingBlock and lastUnderlyingTimestamp have passed.
 41 |     |         uint64 lastUnderlyingBlock;
 42 |     |         uint64 lastUnderlyingTimestamp;
 43 |     |         // The native (Flare/Songbird) chain timestamp when the request occurred.
 44 |     |         uint64 timestamp;
 45 |     |         // True if redemption was created by a selfCloseExit on the collateral pool.
 46 |     |         bool poolSelfClose;
 47 |     |         // True if redemption was initiated by an agent for transfer to core vault.
 48 |     |         bool transferToCoreVault;
 49 |     |         // The executor, optionally assigned by the redeemer to execute the default if needed.
 50 |     |         // (Only redeemer, agent or executor may execute the default.)
 51 |     |         address executor;
 52 |     |         // The fee in NAT that the executor receives if they successfully call default.
 53 |     |         uint256 executorFeeNatWei;
 54 |     |     }
 55 |     | }
 56 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/data/RedemptionTicketInfo.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | library RedemptionTicketInfo {
  5 |     |     struct Data {
  6 |     |         // The id of the ticket, same as returned in RedemptionTicketCreated/Updated/Deleted events.
  7 |     |         uint256 redemptionTicketId;
  8 |     |         // Backing agent vault address.
  9 |     |         address agentVault;
 10 |     |         // The amount of FAsset on the ticket.
 11 |     |         uint256 ticketValueUBA;
 12 |     |     }
 13 |     | }
 14 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/diamond/interfaces/IDiamondLoupe.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /******************************************************************************\
  5 |     | * Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)
  6 |     | * EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535
  7 |     | /******************************************************************************/
  8 |     | 
  9 |     | // A loupe is a small magnifying glass used to look at diamonds.
 10 |     | // These functions look at diamonds
 11 |     | interface IDiamondLoupe {
 12 |     |     /// These functions are expected to be called frequently
 13 |     |     /// by tools.
 14 |     | 
 15 |     |     struct Facet {
 16 |     |         address facetAddress;
 17 |     |         bytes4[] functionSelectors;
 18 |     |     }
 19 |     | 
 20 |     |     /// @notice Gets all facet addresses and their four byte function selectors.
 21 |     |     /// @return facets_ Facet
 22 |     |     function facets() external view returns (Facet[] memory facets_);
 23 |     | 
 24 |     |     /// @notice Gets all the function selectors supported by a specific facet.
 25 |     |     /// @param _facet The facet address.
 26 |     |     /// @return facetFunctionSelectors_
 27 |     |     function facetFunctionSelectors(
 28 |     |         address _facet
 29 |     |     ) external view returns (bytes4[] memory facetFunctionSelectors_);
 30 |     | 
 31 |     |     /// @notice Get all the facet addresses used by a diamond.
 32 |     |     /// @return facetAddresses_
 33 |     |     function facetAddresses()
 34 |     |         external
 35 |     |         view
 36 |     |         returns (address[] memory facetAddresses_);
 37 |     | 
 38 |     |     /// @notice Gets the facet that supports the given selector.
 39 |     |     /// @dev If facet is not found return address(0).
 40 |     |     /// @param _functionSelector The function selector.
 41 |     |     /// @return facetAddress_ The facet address.
 42 |     |     function facetAddress(
 43 |     |         bytes4 _functionSelector
 44 |     |     ) external view returns (address facetAddress_);
 45 |     | }
 46 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/ftso/interfaces/IIFtso.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | import "../../genesis/interfaces/IFtsoGenesis.sol";
   5 |     | import "../../IFtso.sol";
   6 |     | import "../../token/interfaces/IIVPToken.sol";
   7 |     | 
   8 |     | interface IIFtso is IFtso, IFtsoGenesis {
   9 |     |     /// function finalizePriceReveal
  10 |     |     /// called by reward manager only on correct timing.
  11 |     |     /// if price reveal period for epoch x ended. finalize.
  12 |     |     /// iterate list of price submissions
  13 |     |     /// find weighted median
  14 |     |     /// find adjucant 50% of price submissions.
  15 |     |     /// Allocate reward for any price submission which is same as a "winning" submission
  16 |     |     function finalizePriceEpoch(
  17 |     |         uint256 _epochId,
  18 |     |         bool _returnRewardData
  19 |     |     )
  20 |     |         external
  21 |     |         returns (
  22 |     |             address[] memory _eligibleAddresses,
  23 |     |             uint256[] memory _natWeights,
  24 |     |             uint256 _totalNatWeight
  25 |     |         );
  26 |     | 
  27 |     |     function fallbackFinalizePriceEpoch(uint256 _epochId) external;
  28 |     | 
  29 |     |     function forceFinalizePriceEpoch(uint256 _epochId) external;
  30 |     | 
  31 |     |     // activateFtso will be called by ftso manager once ftso is added
  32 |     |     // before this is done, FTSO can't run
  33 |     |     function activateFtso(
  34 |     |         uint256 _firstEpochStartTs,
  35 |     |         uint256 _submitPeriodSeconds,
  36 |     |         uint256 _revealPeriodSeconds
  37 |     |     ) external;
  38 |     | 
  39 |     |     function deactivateFtso() external;
  40 |     | 
  41 |     |     // update initial price and timestamp - only if not active
  42 |     |     function updateInitialPrice(
  43 |     |         uint256 _initialPriceUSD,
  44 |     |         uint256 _initialPriceTimestamp
  45 |     |     ) external;
  46 |     | 
  47 |     |     function configureEpochs(
  48 |     |         uint256 _maxVotePowerNatThresholdFraction,
  49 |     |         uint256 _maxVotePowerAssetThresholdFraction,
  50 |     |         uint256 _lowAssetUSDThreshold,
  51 |     |         uint256 _highAssetUSDThreshold,
  52 |     |         uint256 _highAssetTurnoutThresholdBIPS,
  53 |     |         uint256 _lowNatTurnoutThresholdBIPS,
  54 |     |         uint256 _elasticBandRewardBIPS,
  55 |     |         uint256 _elasticBandWidthPPM,
  56 |     |         address[] memory _trustedAddresses
  57 |     |     ) external;
  58 |     | 
  59 |     |     function setAsset(IIVPToken _asset) external;
  60 |     | 
  61 |     |     function setAssetFtsos(IIFtso[] memory _assetFtsos) external;
  62 |     | 
  63 |     |     // current vote power block will update per reward epoch.
  64 |     |     // the FTSO doesn't have notion of reward epochs.
  65 |     |     // reward manager only can set this data.
  66 |     |     function setVotePowerBlock(uint256 _blockNumber) external;
  67 |     | 
  68 |     |     function initializeCurrentEpochStateForReveal(
  69 |     |         uint256 _circulatingSupplyNat,
  70 |     |         bool _fallbackMode
  71 |     |     ) external;
  72 |     | 
  73 |     |     /**
  74 |     |      * @notice Returns ftso manager address
  75 |     |      */
  76 |     |     function ftsoManager() external view returns (address);
  77 |     | 
  78 |     |     /**
  79 |     |      * @notice Returns the FTSO asset
  80 |     |      * @dev Asset is null in case of multi-asset FTSO
  81 |     |      */
  82 |     |     function getAsset() external view returns (IIVPToken);
  83 |     | 
  84 |     |     /**
  85 |     |      * @notice Returns the Asset FTSOs
  86 |     |      * @dev AssetFtsos is not null only in case of multi-asset FTSO
  87 |     |      */
  88 |     |     function getAssetFtsos() external view returns (IIFtso[] memory);
  89 |     | 
  90 |     |     /**
  91 |     |      * @notice Returns current configuration of epoch state
  92 |     |      * @return _maxVotePowerNatThresholdFraction        High threshold for native token vote power per voter
  93 |     |      * @return _maxVotePowerAssetThresholdFraction      High threshold for asset vote power per voter
  94 |     |      * @return _lowAssetUSDThreshold            Threshold for low asset vote power
  95 |     |      * @return _highAssetUSDThreshold           Threshold for high asset vote power
  96 |     |      * @return _highAssetTurnoutThresholdBIPS   Threshold for high asset turnout
  97 |     |      * @return _lowNatTurnoutThresholdBIPS      Threshold for low nat turnout
  98 |     |      * @return _elasticBandRewardBIPS           Hybrid reward band, where _elasticBandRewardBIPS goes to the 
  99 |     |         elastic band (prices within _elasticBandWidthPPM of the median) 
 100 |     |         and 10000 - elasticBandRewardBIPS to the IQR 
 101 |     |      * @return _elasticBandWidthPPM             Prices within _elasticBandWidthPPM of median are rewarded
 102 |     |      * @return _trustedAddresses                Trusted addresses - use their prices if low nat turnout is not achieved
 103 |     |      */
 104 |     |     function epochsConfiguration()
 105 |     |         external
 106 |     |         view
 107 |     |         returns (
 108 |     |             uint256 _maxVotePowerNatThresholdFraction,
 109 |     |             uint256 _maxVotePowerAssetThresholdFraction,
 110 |     |             uint256 _lowAssetUSDThreshold,
 111 |     |             uint256 _highAssetUSDThreshold,
 112 |     |             uint256 _highAssetTurnoutThresholdBIPS,
 113 |     |             uint256 _lowNatTurnoutThresholdBIPS,
 114 |     |             uint256 _elasticBandRewardBIPS,
 115 |     |             uint256 _elasticBandWidthPPM,
 116 |     |             address[] memory _trustedAddresses
 117 |     |         );
 118 |     | 
 119 |     |     /**
 120 |     |      * @notice Returns parameters necessary for approximately replicating vote weighting.
 121 |     |      * @return _assets                  the list of Assets that are accounted in vote
 122 |     |      * @return _assetMultipliers        weight of each asset in (multiasset) ftso, mutiplied by TERA
 123 |     |      * @return _totalVotePowerNat       total native token vote power at block
 124 |     |      * @return _totalVotePowerAsset     total combined asset vote power at block
 125 |     |      * @return _assetWeightRatio        ratio of combined asset vp vs. native token vp (in BIPS)
 126 |     |      * @return _votePowerBlock          vote powewr block for given epoch
 127 |     |      */
 128 |     |     function getVoteWeightingParameters()
 129 |     |         external
 130 |     |         view
 131 |     |         returns (
 132 |     |             IIVPToken[] memory _assets,
 133 |     |             uint256[] memory _assetMultipliers,
 134 |     |             uint256 _totalVotePowerNat,
 135 |     |             uint256 _totalVotePowerAsset,
 136 |     |             uint256 _assetWeightRatio,
 137 |     |             uint256 _votePowerBlock
 138 |     |         );
 139 |     | 
 140 |     |     function wNat() external view returns (IIVPToken);
 141 |     | }
 142 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/genesis/interfaces/IFtsoGenesis.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | interface IFtsoGenesis {
  5 |     |     /**
  6 |     |      * @notice Reveals submitted price during epoch reveal period - only price submitter
  7 |     |      * @param _voter                Voter address
  8 |     |      * @param _epochId              Id of the epoch in which the price hash was submitted
  9 |     |      * @param _price                Submitted price in USD
 10 |     |      * @notice The hash of _price and _random must be equal to the submitted hash
 11 |     |      * @notice Emits PriceRevealed event
 12 |     |      */
 13 |     |     function revealPriceSubmitter(
 14 |     |         address _voter,
 15 |     |         uint256 _epochId,
 16 |     |         uint256 _price,
 17 |     |         uint256 _wNatVP
 18 |     |     ) external;
 19 |     | 
 20 |     |     /**
 21 |     |      * @notice Get (and cache) wNat vote power for specified voter and given epoch id
 22 |     |      * @param _voter                Voter address
 23 |     |      * @param _epochId              Id of the epoch in which the price hash was submitted
 24 |     |      * @return wNat vote power
 25 |     |      */
 26 |     |     function wNatVotePowerCached(
 27 |     |         address _voter,
 28 |     |         uint256 _epochId
 29 |     |     ) external returns (uint256);
 30 |     | }
 31 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/genesis/interfaces/IFtsoManagerGenesis.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | interface IFtsoManagerGenesis {
  5 |     |     function getCurrentPriceEpochId()
  6 |     |         external
  7 |     |         view
  8 |     |         returns (uint256 _priceEpochId);
  9 |     | }
 10 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/genesis/interfaces/IFtsoRegistryGenesis.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "./IFtsoGenesis.sol";
  5 |     | 
  6 |     | interface IFtsoRegistryGenesis {
  7 |     |     function getFtsos(
  8 |     |         uint256[] memory _indices
  9 |     |     ) external view returns (IFtsoGenesis[] memory _ftsos);
 10 |     | }
 11 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/token/interfaces/IICleanable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | interface IICleanable {
  5 |     |     /**
  6 |     |      * Set the contract that is allowed to call history cleaning methods.
  7 |     |      */
  8 |     |     function setCleanerContract(address _cleanerContract) external;
  9 |     | 
 10 |     |     /**
 11 |     |      * Set the cleanup block number.
 12 |     |      * Historic data for the blocks before `cleanupBlockNumber` can be erased,
 13 |     |      * history before that block should never be used since it can be inconsistent.
 14 |     |      * In particular, cleanup block number must be before current vote power block.
 15 |     |      * @param _blockNumber The new cleanup block number.
 16 |     |      */
 17 |     |     function setCleanupBlockNumber(uint256 _blockNumber) external;
 18 |     | 
 19 |     |     /**
 20 |     |      * Get the current cleanup block number.
 21 |     |      */
 22 |     |     function cleanupBlockNumber() external view returns (uint256);
 23 |     | }
 24 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/token/interfaces/IIGovernanceVotePower.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "../../IVPToken.sol";
  5 |     | import "../../IPChainStakeMirror.sol";
  6 |     | import "../../IGovernanceVotePower.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * Internal interface for contracts delegating their governance vote power.
 10 |     |  */
 11 |     | interface IIGovernanceVotePower is IGovernanceVotePower {
 12 |     |     /**
 13 |     |      * Emitted when a delegate's vote power changes, as a result of a new delegation
 14 |     |      * or a token transfer, for example.
 15 |     |      *
 16 |     |      * The event is always emitted from a `GovernanceVotePower` contract.
 17 |     |      * @param delegate The account receiving the changing delegated vote power.
 18 |     |      * @param previousBalance Delegated vote power before the change.
 19 |     |      * @param newBalance Delegated vote power after the change.
 20 |     |      */
 21 |     |     event DelegateVotesChanged(
 22 |     |         address indexed delegate,
 23 |     |         uint256 previousBalance,
 24 |     |         uint256 newBalance
 25 |     |     );
 26 |     | 
 27 |     |     /**
 28 |     |      * Emitted when an account starts delegating vote power or switches its delegation
 29 |     |      * to another address.
 30 |     |      *
 31 |     |      * The event is always emitted from a `GovernanceVotePower` contract.
 32 |     |      * @param delegator Account delegating its vote power.
 33 |     |      * @param fromDelegate Account receiving the delegation before the change.
 34 |     |      * Can be address(0) if there was no previous delegation.
 35 |     |      * @param toDelegate Account receiving the delegation after the change.
 36 |     |      * Can be address(0) if `delegator` just undelegated all its vote power.
 37 |     |      */
 38 |     |     event DelegateChanged(
 39 |     |         address indexed delegator,
 40 |     |         address indexed fromDelegate,
 41 |     |         address indexed toDelegate
 42 |     |     );
 43 |     | 
 44 |     |     /**
 45 |     |      * Update governance vote power of all involved delegates after tokens are transferred.
 46 |     |      *
 47 |     |      * This function **MUST** be called after each governance token transfer for the
 48 |     |      * delegates to reflect the correct balance.
 49 |     |      * @param _from Source address of the transfer.
 50 |     |      * @param _to Destination address of the transfer.
 51 |     |      * @param _fromBalance _Ignored._
 52 |     |      * @param _toBalance _Ignored._
 53 |     |      * @param _amount Amount being transferred.
 54 |     |      */
 55 |     |     function updateAtTokenTransfer(
 56 |     |         address _from,
 57 |     |         address _to,
 58 |     |         uint256 _fromBalance,
 59 |     |         uint256 _toBalance,
 60 |     |         uint256 _amount
 61 |     |     ) external;
 62 |     | 
 63 |     |     /**
 64 |     |      * Set the cleanup block number.
 65 |     |      * Historic data for the blocks before `cleanupBlockNumber` can be erased.
 66 |     |      * History before that block should never be used since it can be inconsistent.
 67 |     |      * In particular, cleanup block number must be lower than the current vote power block.
 68 |     |      * @param _blockNumber The new cleanup block number.
 69 |     |      */
 70 |     |     function setCleanupBlockNumber(uint256 _blockNumber) external;
 71 |     | 
 72 |     |     /**
 73 |     |      * Set the contract that is allowed to call history cleaning methods.
 74 |     |      * @param _cleanerContract Address of the cleanup contract.
 75 |     |      * Usually this will be an instance of `CleanupBlockNumberManager`.
 76 |     |      */
 77 |     |     function setCleanerContract(address _cleanerContract) external;
 78 |     | 
 79 |     |     /**
 80 |     |      * Get the token that this governance vote power contract belongs to.
 81 |     |      * @return The IVPToken interface owning this contract.
 82 |     |      */
 83 |     |     function ownerToken() external view returns (IVPToken);
 84 |     | 
 85 |     |     /**
 86 |     |      * Get the stake mirror contract that this governance vote power contract belongs to.
 87 |     |      * @return The IPChainStakeMirror interface owning this contract.
 88 |     |      */
 89 |     |     function pChainStakeMirror() external view returns (IPChainStakeMirror);
 90 |     | 
 91 |     |     /**
 92 |     |      * Get the current cleanup block number set with `setCleanupBlockNumber()`.
 93 |     |      * @return The currently set cleanup block number.
 94 |     |      */
 95 |     |     function getCleanupBlockNumber() external view returns (uint256);
 96 |     | }
 97 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/token/interfaces/IIVPContract.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.7.6 <0.9;
   3 |     | 
   4 |     | import "../../IVPToken.sol";
   5 |     | import "../../IVPContractEvents.sol";
   6 |     | import "./IICleanable.sol";
   7 |     | 
   8 |     | interface IIVPContract is IICleanable, IVPContractEvents {
   9 |     |     /**
  10 |     |      * Update vote powers when tokens are transfered.
  11 |     |      * Also update delegated vote powers for percentage delegation
  12 |     |      * and check for enough funds for explicit delegations.
  13 |     |      **/
  14 |     |     function updateAtTokenTransfer(
  15 |     |         address _from,
  16 |     |         address _to,
  17 |     |         uint256 _fromBalance,
  18 |     |         uint256 _toBalance,
  19 |     |         uint256 _amount
  20 |     |     ) external;
  21 |     | 
  22 |     |     /**
  23 |     |      * @notice Delegate `_bips` percentage of voting power to `_to` from `_from`
  24 |     |      * @param _from The address of the delegator
  25 |     |      * @param _to The address of the recipient
  26 |     |      * @param _balance The delegator's current balance
  27 |     |      * @param _bips The percentage of voting power to be delegated expressed in basis points (1/100 of one percent).
  28 |     |      *   Not cumulative - every call resets the delegation value (and value of 0 revokes delegation).
  29 |     |      **/
  30 |     |     function delegate(
  31 |     |         address _from,
  32 |     |         address _to,
  33 |     |         uint256 _balance,
  34 |     |         uint256 _bips
  35 |     |     ) external;
  36 |     | 
  37 |     |     /**
  38 |     |      * @notice Explicitly delegate `_amount` of voting power to `_to` from `msg.sender`.
  39 |     |      * @param _from The address of the delegator
  40 |     |      * @param _to The address of the recipient
  41 |     |      * @param _balance The delegator's current balance
  42 |     |      * @param _amount An explicit vote power amount to be delegated.
  43 |     |      *   Not cumulative - every call resets the delegation value (and value of 0 undelegates `to`).
  44 |     |      **/
  45 |     |     function delegateExplicit(
  46 |     |         address _from,
  47 |     |         address _to,
  48 |     |         uint256 _balance,
  49 |     |         uint _amount
  50 |     |     ) external;
  51 |     | 
  52 |     |     /**
  53 |     |      * @notice Revoke all delegation from sender to `_who` at given block.
  54 |     |      *    Only affects the reads via `votePowerOfAtCached()` in the block `_blockNumber`.
  55 |     |      *    Block `_blockNumber` must be in the past.
  56 |     |      *    This method should be used only to prevent rogue delegate voting in the current voting block.
  57 |     |      *    To stop delegating use delegate/delegateExplicit with value of 0 or undelegateAll/undelegateAllExplicit.
  58 |     |      * @param _from The address of the delegator
  59 |     |      * @param _who Address of the delegatee
  60 |     |      * @param _balance The delegator's current balance
  61 |     |      * @param _blockNumber The block number at which to revoke delegation.
  62 |     |      **/
  63 |     |     function revokeDelegationAt(
  64 |     |         address _from,
  65 |     |         address _who,
  66 |     |         uint256 _balance,
  67 |     |         uint _blockNumber
  68 |     |     ) external;
  69 |     | 
  70 |     |     /**
  71 |     |      * @notice Undelegate all voting power for delegates of `msg.sender`
  72 |     |      *    Can only be used with percentage delegation.
  73 |     |      *    Does not reset delegation mode back to NOTSET.
  74 |     |      * @param _from The address of the delegator
  75 |     |      **/
  76 |     |     function undelegateAll(address _from, uint256 _balance) external;
  77 |     | 
  78 |     |     /**
  79 |     |      * @notice Undelegate all explicit vote power by amount delegates for `msg.sender`.
  80 |     |      *    Can only be used with explicit delegation.
  81 |     |      *    Does not reset delegation mode back to NOTSET.
  82 |     |      * @param _from The address of the delegator
  83 |     |      * @param _delegateAddresses Explicit delegation does not store delegatees' addresses,
  84 |     |      *   so the caller must supply them.
  85 |     |      * @return The amount still delegated (in case the list of delegates was incomplete).
  86 |     |      */
  87 |     |     function undelegateAllExplicit(
  88 |     |         address _from,
  89 |     |         address[] memory _delegateAddresses
  90 |     |     ) external returns (uint256);
  91 |     | 
  92 |     |     /**
  93 |     |      * @notice Get the vote power of `_who` at block `_blockNumber`
  94 |     |      *   Reads/updates cache and upholds revocations.
  95 |     |      * @param _who The address to get voting power.
  96 |     |      * @param _blockNumber The block number at which to fetch.
  97 |     |      * @return Vote power of `_who` at `_blockNumber`.
  98 |     |      */
  99 |     |     function votePowerOfAtCached(
 100 |     |         address _who,
 101 |     |         uint256 _blockNumber
 102 |     |     ) external returns (uint256);
 103 |     | 
 104 |     |     /**
 105 |     |      * @notice Get the current vote power of `_who`.
 106 |     |      * @param _who The address to get voting power.
 107 |     |      * @return Current vote power of `_who`.
 108 |     |      */
 109 |     |     function votePowerOf(address _who) external view returns (uint256);
 110 |     | 
 111 |     |     /**
 112 |     |      * @notice Get the vote power of `_who` at block `_blockNumber`
 113 |     |      * @param _who The address to get voting power.
 114 |     |      * @param _blockNumber The block number at which to fetch.
 115 |     |      * @return Vote power of `_who` at `_blockNumber`.
 116 |     |      */
 117 |     |     function votePowerOfAt(
 118 |     |         address _who,
 119 |     |         uint256 _blockNumber
 120 |     |     ) external view returns (uint256);
 121 |     | 
 122 |     |     /**
 123 |     |      * @notice Get the vote power of `_who` at block `_blockNumber`, ignoring revocation information (and cache).
 124 |     |      * @param _who The address to get voting power.
 125 |     |      * @param _blockNumber The block number at which to fetch.
 126 |     |      * @return Vote power of `_who` at `_blockNumber`. Result doesn't change if vote power is revoked.
 127 |     |      */
 128 |     |     function votePowerOfAtIgnoringRevocation(
 129 |     |         address _who,
 130 |     |         uint256 _blockNumber
 131 |     |     ) external view returns (uint256);
 132 |     | 
 133 |     |     /**
 134 |     |      * Return vote powers for several addresses in a batch.
 135 |     |      * @param _owners The list of addresses to fetch vote power of.
 136 |     |      * @param _blockNumber The block number at which to fetch.
 137 |     |      * @return A list of vote powers.
 138 |     |      */
 139 |     |     function batchVotePowerOfAt(
 140 |     |         address[] memory _owners,
 141 |     |         uint256 _blockNumber
 142 |     |     ) external view returns (uint256[] memory);
 143 |     | 
 144 |     |     /**
 145 |     |      * @notice Get current delegated vote power `_from` delegator delegated `_to` delegatee.
 146 |     |      * @param _from Address of delegator
 147 |     |      * @param _to Address of delegatee
 148 |     |      * @param _balance The delegator's current balance
 149 |     |      * @return The delegated vote power.
 150 |     |      */
 151 |     |     function votePowerFromTo(
 152 |     |         address _from,
 153 |     |         address _to,
 154 |     |         uint256 _balance
 155 |     |     ) external view returns (uint256);
 156 |     | 
 157 |     |     /**
 158 |     |      * @notice Get delegated the vote power `_from` delegator delegated `_to` delegatee at `_blockNumber`.
 159 |     |      * @param _from Address of delegator
 160 |     |      * @param _to Address of delegatee
 161 |     |      * @param _balance The delegator's current balance
 162 |     |      * @param _blockNumber The block number at which to fetch.
 163 |     |      * @return The delegated vote power.
 164 |     |      */
 165 |     |     function votePowerFromToAt(
 166 |     |         address _from,
 167 |     |         address _to,
 168 |     |         uint256 _balance,
 169 |     |         uint _blockNumber
 170 |     |     ) external view returns (uint256);
 171 |     | 
 172 |     |     /**
 173 |     |      * @notice Compute the current undelegated vote power of `_owner`
 174 |     |      * @param _owner The address to get undelegated voting power.
 175 |     |      * @param _balance Owner's current balance
 176 |     |      * @return The unallocated vote power of `_owner`
 177 |     |      */
 178 |     |     function undelegatedVotePowerOf(
 179 |     |         address _owner,
 180 |     |         uint256 _balance
 181 |     |     ) external view returns (uint256);
 182 |     | 
 183 |     |     /**
 184 |     |      * @notice Get the undelegated vote power of `_owner` at given block.
 185 |     |      * @param _owner The address to get undelegated voting power.
 186 |     |      * @param _blockNumber The block number at which to fetch.
 187 |     |      * @return The undelegated vote power of `_owner` (= owner's own balance minus all delegations from owner)
 188 |     |      */
 189 |     |     function undelegatedVotePowerOfAt(
 190 |     |         address _owner,
 191 |     |         uint256 _balance,
 192 |     |         uint256 _blockNumber
 193 |     |     ) external view returns (uint256);
 194 |     | 
 195 |     |     /**
 196 |     |      * @notice Get the delegation mode for '_who'. This mode determines whether vote power is
 197 |     |      *  allocated by percentage or by explicit value.
 198 |     |      * @param _who The address to get delegation mode.
 199 |     |      * @return Delegation mode (NOTSET=0, PERCENTAGE=1, AMOUNT=2))
 200 |     |      */
 201 |     |     function delegationModeOf(address _who) external view returns (uint256);
 202 |     | 
 203 |     |     /**
 204 |     |      * @notice Get the vote power delegation `_delegateAddresses`
 205 |     |      *  and `pcts` of an `_owner`. Returned in two separate positional arrays.
 206 |     |      * @param _owner The address to get delegations.
 207 |     |      * @return _delegateAddresses Positional array of delegation addresses.
 208 |     |      * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)
 209 |     |      * @return _count The number of delegates.
 210 |     |      * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).
 211 |     |      */
 212 |     |     function delegatesOf(
 213 |     |         address _owner
 214 |     |     )
 215 |     |         external
 216 |     |         view
 217 |     |         returns (
 218 |     |             address[] memory _delegateAddresses,
 219 |     |             uint256[] memory _bips,
 220 |     |             uint256 _count,
 221 |     |             uint256 _delegationMode
 222 |     |         );
 223 |     | 
 224 |     |     /**
 225 |     |      * @notice Get the vote power delegation `delegationAddresses`
 226 |     |      *  and `pcts` of an `_owner`. Returned in two separate positional arrays.
 227 |     |      * @param _owner The address to get delegations.
 228 |     |      * @param _blockNumber The block for which we want to know the delegations.
 229 |     |      * @return _delegateAddresses Positional array of delegation addresses.
 230 |     |      * @return _bips Positional array of delegation percents specified in basis points (1/100 or 1 percent)
 231 |     |      * @return _count The number of delegates.
 232 |     |      * @return _delegationMode The mode of the delegation (NOTSET=0, PERCENTAGE=1, AMOUNT=2).
 233 |     |      */
 234 |     |     function delegatesOfAt(
 235 |     |         address _owner,
 236 |     |         uint256 _blockNumber
 237 |     |     )
 238 |     |         external
 239 |     |         view
 240 |     |         returns (
 241 |     |             address[] memory _delegateAddresses,
 242 |     |             uint256[] memory _bips,
 243 |     |             uint256 _count,
 244 |     |             uint256 _delegationMode
 245 |     |         );
 246 |     | 
 247 |     |     /**
 248 |     |      * The VPToken (or some other contract) that owns this VPContract.
 249 |     |      * All state changing methods may be called only from this address.
 250 |     |      * This is because original msg.sender is sent in `_from` parameter
 251 |     |      * and we must be sure that it cannot be faked by directly calling VPContract.
 252 |     |      * Owner token is also used in case of replacement to recover vote powers from balances.
 253 |     |      */
 254 |     |     function ownerToken() external view returns (IVPToken);
 255 |     | 
 256 |     |     /**
 257 |     |      * Return true if this IIVPContract is configured to be used as a replacement for other contract.
 258 |     |      * It means that vote powers are not necessarily correct at the initialization, therefore
 259 |     |      * every method that reads vote power must check whether it is initialized for that address and block.
 260 |     |      */
 261 |     |     function isReplacement() external view returns (bool);
 262 |     | }
 263 |     | 

/Users/amac/code/flare/flux/node_modules/@flarenetwork/flare-periphery-contracts/coston2/token/interfaces/IIVPToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.7.6 <0.9;
  3 |     | 
  4 |     | import "../../IVPToken.sol";
  5 |     | import "../../IGovernanceVotePower.sol";
  6 |     | import "./IIVPContract.sol";
  7 |     | import "./IIGovernanceVotePower.sol";
  8 |     | import "./IICleanable.sol";
  9 |     | 
 10 |     | interface IIVPToken is IVPToken, IICleanable {
 11 |     |     /**
 12 |     |      * Set the contract that is allowed to set cleanupBlockNumber.
 13 |     |      * Usually this will be an instance of CleanupBlockNumberManager.
 14 |     |      */
 15 |     |     function setCleanupBlockNumberManager(
 16 |     |         address _cleanupBlockNumberManager
 17 |     |     ) external;
 18 |     | 
 19 |     |     /**
 20 |     |      * Sets new governance vote power contract that allows token owners to participate in governance voting
 21 |     |      * and delegate governance vote power.
 22 |     |      */
 23 |     |     function setGovernanceVotePower(
 24 |     |         IIGovernanceVotePower _governanceVotePower
 25 |     |     ) external;
 26 |     | 
 27 |     |     /**
 28 |     |      * @notice Get the total vote power at block `_blockNumber` using cache.
 29 |     |      *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.
 30 |     |      *   Can only be used if `_blockNumber` is in the past, otherwise reverts.
 31 |     |      * @param _blockNumber The block number at which to fetch.
 32 |     |      * @return The total vote power at the block (sum of all accounts' vote powers).
 33 |     |      */
 34 |     |     function totalVotePowerAtCached(
 35 |     |         uint256 _blockNumber
 36 |     |     ) external returns (uint256);
 37 |     | 
 38 |     |     /**
 39 |     |      * @notice Get the vote power of `_owner` at block `_blockNumber` using cache.
 40 |     |      *   It tries to read the cached value and if not found, reads the actual value and stores it in cache.
 41 |     |      *   Can only be used if _blockNumber is in the past, otherwise reverts.
 42 |     |      * @param _owner The address to get voting power.
 43 |     |      * @param _blockNumber The block number at which to fetch.
 44 |     |      * @return Vote power of `_owner` at `_blockNumber`.
 45 |     |      */
 46 |     |     function votePowerOfAtCached(
 47 |     |         address _owner,
 48 |     |         uint256 _blockNumber
 49 |     |     ) external returns (uint256);
 50 |     | 
 51 |     |     /**
 52 |     |      * Return vote powers for several addresses in a batch.
 53 |     |      * @param _owners The list of addresses to fetch vote power of.
 54 |     |      * @param _blockNumber The block number at which to fetch.
 55 |     |      * @return A list of vote powers.
 56 |     |      */
 57 |     |     function batchVotePowerOfAt(
 58 |     |         address[] memory _owners,
 59 |     |         uint256 _blockNumber
 60 |     |     ) external view returns (uint256[] memory);
 61 |     | }
 62 |     | 

/Users/amac/code/flare/flux/node_modules/@openzeppelin/contracts/interfaces/IERC1363.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)
  3 |     | 
  4 |     | pragma solidity >=0.6.2;
  5 |     | 
  6 |     | import {IERC20} from "./IERC20.sol";
  7 |     | import {IERC165} from "./IERC165.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @title IERC1363
 11 |     |  * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].
 12 |     |  *
 13 |     |  * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract
 14 |     |  * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.
 15 |     |  */
 16 |     | interface IERC1363 is IERC20, IERC165 {
 17 |     |     /*
 18 |     |      * Note: the ERC-165 identifier for this interface is 0xb0202a11.
 19 |     |      * 0xb0202a11 ===
 20 |     |      *   bytes4(keccak256('transferAndCall(address,uint256)')) ^
 21 |     |      *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^
 22 |     |      *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^
 23 |     |      *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^
 24 |     |      *   bytes4(keccak256('approveAndCall(address,uint256)')) ^
 25 |     |      *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))
 26 |     |      */
 27 |     | 
 28 |     |     /**
 29 |     |      * @dev Moves a `value` amount of tokens from the caller's account to `to`
 30 |     |      * and then calls {IERC1363Receiver-onTransferReceived} on `to`.
 31 |     |      * @param to The address which you want to transfer to.
 32 |     |      * @param value The amount of tokens to be transferred.
 33 |     |      * @return A boolean value indicating whether the operation succeeded unless throwing.
 34 |     |      */
 35 |     |     function transferAndCall(address to, uint256 value) external returns (bool);
 36 |     | 
 37 |     |     /**
 38 |     |      * @dev Moves a `value` amount of tokens from the caller's account to `to`
 39 |     |      * and then calls {IERC1363Receiver-onTransferReceived} on `to`.
 40 |     |      * @param to The address which you want to transfer to.
 41 |     |      * @param value The amount of tokens to be transferred.
 42 |     |      * @param data Additional data with no specified format, sent in call to `to`.
 43 |     |      * @return A boolean value indicating whether the operation succeeded unless throwing.
 44 |     |      */
 45 |     |     function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism
 49 |     |      * and then calls {IERC1363Receiver-onTransferReceived} on `to`.
 50 |     |      * @param from The address which you want to send tokens from.
 51 |     |      * @param to The address which you want to transfer to.
 52 |     |      * @param value The amount of tokens to be transferred.
 53 |     |      * @return A boolean value indicating whether the operation succeeded unless throwing.
 54 |     |      */
 55 |     |     function transferFromAndCall(address from, address to, uint256 value) external returns (bool);
 56 |     | 
 57 |     |     /**
 58 |     |      * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism
 59 |     |      * and then calls {IERC1363Receiver-onTransferReceived} on `to`.
 60 |     |      * @param from The address which you want to send tokens from.
 61 |     |      * @param to The address which you want to transfer to.
 62 |     |      * @param value The amount of tokens to be transferred.
 63 |     |      * @param data Additional data with no specified format, sent in call to `to`.
 64 |     |      * @return A boolean value indicating whether the operation succeeded unless throwing.
 65 |     |      */
 66 |     |     function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
 70 |     |      * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.
 71 |     |      * @param spender The address which will spend the funds.
 72 |     |      * @param value The amount of tokens to be spent.
 73 |     |      * @return A boolean value indicating whether the operation succeeded unless throwing.
 74 |     |      */
 75 |     |     function approveAndCall(address spender, uint256 value) external returns (bool);
 76 |     | 
 77 |     |     /**
 78 |     |      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
 79 |     |      * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.
 80 |     |      * @param spender The address which will spend the funds.
 81 |     |      * @param value The amount of tokens to be spent.
 82 |     |      * @param data Additional data with no specified format, sent in call to `spender`.
 83 |     |      * @return A boolean value indicating whether the operation succeeded unless throwing.
 84 |     |      */
 85 |     |     function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);
 86 |     | }
 87 |     | 

/Users/amac/code/flare/flux/node_modules/@openzeppelin/contracts/interfaces/IERC165.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)
 3 |     | 
 4 |     | pragma solidity >=0.4.16;
 5 |     | 
 6 |     | import {IERC165} from "../utils/introspection/IERC165.sol";
 7 |     | 

/Users/amac/code/flare/flux/node_modules/@openzeppelin/contracts/interfaces/IERC20.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)
 3 |     | 
 4 |     | pragma solidity >=0.4.16;
 5 |     | 
 6 |     | import {IERC20} from "../token/ERC20/IERC20.sol";
 7 |     | 

/Users/amac/code/flare/flux/node_modules/@openzeppelin/contracts/interfaces/draft-IERC6093.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (interfaces/draft-IERC6093.sol)
   3 |     | pragma solidity >=0.8.4;
   4 |     | 
   5 |     | /**
   6 |     |  * @dev Standard ERC-20 Errors
   7 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.
   8 |     |  */
   9 |     | interface IERC20Errors {
  10 |     |     /**
  11 |     |      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
  12 |     |      * @param sender Address whose tokens are being transferred.
  13 |     |      * @param balance Current balance for the interacting account.
  14 |     |      * @param needed Minimum amount required to perform a transfer.
  15 |     |      */
  16 |     |     error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);
  17 |     | 
  18 |     |     /**
  19 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
  20 |     |      * @param sender Address whose tokens are being transferred.
  21 |     |      */
  22 |     |     error ERC20InvalidSender(address sender);
  23 |     | 
  24 |     |     /**
  25 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
  26 |     |      * @param receiver Address to which tokens are being transferred.
  27 |     |      */
  28 |     |     error ERC20InvalidReceiver(address receiver);
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Indicates a failure with the `spender`s `allowance`. Used in transfers.
  32 |     |      * @param spender Address that may be allowed to operate on tokens without being their owner.
  33 |     |      * @param allowance Amount of tokens a `spender` is allowed to operate with.
  34 |     |      * @param needed Minimum amount required to perform a transfer.
  35 |     |      */
  36 |     |     error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
  40 |     |      * @param approver Address initiating an approval operation.
  41 |     |      */
  42 |     |     error ERC20InvalidApprover(address approver);
  43 |     | 
  44 |     |     /**
  45 |     |      * @dev Indicates a failure with the `spender` to be approved. Used in approvals.
  46 |     |      * @param spender Address that may be allowed to operate on tokens without being their owner.
  47 |     |      */
  48 |     |     error ERC20InvalidSpender(address spender);
  49 |     | }
  50 |     | 
  51 |     | /**
  52 |     |  * @dev Standard ERC-721 Errors
  53 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.
  54 |     |  */
  55 |     | interface IERC721Errors {
  56 |     |     /**
  57 |     |      * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.
  58 |     |      * Used in balance queries.
  59 |     |      * @param owner Address of the current owner of a token.
  60 |     |      */
  61 |     |     error ERC721InvalidOwner(address owner);
  62 |     | 
  63 |     |     /**
  64 |     |      * @dev Indicates a `tokenId` whose `owner` is the zero address.
  65 |     |      * @param tokenId Identifier number of a token.
  66 |     |      */
  67 |     |     error ERC721NonexistentToken(uint256 tokenId);
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Indicates an error related to the ownership over a particular token. Used in transfers.
  71 |     |      * @param sender Address whose tokens are being transferred.
  72 |     |      * @param tokenId Identifier number of a token.
  73 |     |      * @param owner Address of the current owner of a token.
  74 |     |      */
  75 |     |     error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
  79 |     |      * @param sender Address whose tokens are being transferred.
  80 |     |      */
  81 |     |     error ERC721InvalidSender(address sender);
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
  85 |     |      * @param receiver Address to which tokens are being transferred.
  86 |     |      */
  87 |     |     error ERC721InvalidReceiver(address receiver);
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Indicates a failure with the `operator`s approval. Used in transfers.
  91 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
  92 |     |      * @param tokenId Identifier number of a token.
  93 |     |      */
  94 |     |     error ERC721InsufficientApproval(address operator, uint256 tokenId);
  95 |     | 
  96 |     |     /**
  97 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
  98 |     |      * @param approver Address initiating an approval operation.
  99 |     |      */
 100 |     |     error ERC721InvalidApprover(address approver);
 101 |     | 
 102 |     |     /**
 103 |     |      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
 104 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 105 |     |      */
 106 |     |     error ERC721InvalidOperator(address operator);
 107 |     | }
 108 |     | 
 109 |     | /**
 110 |     |  * @dev Standard ERC-1155 Errors
 111 |     |  * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.
 112 |     |  */
 113 |     | interface IERC1155Errors {
 114 |     |     /**
 115 |     |      * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.
 116 |     |      * @param sender Address whose tokens are being transferred.
 117 |     |      * @param balance Current balance for the interacting account.
 118 |     |      * @param needed Minimum amount required to perform a transfer.
 119 |     |      * @param tokenId Identifier number of a token.
 120 |     |      */
 121 |     |     error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);
 122 |     | 
 123 |     |     /**
 124 |     |      * @dev Indicates a failure with the token `sender`. Used in transfers.
 125 |     |      * @param sender Address whose tokens are being transferred.
 126 |     |      */
 127 |     |     error ERC1155InvalidSender(address sender);
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Indicates a failure with the token `receiver`. Used in transfers.
 131 |     |      * @param receiver Address to which tokens are being transferred.
 132 |     |      */
 133 |     |     error ERC1155InvalidReceiver(address receiver);
 134 |     | 
 135 |     |     /**
 136 |     |      * @dev Indicates a failure with the `operator`s approval. Used in transfers.
 137 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 138 |     |      * @param owner Address of the current owner of a token.
 139 |     |      */
 140 |     |     error ERC1155MissingApprovalForAll(address operator, address owner);
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.
 144 |     |      * @param approver Address initiating an approval operation.
 145 |     |      */
 146 |     |     error ERC1155InvalidApprover(address approver);
 147 |     | 
 148 |     |     /**
 149 |     |      * @dev Indicates a failure with the `operator` to be approved. Used in approvals.
 150 |     |      * @param operator Address that may be allowed to operate on tokens without being their owner.
 151 |     |      */
 152 |     |     error ERC1155InvalidOperator(address operator);
 153 |     | 
 154 |     |     /**
 155 |     |      * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.
 156 |     |      * Used in batch transfers.
 157 |     |      * @param idsLength Length of the array of token identifiers
 158 |     |      * @param valuesLength Length of the array of token amounts
 159 |     |      */
 160 |     |     error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);
 161 |     | }
 162 |     | 

/Users/amac/code/flare/flux/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC20} from "./IERC20.sol";
   7 |     | import {IERC20Metadata} from "./extensions/IERC20Metadata.sol";
   8 |     | import {Context} from "../../utils/Context.sol";
   9 |     | import {IERC20Errors} from "../../interfaces/draft-IERC6093.sol";
  10 |     | 
  11 |     | /**
  12 |     |  * @dev Implementation of the {IERC20} interface.
  13 |     |  *
  14 |     |  * This implementation is agnostic to the way tokens are created. This means
  15 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC-20
  27 |     |  * applications.
  28 |     |  */
  29 |     | abstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {
  30 |     |     mapping(address account => uint256) private _balances;
  31 |     | 
  32 |     |     mapping(address account => mapping(address spender => uint256)) private _allowances;
  33 |     | 
  34 |     |     uint256 private _totalSupply;
  35 |     | 
  36 |     |     string private _name;
  37 |     |     string private _symbol;
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Sets the values for {name} and {symbol}.
  41 |     |      *
  42 |     |      * Both values are immutable: they can only be set once during construction.
  43 |     |      */
  44 |     |     constructor(string memory name_, string memory symbol_) {
  45 | *   |         _name = name_;
  46 | *   |         _symbol = symbol_;
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev Returns the name of the token.
  51 |     |      */
  52 | *   |     function name() public view virtual returns (string memory) {
  53 |     |         return _name;
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  58 |     |      * name.
  59 |     |      */
  60 |     |     function symbol() public view virtual returns (string memory) {
  61 |     |         return _symbol;
  62 |     |     }
  63 |     | 
  64 |     |     /**
  65 |     |      * @dev Returns the number of decimals used to get its user representation.
  66 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  67 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  68 |     |      *
  69 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  70 |     |      * Ether and Wei. This is the default value returned by this function, unless
  71 |     |      * it's overridden.
  72 |     |      *
  73 |     |      * NOTE: This information is only used for _display_ purposes: it in
  74 |     |      * no way affects any of the arithmetic of the contract, including
  75 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  76 |     |      */
  77 |     |     function decimals() public view virtual returns (uint8) {
  78 |     |         return 18;
  79 |     |     }
  80 |     | 
  81 |     |     /// @inheritdoc IERC20
  82 | *   |     function totalSupply() public view virtual returns (uint256) {
  83 |     |         return _totalSupply;
  84 |     |     }
  85 |     | 
  86 |     |     /// @inheritdoc IERC20
  87 | *   |     function balanceOf(address account) public view virtual returns (uint256) {
  88 | *   |         return _balances[account];
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-transfer}.
  93 |     |      *
  94 |     |      * Requirements:
  95 |     |      *
  96 |     |      * - `to` cannot be the zero address.
  97 |     |      * - the caller must have a balance of at least `value`.
  98 |     |      */
  99 | *   |     function transfer(address to, uint256 value) public virtual returns (bool) {
 100 |     |         address owner = _msgSender();
 101 | *   |         _transfer(owner, to, value);
 102 |     |         return true;
 103 |     |     }
 104 |     | 
 105 |     |     /// @inheritdoc IERC20
 106 |     |     function allowance(address owner, address spender) public view virtual returns (uint256) {
 107 | *   |         return _allowances[owner][spender];
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @dev See {IERC20-approve}.
 112 |     |      *
 113 |     |      * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on
 114 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 115 |     |      *
 116 |     |      * Requirements:
 117 |     |      *
 118 |     |      * - `spender` cannot be the zero address.
 119 |     |      */
 120 | *   |     function approve(address spender, uint256 value) public virtual returns (bool) {
 121 |     |         address owner = _msgSender();
 122 | *   |         _approve(owner, spender, value);
 123 | *   |         return true;
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-transferFrom}.
 128 |     |      *
 129 |     |      * Skips emitting an {Approval} event indicating an allowance update. This is not
 130 |     |      * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].
 131 |     |      *
 132 |     |      * NOTE: Does not update the allowance if the current allowance
 133 |     |      * is the maximum `uint256`.
 134 |     |      *
 135 |     |      * Requirements:
 136 |     |      *
 137 |     |      * - `from` and `to` cannot be the zero address.
 138 |     |      * - `from` must have a balance of at least `value`.
 139 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 140 |     |      * `value`.
 141 |     |      */
 142 | *   |     function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {
 143 |     |         address spender = _msgSender();
 144 | *   |         _spendAllowance(from, spender, value);
 145 | *   |         _transfer(from, to, value);
 146 | *   |         return true;
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Moves a `value` amount of tokens from `from` to `to`.
 151 |     |      *
 152 |     |      * This internal function is equivalent to {transfer}, and can be used to
 153 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 154 |     |      *
 155 |     |      * Emits a {Transfer} event.
 156 |     |      *
 157 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 158 |     |      */
 159 | *   |     function _transfer(address from, address to, uint256 value) internal {
 160 | *   |         if (from == address(0)) {
 161 |     |             revert ERC20InvalidSender(address(0));
 162 |     |         }
 163 | *   |         if (to == address(0)) {
 164 |     |             revert ERC20InvalidReceiver(address(0));
 165 |     |         }
 166 | *   |         _update(from, to, value);
 167 |     |     }
 168 |     | 
 169 |     |     /**
 170 |     |      * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`
 171 |     |      * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding
 172 |     |      * this function.
 173 |     |      *
 174 |     |      * Emits a {Transfer} event.
 175 |     |      */
 176 | *   |     function _update(address from, address to, uint256 value) internal virtual {
 177 | *   |         if (from == address(0)) {
 178 |     |             // Overflow check required: The rest of the code assumes that totalSupply never overflows
 179 | *   |             _totalSupply += value;
 180 |     |         } else {
 181 | *   |             uint256 fromBalance = _balances[from];
 182 | *   |             if (fromBalance < value) {
 183 | *   |                 revert ERC20InsufficientBalance(from, fromBalance, value);
 184 |     |             }
 185 |     |             unchecked {
 186 |     |                 // Overflow not possible: value <= fromBalance <= totalSupply.
 187 | *   |                 _balances[from] = fromBalance - value;
 188 |     |             }
 189 |     |         }
 190 |     | 
 191 | *   |         if (to == address(0)) {
 192 |     |             unchecked {
 193 |     |                 // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.
 194 |     |                 _totalSupply -= value;
 195 |     |             }
 196 |     |         } else {
 197 |     |             unchecked {
 198 |     |                 // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.
 199 | *   |                 _balances[to] += value;
 200 |     |             }
 201 |     |         }
 202 |     | 
 203 | *   |         emit Transfer(from, to, value);
 204 |     |     }
 205 |     | 
 206 |     |     /**
 207 |     |      * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).
 208 |     |      * Relies on the `_update` mechanism
 209 |     |      *
 210 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 211 |     |      *
 212 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead.
 213 |     |      */
 214 | *   |     function _mint(address account, uint256 value) internal {
 215 | *   |         if (account == address(0)) {
 216 |     |             revert ERC20InvalidReceiver(address(0));
 217 |     |         }
 218 | *   |         _update(address(0), account, value);
 219 |     |     }
 220 |     | 
 221 |     |     /**
 222 |     |      * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.
 223 |     |      * Relies on the `_update` mechanism.
 224 |     |      *
 225 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 226 |     |      *
 227 |     |      * NOTE: This function is not virtual, {_update} should be overridden instead
 228 |     |      */
 229 |     |     function _burn(address account, uint256 value) internal {
 230 |     |         if (account == address(0)) {
 231 |     |             revert ERC20InvalidSender(address(0));
 232 |     |         }
 233 |     |         _update(account, address(0), value);
 234 |     |     }
 235 |     | 
 236 |     |     /**
 237 |     |      * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.
 238 |     |      *
 239 |     |      * This internal function is equivalent to `approve`, and can be used to
 240 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 241 |     |      *
 242 |     |      * Emits an {Approval} event.
 243 |     |      *
 244 |     |      * Requirements:
 245 |     |      *
 246 |     |      * - `owner` cannot be the zero address.
 247 |     |      * - `spender` cannot be the zero address.
 248 |     |      *
 249 |     |      * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.
 250 |     |      */
 251 | *   |     function _approve(address owner, address spender, uint256 value) internal {
 252 | *   |         _approve(owner, spender, value, true);
 253 |     |     }
 254 |     | 
 255 |     |     /**
 256 |     |      * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.
 257 |     |      *
 258 |     |      * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by
 259 |     |      * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any
 260 |     |      * `Approval` event during `transferFrom` operations.
 261 |     |      *
 262 |     |      * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to
 263 |     |      * true using the following override:
 264 |     |      *
 265 |     |      * ```solidity
 266 |     |      * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {
 267 |     |      *     super._approve(owner, spender, value, true);
 268 |     |      * }
 269 |     |      * ```
 270 |     |      *
 271 |     |      * Requirements are the same as {_approve}.
 272 |     |      */
 273 | *   |     function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {
 274 | *   |         if (owner == address(0)) {
 275 |     |             revert ERC20InvalidApprover(address(0));
 276 |     |         }
 277 | *   |         if (spender == address(0)) {
 278 |     |             revert ERC20InvalidSpender(address(0));
 279 |     |         }
 280 | *   |         _allowances[owner][spender] = value;
 281 | *   |         if (emitEvent) {
 282 | *   |             emit Approval(owner, spender, value);
 283 |     |         }
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev Updates `owner`'s allowance for `spender` based on spent `value`.
 288 |     |      *
 289 |     |      * Does not update the allowance value in case of infinite allowance.
 290 |     |      * Revert if not enough allowance is available.
 291 |     |      *
 292 |     |      * Does not emit an {Approval} event.
 293 |     |      */
 294 | *   |     function _spendAllowance(address owner, address spender, uint256 value) internal virtual {
 295 | *   |         uint256 currentAllowance = allowance(owner, spender);
 296 | *   |         if (currentAllowance < type(uint256).max) {
 297 |     |             if (currentAllowance < value) {
 298 | *   |                 revert ERC20InsufficientAllowance(spender, currentAllowance, value);
 299 |     |             }
 300 |     |             unchecked {
 301 | *   |                 _approve(owner, spender, currentAllowance - value, false);
 302 |     |             }
 303 |     |         }
 304 |     |     }
 305 |     | }
 306 |     | 

/Users/amac/code/flare/flux/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity >=0.4.16;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC-20 standard as defined in the ERC.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the value of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the value of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves a `value` amount of tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 value) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets a `value` amount of tokens as the allowance of `spender` over the
 54 |     |      * caller's tokens.
 55 |     |      *
 56 |     |      * Returns a boolean value indicating whether the operation succeeded.
 57 |     |      *
 58 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 59 |     |      * that someone may use both the old and the new allowance by unfortunate
 60 |     |      * transaction ordering. One possible solution to mitigate this race
 61 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 62 |     |      * desired value afterwards:
 63 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 64 |     |      *
 65 |     |      * Emits an {Approval} event.
 66 |     |      */
 67 |     |     function approve(address spender, uint256 value) external returns (bool);
 68 |     | 
 69 |     |     /**
 70 |     |      * @dev Moves a `value` amount of tokens from `from` to `to` using the
 71 |     |      * allowance mechanism. `value` is then deducted from the caller's
 72 |     |      * allowance.
 73 |     |      *
 74 |     |      * Returns a boolean value indicating whether the operation succeeded.
 75 |     |      *
 76 |     |      * Emits a {Transfer} event.
 77 |     |      */
 78 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
 79 |     | }
 80 |     | 

/Users/amac/code/flare/flux/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity >=0.6.2;
  5 |     | 
  6 |     | import {IERC20} from "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC-20 standard.
 10 |     |  */
 11 |     | interface IERC20Metadata is IERC20 {
 12 |     |     /**
 13 |     |      * @dev Returns the name of the token.
 14 |     |      */
 15 |     |     function name() external view returns (string memory);
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the symbol of the token.
 19 |     |      */
 20 |     |     function symbol() external view returns (string memory);
 21 |     | 
 22 |     |     /**
 23 |     |      * @dev Returns the decimals places of the token.
 24 |     |      */
 25 |     |     function decimals() external view returns (uint8);
 26 |     | }
 27 |     | 

/Users/amac/code/flare/flux/node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.20;
   5 |     | 
   6 |     | import {IERC20} from "../IERC20.sol";
   7 |     | import {IERC1363} from "../../../interfaces/IERC1363.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title SafeERC20
  11 |     |  * @dev Wrappers around ERC-20 operations that throw on failure (when the token
  12 |     |  * contract returns false). Tokens that return no value (and instead revert or
  13 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  14 |     |  * successful.
  15 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  16 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  17 |     |  */
  18 |     | library SafeERC20 {
  19 |     |     /**
  20 |     |      * @dev An operation with an ERC-20 token failed.
  21 |     |      */
  22 |     |     error SafeERC20FailedOperation(address token);
  23 |     | 
  24 |     |     /**
  25 |     |      * @dev Indicates a failed `decreaseAllowance` request.
  26 |     |      */
  27 |     |     error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);
  28 |     | 
  29 |     |     /**
  30 |     |      * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
  31 |     |      * non-reverting calls are assumed to be successful.
  32 |     |      */
  33 | *   |     function safeTransfer(IERC20 token, address to, uint256 value) internal {
  34 | *   |         _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));
  35 |     |     }
  36 |     | 
  37 |     |     /**
  38 |     |      * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
  39 |     |      * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
  40 |     |      */
  41 | *   |     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
  42 | *   |         _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));
  43 |     |     }
  44 |     | 
  45 |     |     /**
  46 |     |      * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.
  47 |     |      */
  48 |     |     function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {
  49 |     |         return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));
  50 |     |     }
  51 |     | 
  52 |     |     /**
  53 |     |      * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.
  54 |     |      */
  55 |     |     function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {
  56 |     |         return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  61 |     |      * non-reverting calls are assumed to be successful.
  62 |     |      *
  63 |     |      * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the "client"
  64 |     |      * smart contract uses ERC-7674 to set temporary allowances, then the "client" smart contract should avoid using
  65 |     |      * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract
  66 |     |      * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.
  67 |     |      */
  68 |     |     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  69 |     |         uint256 oldAllowance = token.allowance(address(this), spender);
  70 |     |         forceApprove(token, spender, oldAllowance + value);
  71 |     |     }
  72 |     | 
  73 |     |     /**
  74 |     |      * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no
  75 |     |      * value, non-reverting calls are assumed to be successful.
  76 |     |      *
  77 |     |      * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the "client"
  78 |     |      * smart contract uses ERC-7674 to set temporary allowances, then the "client" smart contract should avoid using
  79 |     |      * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract
  80 |     |      * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.
  81 |     |      */
  82 |     |     function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {
  83 |     |         unchecked {
  84 |     |             uint256 currentAllowance = token.allowance(address(this), spender);
  85 |     |             if (currentAllowance < requestedDecrease) {
  86 |     |                 revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);
  87 |     |             }
  88 |     |             forceApprove(token, spender, currentAllowance - requestedDecrease);
  89 |     |         }
  90 |     |     }
  91 |     | 
  92 |     |     /**
  93 |     |      * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
  94 |     |      * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
  95 |     |      * to be set to zero before setting it to a non-zero value, such as USDT.
  96 |     |      *
  97 |     |      * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function
  98 |     |      * only sets the "standard" allowance. Any temporary allowance will remain active, in addition to the value being
  99 |     |      * set here.
 100 |     |      */
 101 |     |     function forceApprove(IERC20 token, address spender, uint256 value) internal {
 102 |     |         bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));
 103 |     | 
 104 |     |         if (!_callOptionalReturnBool(token, approvalCall)) {
 105 |     |             _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));
 106 |     |             _callOptionalReturn(token, approvalCall);
 107 |     |         }
 108 |     |     }
 109 |     | 
 110 |     |     /**
 111 |     |      * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no
 112 |     |      * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when
 113 |     |      * targeting contracts.
 114 |     |      *
 115 |     |      * Reverts if the returned value is other than `true`.
 116 |     |      */
 117 |     |     function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {
 118 |     |         if (to.code.length == 0) {
 119 |     |             safeTransfer(token, to, value);
 120 |     |         } else if (!token.transferAndCall(to, value, data)) {
 121 |     |             revert SafeERC20FailedOperation(address(token));
 122 |     |         }
 123 |     |     }
 124 |     | 
 125 |     |     /**
 126 |     |      * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target
 127 |     |      * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when
 128 |     |      * targeting contracts.
 129 |     |      *
 130 |     |      * Reverts if the returned value is other than `true`.
 131 |     |      */
 132 |     |     function transferFromAndCallRelaxed(
 133 |     |         IERC1363 token,
 134 |     |         address from,
 135 |     |         address to,
 136 |     |         uint256 value,
 137 |     |         bytes memory data
 138 |     |     ) internal {
 139 |     |         if (to.code.length == 0) {
 140 |     |             safeTransferFrom(token, from, to, value);
 141 |     |         } else if (!token.transferFromAndCall(from, to, value, data)) {
 142 |     |             revert SafeERC20FailedOperation(address(token));
 143 |     |         }
 144 |     |     }
 145 |     | 
 146 |     |     /**
 147 |     |      * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no
 148 |     |      * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when
 149 |     |      * targeting contracts.
 150 |     |      *
 151 |     |      * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.
 152 |     |      * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}
 153 |     |      * once without retrying, and relies on the returned value to be true.
 154 |     |      *
 155 |     |      * Reverts if the returned value is other than `true`.
 156 |     |      */
 157 |     |     function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {
 158 |     |         if (to.code.length == 0) {
 159 |     |             forceApprove(token, to, value);
 160 |     |         } else if (!token.approveAndCall(to, value, data)) {
 161 |     |             revert SafeERC20FailedOperation(address(token));
 162 |     |         }
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 167 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 168 |     |      * @param token The token targeted by the call.
 169 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 170 |     |      *
 171 |     |      * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.
 172 |     |      */
 173 | *   |     function _callOptionalReturn(IERC20 token, bytes memory data) private {
 174 | *   |         uint256 returnSize;
 175 | *   |         uint256 returnValue;
 176 |     |         assembly ("memory-safe") {
 177 | *   |             let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)
 178 |     |             // bubble errors
 179 | *   |             if iszero(success) {
 180 | *   |                 let ptr := mload(0x40)
 181 | *   |                 returndatacopy(ptr, 0, returndatasize())
 182 | *   |                 revert(ptr, returndatasize())
 183 |     |             }
 184 | *   |             returnSize := returndatasize()
 185 | *   |             returnValue := mload(0)
 186 |     |         }
 187 |     | 
 188 | *   |         if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {
 189 |     |             revert SafeERC20FailedOperation(address(token));
 190 |     |         }
 191 |     |     }
 192 |     | 
 193 |     |     /**
 194 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 195 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 196 |     |      * @param token The token targeted by the call.
 197 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 198 |     |      *
 199 |     |      * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.
 200 |     |      */
 201 |     |     function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
 202 |     |         bool success;
 203 |     |         uint256 returnSize;
 204 |     |         uint256 returnValue;
 205 |     |         assembly ("memory-safe") {
 206 |     |             success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)
 207 |     |             returnSize := returndatasize()
 208 |     |             returnValue := mload(0)
 209 |     |         }
 210 |     |         return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);
 211 |     |     }
 212 |     | }
 213 |     | 

/Users/amac/code/flare/flux/node_modules/@openzeppelin/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | 
 25 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 26 |     |         return 0;
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/amac/code/flare/flux/node_modules/@openzeppelin/contracts/utils/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.20;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  8 |     |  *
  9 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 10 |     |  * available, which can be applied to functions to make sure there are no nested
 11 |     |  * (reentrant) calls to them.
 12 |     |  *
 13 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 14 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 15 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 16 |     |  * points to them.
 17 |     |  *
 18 |     |  * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,
 19 |     |  * consider using {ReentrancyGuardTransient} instead.
 20 |     |  *
 21 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 22 |     |  * to protect against it, check out our blog post
 23 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 24 |     |  */
 25 |     | abstract contract ReentrancyGuard {
 26 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 27 |     |     // word because each write operation emits an extra SLOAD to first read the
 28 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 29 |     |     // back. This is the compiler's defense against contract upgrades and
 30 |     |     // pointer aliasing, and it cannot be disabled.
 31 |     | 
 32 |     |     // The values being non-zero value makes deployment a bit more expensive,
 33 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 34 |     |     // amount. Since refunds are capped to a percentage of the total
 35 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 36 |     |     // increase the likelihood of the full refund coming into effect.
 37 | *   |     uint256 private constant NOT_ENTERED = 1;
 38 | *   |     uint256 private constant ENTERED = 2;
 39 |     | 
 40 |     |     uint256 private _status;
 41 |     | 
 42 |     |     /**
 43 |     |      * @dev Unauthorized reentrant call.
 44 |     |      */
 45 |     |     error ReentrancyGuardReentrantCall();
 46 |     | 
 47 |     |     constructor() {
 48 | *   |         _status = NOT_ENTERED;
 49 |     |     }
 50 |     | 
 51 |     |     /**
 52 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 53 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 54 |     |      * function is not supported. It is possible to prevent this from happening
 55 |     |      * by making the `nonReentrant` function external, and making it call a
 56 |     |      * `private` function that does the actual work.
 57 |     |      */
 58 |     |     modifier nonReentrant() {
 59 | *   |         _nonReentrantBefore();
 60 | *   |         _;
 61 | *   |         _nonReentrantAfter();
 62 |     |     }
 63 |     | 
 64 | *   |     function _nonReentrantBefore() private {
 65 |     |         // On the first call to nonReentrant, _status will be NOT_ENTERED
 66 | *   |         if (_status == ENTERED) {
 67 |     |             revert ReentrancyGuardReentrantCall();
 68 |     |         }
 69 |     | 
 70 |     |         // Any calls to nonReentrant after this point will fail
 71 | *   |         _status = ENTERED;
 72 |     |     }
 73 |     | 
 74 | *   |     function _nonReentrantAfter() private {
 75 |     |         // By storing the original value once again, a refund is triggered (see
 76 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 77 | *   |         _status = NOT_ENTERED;
 78 |     |     }
 79 |     | 
 80 |     |     /**
 81 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
 82 |     |      * `nonReentrant` function in the call stack.
 83 |     |      */
 84 |     |     function _reentrancyGuardEntered() internal view returns (bool) {
 85 |     |         return _status == ENTERED;
 86 |     |     }
 87 |     | }
 88 |     | 

/Users/amac/code/flare/flux/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity >=0.4.16;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC-165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[ERC].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/Users/amac/code/flare/flux/contracts/PredictionDerivatives.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.25;
   3 |     | 
   4 |     | import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   5 |     | import { SafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
   6 |     | import { ReentrancyGuard } from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
   7 |     | import { IPredictionMarketOracle } from "./PredictionMarketOracle.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @title PredictionDerivatives
  11 |     |  * @notice Create leveraged positions on prediction market outcomes using Flare's FDC
  12 |     |  * @dev Enables users to go long/short on Polymarket outcomes with leverage
  13 |     |  *
  14 |     |  * Security considerations (Trail of Bits):
  15 |     |  * - Reentrancy protection on all state-changing functions
  16 |     |  * - Proper decimal handling for price calculations
  17 |     |  * - Maximum leverage caps to prevent excessive risk
  18 |     |  * - Liquidation mechanism to protect protocol solvency
  19 |     |  * - Oracle staleness checks before using price data
  20 |     |  * - Minimum position sizes to prevent dust attacks
  21 |     |  */
  22 |     | 
  23 |     | /// @notice Position direction
  24 |     | enum Direction {
  25 |     |     LONG_YES, // Betting YES price will increase
  26 |     |     LONG_NO, // Betting NO price will increase (same as SHORT_YES)
  27 |     |     SHORT_YES, // Betting YES price will decrease
  28 |     |     SHORT_NO // Betting NO price will decrease (same as LONG_YES)
  29 |     | }
  30 |     | 
  31 |     | /// @notice A leveraged position
  32 |     | struct Position {
  33 |     |     address owner;
  34 |     |     string marketId;
  35 |     |     Direction direction;
  36 |     |     uint256 collateral; // Collateral deposited (in stablecoin)
  37 |     |     uint256 leverage; // Leverage multiplier (1x = 10000, 2x = 20000, etc.)
  38 |     |     uint256 entryPrice; // Entry price in basis points
  39 |     |     uint256 size; // Position size = collateral * leverage
  40 |     |     uint256 openTimestamp;
  41 |     |     bool isOpen;
  42 |     | }
  43 |     | 
  44 |     | /// @notice Emitted when a position is opened
  45 |     | event PositionOpened(
  46 |     |     uint256 indexed positionId,
  47 |     |     address indexed owner,
  48 |     |     string marketId,
  49 |     |     Direction direction,
  50 |     |     uint256 collateral,
  51 |     |     uint256 leverage,
  52 |     |     uint256 entryPrice
  53 |     | );
  54 |     | 
  55 |     | /// @notice Emitted when a position is closed
  56 |     | event PositionClosed(uint256 indexed positionId, address indexed owner, uint256 exitPrice, int256 pnl);
  57 |     | 
  58 |     | /// @notice Emitted when a position is liquidated
  59 |     | event PositionLiquidated(uint256 indexed positionId, address indexed liquidator, uint256 exitPrice);
  60 |     | 
  61 |     | /**
  62 |     |  * @title IPredictionDerivatives
  63 |     |  * @notice Interface for prediction derivatives
  64 |     |  */
  65 |     | interface IPredictionDerivatives {
  66 |     |     function openPosition(
  67 |     |         string calldata marketId,
  68 |     |         Direction direction,
  69 |     |         uint256 collateral,
  70 |     |         uint256 leverage
  71 |     |     ) external returns (uint256 positionId);
  72 |     | 
  73 |     |     function closePosition(uint256 positionId) external returns (int256 pnl);
  74 |     |     function liquidatePosition(uint256 positionId) external;
  75 |     |     function getPosition(uint256 positionId) external view returns (Position memory);
  76 |     |     function calculatePnL(uint256 positionId) external view returns (int256 pnl);
  77 |     |     function isLiquidatable(uint256 positionId) external view returns (bool);
  78 |     | }
  79 |     | 
  80 |     | /**
  81 |     |  * @title PredictionDerivatives
  82 |     |  * @notice Main contract for prediction market derivatives
  83 |     |  */
  84 | *   | contract PredictionDerivatives is IPredictionDerivatives, ReentrancyGuard {
  85 |     |     using SafeERC20 for IERC20;
  86 |     | 
  87 |     |     /// @notice Basis points denominator (100% = 10000)
  88 | *   |     uint256 public constant BPS = 10000;
  89 |     | 
  90 |     |     /// @notice Maximum leverage allowed (5x)
  91 | *   |     uint256 public constant MAX_LEVERAGE = 50000;
  92 |     | 
  93 |     |     /// @notice Minimum leverage (1x)
  94 | *   |     uint256 public constant MIN_LEVERAGE = 10000;
  95 |     | 
  96 |     |     /// @notice Liquidation threshold (80% loss of collateral)
  97 | *   |     uint256 public constant LIQUIDATION_THRESHOLD = 8000;
  98 |     | 
  99 |     |     /// @notice Liquidation reward (5% of remaining collateral)
 100 | *   |     uint256 public constant LIQUIDATION_REWARD = 500;
 101 |     | 
 102 |     |     /// @notice Minimum collateral to open a position ($10)
 103 | *   |     uint256 public constant MIN_COLLATERAL = 10e6;
 104 |     | 
 105 |     |     /// @notice Maximum oracle staleness (1 hour)
 106 | *   |     uint256 public constant MAX_ORACLE_STALENESS = 1 hours;
 107 |     | 
 108 |     |     /// @notice Protocol fee (0.1%)
 109 | *   |     uint256 public constant PROTOCOL_FEE_BPS = 10;
 110 |     | 
 111 |     |     /// @notice The prediction market oracle
 112 |     |     IPredictionMarketOracle public immutable oracle;
 113 |     | 
 114 |     |     /// @notice The collateral token (USDC/stablecoin)
 115 |     |     IERC20 public immutable collateralToken;
 116 |     | 
 117 |     |     /// @notice Owner for admin functions
 118 |     |     address public owner;
 119 |     | 
 120 |     |     /// @notice Fee recipient
 121 |     |     address public feeRecipient;
 122 |     | 
 123 |     |     /// @notice Counter for position IDs
 124 | *   |     uint256 public nextPositionId;
 125 |     | 
 126 |     |     /// @notice Mapping of position ID to position data
 127 |     |     mapping(uint256 => Position) public positions;
 128 |     | 
 129 |     |     /// @notice Mapping of user address to their position IDs
 130 |     |     mapping(address => uint256[]) public userPositions;
 131 |     | 
 132 |     |     /// @notice Total protocol fees collected
 133 |     |     uint256 public totalFeesCollected;
 134 |     | 
 135 |     |     /// @notice Modifier to check oracle freshness
 136 |     |     modifier oracleFresh(string calldata marketId) {
 137 | *   |         require(oracle.isMarketDataFresh(marketId, MAX_ORACLE_STALENESS), "Oracle data stale");
 138 |     |         _;
 139 |     |     }
 140 |     | 
 141 |     |     /// @notice Modifier for owner-only functions
 142 |     |     modifier onlyOwner() {
 143 |     |         require(msg.sender == owner, "Only owner");
 144 |     |         _;
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @notice Constructor
 149 |     |      * @param oracleAddress The prediction market oracle address
 150 |     |      * @param collateralAddress The collateral token address (USDC)
 151 |     |      */
 152 | *   |     constructor(address oracleAddress, address collateralAddress) {
 153 | *   |         require(oracleAddress != address(0), "Invalid oracle");
 154 | *   |         require(collateralAddress != address(0), "Invalid collateral");
 155 |     | 
 156 | *   |         oracle = IPredictionMarketOracle(oracleAddress);
 157 | *   |         collateralToken = IERC20(collateralAddress);
 158 | *   |         owner = msg.sender;
 159 | *   |         feeRecipient = msg.sender;
 160 | *   |         nextPositionId = 1;
 161 |     |     }
 162 |     | 
 163 |     |     /**
 164 |     |      * @notice Open a new leveraged position
 165 |     |      * @param marketId The Polymarket market ID
 166 |     |      * @param direction The position direction (LONG_YES, LONG_NO, etc.)
 167 |     |      * @param collateral The collateral amount in collateral token units
 168 |     |      * @param leverage The leverage in basis points (10000 = 1x, 20000 = 2x)
 169 |     |      * @return positionId The ID of the newly created position
 170 |     |      */
 171 | *   |     function openPosition(
 172 |     |         string calldata marketId,
 173 |     |         Direction direction,
 174 |     |         uint256 collateral,
 175 |     |         uint256 leverage
 176 | *   |     ) external override nonReentrant oracleFresh(marketId) returns (uint256 positionId) {
 177 |     |         // Validate inputs
 178 | *   |         require(collateral >= MIN_COLLATERAL, "Collateral too low");
 179 | *   |         require(leverage >= MIN_LEVERAGE, "Leverage too low");
 180 | *   |         require(leverage <= MAX_LEVERAGE, "Leverage too high");
 181 |     | 
 182 |     |         // Get entry price from oracle
 183 | *   |         uint256 entryPrice = _getEntryPrice(marketId, direction);
 184 |     | 
 185 |     |         // Calculate net collateral after fee
 186 | *   |         uint256 netCollateral = _processCollateral(collateral);
 187 |     | 
 188 |     |         // Create and store position
 189 | *   |         positionId = _createPosition(marketId, direction, netCollateral, leverage, entryPrice);
 190 |     | 
 191 | *   |         emit PositionOpened(positionId, msg.sender, marketId, direction, netCollateral, leverage, entryPrice);
 192 |     |     }
 193 |     | 
 194 |     |     /**
 195 |     |      * @notice Get entry price from oracle for a direction
 196 |     |      */
 197 | *   |     function _getEntryPrice(string calldata marketId, Direction direction) internal view returns (uint256) {
 198 | *   |         (uint256 yesPrice, uint256 noPrice) = oracle.getLatestPrice(marketId);
 199 | *   |         return _getDirectionalPrice(direction, yesPrice, noPrice);
 200 |     |     }
 201 |     | 
 202 |     |     /**
 203 |     |      * @notice Process collateral transfer and fee deduction
 204 |     |      */
 205 | *   |     function _processCollateral(uint256 collateral) internal returns (uint256) {
 206 | *   |         uint256 fee = (collateral * PROTOCOL_FEE_BPS) / BPS;
 207 | *   |         collateralToken.safeTransferFrom(msg.sender, address(this), collateral);
 208 | *   |         totalFeesCollected += fee;
 209 | *   |         return collateral - fee;
 210 |     |     }
 211 |     | 
 212 |     |     /**
 213 |     |      * @notice Create and store a new position
 214 |     |      */
 215 | *   |     function _createPosition(
 216 |     |         string calldata marketId,
 217 |     |         Direction direction,
 218 |     |         uint256 netCollateral,
 219 |     |         uint256 leverage,
 220 |     |         uint256 entryPrice
 221 | *   |     ) internal returns (uint256 positionId) {
 222 | *   |         positionId = nextPositionId++;
 223 | *   |         uint256 size = (netCollateral * leverage) / BPS;
 224 |     | 
 225 | *   |         positions[positionId] = Position({
 226 | *   |             owner: msg.sender,
 227 | *   |             marketId: marketId,
 228 | *   |             direction: direction,
 229 |     |             collateral: netCollateral,
 230 |     |             leverage: leverage,
 231 |     |             entryPrice: entryPrice,
 232 |     |             size: size,
 233 | *   |             openTimestamp: block.timestamp,
 234 | *   |             isOpen: true
 235 |     |         });
 236 |     | 
 237 | *   |         userPositions[msg.sender].push(positionId);
 238 |     |     }
 239 |     | 
 240 |     |     /**
 241 |     |      * @notice Close an open position
 242 |     |      * @param positionId The position ID to close
 243 |     |      * @return pnl The profit/loss in collateral token units
 244 |     |      */
 245 | *   |     function closePosition(uint256 positionId) external override nonReentrant returns (int256 pnl) {
 246 | *   |         Position storage position = positions[positionId];
 247 | *   |         require(position.isOpen, "Position not open");
 248 | *   |         require(position.owner == msg.sender, "Not position owner");
 249 |     | 
 250 |     |         // Get current price
 251 | *   |         (uint256 yesPrice, uint256 noPrice) = oracle.getLatestPrice(position.marketId);
 252 | *   |         uint256 exitPrice = _getDirectionalPrice(position.direction, yesPrice, noPrice);
 253 |     | 
 254 |     |         // Calculate PnL
 255 | *   |         pnl = _calculatePnL(position, exitPrice);
 256 |     | 
 257 |     |         // Calculate payout
 258 | *   |         int256 payout = int256(position.collateral) + pnl;
 259 | *   |         uint256 payoutAmount = payout > 0 ? uint256(payout) : 0;
 260 |     | 
 261 |     |         // Close position
 262 | *   |         position.isOpen = false;
 263 |     | 
 264 |     |         // Transfer payout
 265 | *   |         if (payoutAmount > 0) {
 266 | *   |             collateralToken.safeTransfer(msg.sender, payoutAmount);
 267 |     |         }
 268 |     | 
 269 | *   |         emit PositionClosed(positionId, msg.sender, exitPrice, pnl);
 270 |     |     }
 271 |     | 
 272 |     |     /**
 273 |     |      * @notice Liquidate an underwater position
 274 |     |      * @param positionId The position ID to liquidate
 275 |     |      */
 276 | *   |     function liquidatePosition(uint256 positionId) external override nonReentrant {
 277 | *   |         Position storage position = positions[positionId];
 278 | *   |         require(position.isOpen, "Position not open");
 279 | *   |         require(isLiquidatable(positionId), "Not liquidatable");
 280 |     | 
 281 |     |         // Get current price
 282 | *   |         (uint256 yesPrice, uint256 noPrice) = oracle.getLatestPrice(position.marketId);
 283 | *   |         uint256 exitPrice = _getDirectionalPrice(position.direction, yesPrice, noPrice);
 284 |     | 
 285 |     |         // Calculate liquidation reward
 286 | *   |         uint256 reward = (position.collateral * LIQUIDATION_REWARD) / BPS;
 287 |     | 
 288 |     |         // Close position
 289 | *   |         position.isOpen = false;
 290 |     | 
 291 |     |         // Pay liquidator
 292 | *   |         if (reward > 0) {
 293 | *   |             collateralToken.safeTransfer(msg.sender, reward);
 294 |     |         }
 295 |     | 
 296 | *   |         emit PositionLiquidated(positionId, msg.sender, exitPrice);
 297 |     |     }
 298 |     | 
 299 |     |     /**
 300 |     |      * @notice Get position details
 301 |     |      * @param positionId The position ID
 302 |     |      * @return The position struct
 303 |     |      */
 304 |     |     function getPosition(uint256 positionId) external view override returns (Position memory) {
 305 |     |         return positions[positionId];
 306 |     |     }
 307 |     | 
 308 |     |     /**
 309 |     |      * @notice Calculate unrealized PnL for a position
 310 |     |      * @param positionId The position ID
 311 |     |      * @return pnl The profit/loss in collateral token units
 312 |     |      */
 313 | *   |     function calculatePnL(uint256 positionId) external view override returns (int256 pnl) {
 314 | *   |         Position memory position = positions[positionId];
 315 | *   |         require(position.isOpen, "Position not open");
 316 |     | 
 317 | *   |         (uint256 yesPrice, uint256 noPrice) = oracle.getLatestPrice(position.marketId);
 318 | *   |         uint256 currentPrice = _getDirectionalPrice(position.direction, yesPrice, noPrice);
 319 |     | 
 320 | *   |         return _calculatePnL(position, currentPrice);
 321 |     |     }
 322 |     | 
 323 |     |     /**
 324 |     |      * @notice Check if a position can be liquidated
 325 |     |      * @param positionId The position ID
 326 |     |      * @return True if the position is liquidatable
 327 |     |      */
 328 | *   |     function isLiquidatable(uint256 positionId) public view override returns (bool) {
 329 | *   |         Position memory position = positions[positionId];
 330 | *   |         if (!position.isOpen) return false;
 331 |     | 
 332 | *   |         int256 pnl = this.calculatePnL(positionId);
 333 | *   |         int256 equity = int256(position.collateral) + pnl;
 334 |     | 
 335 |     |         // Liquidatable if equity is below liquidation threshold
 336 | *   |         int256 threshold = (int256(position.collateral) * int256(BPS - LIQUIDATION_THRESHOLD)) / int256(BPS);
 337 |     | 
 338 | *   |         return equity < threshold;
 339 |     |     }
 340 |     | 
 341 |     |     /**
 342 |     |      * @notice Get all positions for a user
 343 |     |      * @param user The user address
 344 |     |      * @return Array of position IDs
 345 |     |      */
 346 |     |     function getUserPositions(address user) external view returns (uint256[] memory) {
 347 |     |         return userPositions[user];
 348 |     |     }
 349 |     | 
 350 |     |     /**
 351 |     |      * @notice Withdraw accumulated fees
 352 |     |      */
 353 | *   |     function withdrawFees() external onlyOwner {
 354 |     |         uint256 fees = totalFeesCollected;
 355 |     |         totalFeesCollected = 0;
 356 | *   |         collateralToken.safeTransfer(feeRecipient, fees);
 357 |     |     }
 358 |     | 
 359 |     |     /**
 360 |     |      * @notice Set fee recipient
 361 |     |      * @param newRecipient The new fee recipient
 362 |     |      */
 363 |     |     function setFeeRecipient(address newRecipient) external onlyOwner {
 364 |     |         require(newRecipient != address(0), "Invalid address");
 365 |     |         feeRecipient = newRecipient;
 366 |     |     }
 367 |     | 
 368 |     |     /**
 369 |     |      * @notice Transfer ownership
 370 |     |      * @param newOwner The new owner
 371 |     |      */
 372 |     |     function transferOwnership(address newOwner) external onlyOwner {
 373 |     |         require(newOwner != address(0), "Invalid address");
 374 |     |         owner = newOwner;
 375 |     |     }
 376 |     | 
 377 |     |     /**
 378 |     |      * @notice Get the directional price based on position direction
 379 |     |      */
 380 | *   |     function _getDirectionalPrice(
 381 |     |         Direction direction,
 382 |     |         uint256 yesPrice,
 383 |     |         uint256 noPrice
 384 | *   |     ) internal pure returns (uint256) {
 385 | *   |         if (direction == Direction.LONG_YES || direction == Direction.SHORT_NO) {
 386 | *   |             return yesPrice;
 387 |     |         } else {
 388 | *   |             return noPrice;
 389 |     |         }
 390 |     |     }
 391 |     | 
 392 |     |     /**
 393 |     |      * @notice Calculate PnL for a position
 394 |     |      */
 395 | *   |     function _calculatePnL(Position memory position, uint256 currentPrice) internal pure returns (int256) {
 396 |     |         int256 priceDiff;
 397 |     | 
 398 | *   |         if (position.direction == Direction.LONG_YES || position.direction == Direction.LONG_NO) {
 399 |     |             // Long: profit when price goes up
 400 | *   |             priceDiff = int256(currentPrice) - int256(position.entryPrice);
 401 |     |         } else {
 402 |     |             // Short: profit when price goes down
 403 | *   |             priceDiff = int256(position.entryPrice) - int256(currentPrice);
 404 |     |         }
 405 |     | 
 406 |     |         // PnL = size * price_change / entry_price
 407 |     |         // Using fixed point math with BPS precision
 408 | *   |         return (int256(position.size) * priceDiff) / int256(position.entryPrice);
 409 |     |     }
 410 |     | }
 411 |     | 

/Users/amac/code/flare/flux/contracts/PredictionMarketOracle.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.25;
   3 |     | 
   4 |     | import { ContractRegistry } from "@flarenetwork/flare-periphery-contracts/coston2/ContractRegistry.sol";
   5 |     | import { IWeb2Json } from "@flarenetwork/flare-periphery-contracts/coston2/IWeb2Json.sol";
   6 |     | import { IFdcVerification } from "@flarenetwork/flare-periphery-contracts/coston2/IFdcVerification.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @title PredictionMarketOracle
  10 |     |  * @notice Fetches prediction market data from Polymarket via FDC Web2Json attestations
  11 |     |  * @dev Uses Flare Data Connector to bring off-chain prediction market data on-chain
  12 |     |  *
  13 |     |  * Security considerations (Trail of Bits):
  14 |     |  * - All external data must be verified via FDC proof
  15 |     |  * - Price data is bounded to prevent manipulation
  16 |     |  * - Staleness checks prevent use of outdated data
  17 |     |  * - Access control for oracle updates
  18 |     |  */
  19 |     | 
  20 |     | /// @notice Data structure for a prediction market from Polymarket API
  21 |     | struct MarketData {
  22 |     |     string marketId;
  23 |     |     string question;
  24 |     |     uint256 yesPrice; // Price in basis points (0-10000 = 0-100%)
  25 |     |     uint256 noPrice; // Price in basis points (0-10000 = 0-100%)
  26 |     |     uint256 volume; // Total volume in USD (scaled by 1e6)
  27 |     |     uint256 liquidity; // Current liquidity in USD (scaled by 1e6)
  28 |     |     uint256 timestamp; // When this data was fetched
  29 |     | }
  30 |     | 
  31 |     | /// @notice Data transport object matching the JQ transformation output
  32 |     | struct MarketDTO {
  33 |     |     string marketId;
  34 |     |     string question;
  35 |     |     uint256 yesPrice;
  36 |     |     uint256 noPrice;
  37 |     |     uint256 volume;
  38 |     |     uint256 liquidity;
  39 |     | }
  40 |     | 
  41 |     | /// @notice Emitted when new market data is stored
  42 |     | event MarketDataUpdated(string indexed marketId, uint256 yesPrice, uint256 noPrice, uint256 volume, uint256 timestamp);
  43 |     | 
  44 |     | /// @notice Emitted when a market is added to the whitelist
  45 |     | event MarketWhitelisted(string indexed marketId);
  46 |     | 
  47 |     | /// @notice Emitted when a market is removed from the whitelist
  48 |     | event MarketDelisted(string indexed marketId);
  49 |     | 
  50 |     | /**
  51 |     |  * @title IPredictionMarketOracle
  52 |     |  * @notice Interface for the prediction market oracle
  53 |     |  */
  54 |     | interface IPredictionMarketOracle {
  55 |     |     function updateMarketData(IWeb2Json.Proof calldata proof) external;
  56 |     |     function getMarketData(string calldata marketId) external view returns (MarketData memory);
  57 |     |     function getLatestPrice(string calldata marketId) external view returns (uint256 yesPrice, uint256 noPrice);
  58 |     |     function isMarketDataFresh(string calldata marketId, uint256 maxAge) external view returns (bool);
  59 |     | }
  60 |     | 
  61 |     | /**
  62 |     |  * @title PredictionMarketOracle
  63 |     |  * @notice Oracle contract that stores verified prediction market data from Polymarket
  64 |     |  */
  65 |     | contract PredictionMarketOracle is IPredictionMarketOracle {
  66 |     |     /// @notice Maximum allowed price in basis points (100%)
  67 |     |     uint256 public constant MAX_PRICE_BPS = 10000;
  68 |     | 
  69 |     |     /// @notice Minimum liquidity required to accept market data (prevents low-liquidity manipulation)
  70 |     |     uint256 public constant MIN_LIQUIDITY = 1000e6; // $1000 minimum liquidity
  71 |     | 
  72 |     |     /// @notice Maximum staleness for market data (24 hours)
  73 |     |     uint256 public constant MAX_STALENESS = 24 hours;
  74 |     | 
  75 |     |     /// @notice Owner address for admin functions
  76 |     |     address public owner;
  77 |     | 
  78 |     |     /// @notice Mapping of market ID to latest market data
  79 |     |     mapping(string => MarketData) public markets;
  80 |     | 
  81 |     |     /// @notice Mapping of market ID to whether it's whitelisted
  82 |     |     mapping(string => bool) public whitelistedMarkets;
  83 |     | 
  84 |     |     /// @notice Array of all market IDs that have been updated
  85 |     |     string[] public marketIds;
  86 |     | 
  87 |     |     /// @notice Mapping to check if market ID exists in array
  88 |     |     mapping(string => bool) private marketExists;
  89 |     | 
  90 |     |     /// @notice Modifier to restrict access to owner
  91 |     |     modifier onlyOwner() {
  92 |     |         require(msg.sender == owner, "Only owner");
  93 |     |         _;
  94 |     |     }
  95 |     | 
  96 |     |     /// @notice Constructor sets the deployer as owner
  97 |     |     constructor() {
  98 |     |         owner = msg.sender;
  99 |     |     }
 100 |     | 
 101 |     |     /**
 102 |     |      * @notice Update market data with a verified Web2Json proof from Polymarket API
 103 |     |      * @param proof The FDC Web2Json proof containing market data
 104 |     |      * @dev The proof must be valid and the market must pass all safety checks
 105 |     |      */
 106 |     |     function updateMarketData(IWeb2Json.Proof calldata proof) external override {
 107 |     |         // 1. Verify the FDC proof
 108 |     |         require(_isWeb2JsonProofValid(proof), "Invalid FDC proof");
 109 |     | 
 110 |     |         // 2. Decode the ABI-encoded data from the proof
 111 |     |         MarketDTO memory dto = abi.decode(proof.data.responseBody.abiEncodedData, (MarketDTO));
 112 |     | 
 113 |     |         // 3. Validate the data
 114 |     |         _validateMarketData(dto);
 115 |     | 
 116 |     |         // 4. Store the market data
 117 |     |         MarketData memory newData = MarketData({
 118 |     |             marketId: dto.marketId,
 119 |     |             question: dto.question,
 120 |     |             yesPrice: dto.yesPrice,
 121 |     |             noPrice: dto.noPrice,
 122 |     |             volume: dto.volume,
 123 |     |             liquidity: dto.liquidity,
 124 |     |             timestamp: block.timestamp
 125 |     |         });
 126 |     | 
 127 |     |         markets[dto.marketId] = newData;
 128 |     | 
 129 |     |         // Track market IDs
 130 |     |         if (!marketExists[dto.marketId]) {
 131 |     |             marketIds.push(dto.marketId);
 132 |     |             marketExists[dto.marketId] = true;
 133 |     |         }
 134 |     | 
 135 |     |         emit MarketDataUpdated(dto.marketId, dto.yesPrice, dto.noPrice, dto.volume, block.timestamp);
 136 |     |     }
 137 |     | 
 138 |     |     /**
 139 |     |      * @notice Get the full market data for a given market ID
 140 |     |      * @param marketId The Polymarket market ID
 141 |     |      * @return The market data struct
 142 |     |      */
 143 |     |     function getMarketData(string calldata marketId) external view override returns (MarketData memory) {
 144 |     |         require(markets[marketId].timestamp > 0, "Market not found");
 145 |     |         return markets[marketId];
 146 |     |     }
 147 |     | 
 148 |     |     /**
 149 |     |      * @notice Get just the latest prices for a market
 150 |     |      * @param marketId The Polymarket market ID
 151 |     |      * @return yesPrice The YES price in basis points
 152 |     |      * @return noPrice The NO price in basis points
 153 |     |      */
 154 |     |     function getLatestPrice(
 155 |     |         string calldata marketId
 156 |     |     ) external view override returns (uint256 yesPrice, uint256 noPrice) {
 157 |     |         MarketData memory data = markets[marketId];
 158 |     |         require(data.timestamp > 0, "Market not found");
 159 |     |         return (data.yesPrice, data.noPrice);
 160 |     |     }
 161 |     | 
 162 |     |     /**
 163 |     |      * @notice Check if market data is fresh enough
 164 |     |      * @param marketId The Polymarket market ID
 165 |     |      * @param maxAge Maximum allowed age in seconds
 166 |     |      * @return True if the data is fresh
 167 |     |      */
 168 |     |     function isMarketDataFresh(string calldata marketId, uint256 maxAge) external view override returns (bool) {
 169 |     |         MarketData memory data = markets[marketId];
 170 |     |         if (data.timestamp == 0) return false;
 171 |     |         return (block.timestamp - data.timestamp) <= maxAge;
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @notice Get all tracked market IDs
 176 |     |      * @return Array of market IDs
 177 |     |      */
 178 |     |     function getAllMarketIds() external view returns (string[] memory) {
 179 |     |         return marketIds;
 180 |     |     }
 181 |     | 
 182 |     |     /**
 183 |     |      * @notice Get the number of tracked markets
 184 |     |      * @return The count of markets
 185 |     |      */
 186 |     |     function getMarketCount() external view returns (uint256) {
 187 |     |         return marketIds.length;
 188 |     |     }
 189 |     | 
 190 |     |     /**
 191 |     |      * @notice Whitelist a market for derivatives trading
 192 |     |      * @param marketId The market ID to whitelist
 193 |     |      */
 194 |     |     function whitelistMarket(string calldata marketId) external onlyOwner {
 195 |     |         whitelistedMarkets[marketId] = true;
 196 |     |         emit MarketWhitelisted(marketId);
 197 |     |     }
 198 |     | 
 199 |     |     /**
 200 |     |      * @notice Remove a market from the whitelist
 201 |     |      * @param marketId The market ID to delist
 202 |     |      */
 203 |     |     function delistMarket(string calldata marketId) external onlyOwner {
 204 |     |         whitelistedMarkets[marketId] = false;
 205 |     |         emit MarketDelisted(marketId);
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @notice Transfer ownership
 210 |     |      * @param newOwner The new owner address
 211 |     |      */
 212 |     |     function transferOwnership(address newOwner) external onlyOwner {
 213 |     |         require(newOwner != address(0), "Invalid address");
 214 |     |         owner = newOwner;
 215 |     |     }
 216 |     | 
 217 |     |     /**
 218 |     |      * @notice Validate market data for safety
 219 |     |      * @param dto The market data to validate
 220 |     |      */
 221 |     |     function _validateMarketData(MarketDTO memory dto) internal pure {
 222 |     |         // Prices must be valid percentages (0-100%)
 223 |     |         require(dto.yesPrice <= MAX_PRICE_BPS, "YES price out of range");
 224 |     |         require(dto.noPrice <= MAX_PRICE_BPS, "NO price out of range");
 225 |     | 
 226 |     |         // YES + NO should approximately equal 100% (allow 5% tolerance for spread)
 227 |     |         uint256 totalPrice = dto.yesPrice + dto.noPrice;
 228 |     |         require(totalPrice >= 9500 && totalPrice <= 10500, "Price sum out of range");
 229 |     | 
 230 |     |         // Minimum liquidity check to prevent low-liquidity manipulation
 231 |     |         require(dto.liquidity >= MIN_LIQUIDITY, "Insufficient liquidity");
 232 |     |     }
 233 |     | 
 234 |     |     /**
 235 |     |      * @notice Verify a Web2Json proof via FDC
 236 |     |      * @param proof The proof to verify
 237 |     |      * @return True if valid
 238 |     |      */
 239 |     |     function _isWeb2JsonProofValid(IWeb2Json.Proof calldata proof) internal view returns (bool) {
 240 |     |         IFdcVerification fdc = ContractRegistry.getFdcVerification();
 241 |     |         return fdc.verifyWeb2Json(proof);
 242 |     |     }
 243 |     | 
 244 |     |     /**
 245 |     |      * @notice ABI signature helper for generating the correct encoding
 246 |     |      * @dev This function is never called, it just helps tooling generate correct ABI
 247 |     |      */
 248 |     |     function abiSignatureHelper(MarketDTO calldata dto) external pure {}
 249 |     | }
 250 |     | 

/Users/amac/code/flare/flux/contracts/mocks/MockERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.25;
  3 |     | 
  4 |     | import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  5 |     | 
  6 |     | /**
  7 |     |  * @title MockERC20
  8 |     |  * @notice Mock ERC20 token for testing purposes
  9 |     |  * @dev Only for use in tests - not for production
 10 |     |  */
 11 | *   | contract MockERC20 is ERC20 {
 12 |     |     uint8 private immutable _decimals;
 13 |     | 
 14 | *   |     constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_) {
 15 | *   |         _decimals = decimals_;
 16 |     |     }
 17 |     | 
 18 |     |     function decimals() public view override returns (uint8) {
 19 |     |         return _decimals;
 20 |     |     }
 21 |     | 
 22 | *   |     function mint(address to, uint256 amount) external {
 23 | *   |         _mint(to, amount);
 24 |     |     }
 25 |     | 
 26 |     |     function burn(address from, uint256 amount) external {
 27 |     |         _burn(from, amount);
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/amac/code/flare/flux/contracts/test/EchidnaTest.sol
   1 | *   | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.25;
   3 |     | 
   4 | *   | import "../PredictionDerivatives.sol";
   5 | *   | import "../PredictionMarketOracle.sol";
   6 | *   | import "../mocks/MockERC20.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @title MockOracle
  10 | *   |  * @notice Mock oracle for fuzzing tests
  11 | *   |  */
  12 | *   | contract MockOracle is IPredictionMarketOracle {
  13 | *   |     mapping(string => MarketData) public markets;
  14 |     | 
  15 | *   |     function setMarketData(string memory marketId, uint256 yesPrice, uint256 noPrice) external {
  16 | *   |         markets[marketId] = MarketData({
  17 | *   |             marketId: marketId,
  18 | *   |             question: "Test",
  19 | *   |             yesPrice: yesPrice,
  20 | *   |             noPrice: noPrice,
  21 | *   |             volume: 1000000e6,
  22 | *   |             liquidity: 1000000e6,
  23 | *   |             timestamp: block.timestamp
  24 | *   |         });
  25 | *   |     }
  26 | *   | 
  27 | *   |     function updateMarketData(IWeb2Json.Proof calldata) external override {}
  28 |     | 
  29 | *   |     function getMarketData(string calldata marketId) external view override returns (MarketData memory) {
  30 | *   |         return markets[marketId];
  31 | *   |     }
  32 |     | 
  33 | *   |     function getLatestPrice(string calldata marketId) external view override returns (uint256 yesPrice, uint256 noPrice) {
  34 | *   |         MarketData memory data = markets[marketId];
  35 | *   |         return (data.yesPrice, data.noPrice);
  36 | *   |     }
  37 |     | 
  38 | *   |     function isMarketDataFresh(string calldata, uint256) external pure override returns (bool) {
  39 | *   |         return true;
  40 |     |     }
  41 |     | }
  42 |     | 
  43 |     | /**
  44 | *   |  * @title EchidnaTest
  45 | *   |  * @notice Test harness for Echidna fuzzing
  46 | *   |  */
  47 | *   | contract EchidnaTest {
  48 | *   |     PredictionDerivatives public derivatives;
  49 | *   |     MockOracle public oracle;
  50 | *   |     MockERC20 public token;
  51 |     | 
  52 | *   |     string constant MARKET_ID = "test-market";
  53 |     | 
  54 | *   |     // Invariants tracking
  55 | *   |     uint256 public totalDeposited;
  56 | *   |     uint256 public totalWithdrawn;
  57 | *   | 
  58 | *   |     constructor() {
  59 | *   |         oracle = new MockOracle();
  60 | *   |         token = new MockERC20("USDC", "USDC", 6);
  61 | *   |         derivatives = new PredictionDerivatives(address(oracle), address(token));
  62 |     | 
  63 | *   |         // Setup initial market data
  64 | *   |         oracle.setMarketData(MARKET_ID, 5000, 5000);
  65 |     | 
  66 | *   |         // Mint tokens for testing
  67 | *   |         token.mint(address(this), 1000000e6);
  68 | *   |         token.approve(address(derivatives), type(uint256).max);
  69 |     |     }
  70 |     | 
  71 |     |     // ============ INVARIANT PROPERTIES ============
  72 |     | 
  73 |     |     /**
  74 |     |      * @notice Position collateral should never exceed deposited amount
  75 | *   |      */
  76 |     |     function echidna_position_collateral_bounded() public view returns (bool) {
  77 | *   |         uint256 nextId = derivatives.nextPositionId();
  78 |     |         for (uint256 i = 1; i < nextId; i++) {
  79 |     |             Position memory pos = derivatives.getPosition(i);
  80 |     |             if (pos.collateral > 1000000e6) {
  81 |     |                 return false;
  82 |     |             }
  83 |     |         }
  84 |     |         return true;
  85 |     |     }
  86 |     | 
  87 |     |     /**
  88 |     |      * @notice Leverage should always be within bounds
  89 | *   |      */
  90 | *   |     function echidna_leverage_within_bounds() public view returns (bool) {
  91 |     |         uint256 nextId = derivatives.nextPositionId();
  92 |     |         for (uint256 i = 1; i < nextId; i++) {
  93 | *   |             Position memory pos = derivatives.getPosition(i);
  94 | *   |             if (pos.isOpen) {
  95 | *   |                 if (pos.leverage < derivatives.MIN_LEVERAGE() ||
  96 | *   |                     pos.leverage > derivatives.MAX_LEVERAGE()) {
  97 | *   |                     return false;
  98 | *   |                 }
  99 |     |             }
 100 |     |         }
 101 | *   |         return true;
 102 |     |     }
 103 |     | 
 104 |     |     /**
 105 | *   |      * @notice Contract should never have negative balance (solvency)
 106 |     |      */
 107 | *   |     function echidna_contract_solvent() public view returns (bool) {
 108 | *   |         return token.balanceOf(address(derivatives)) >= 0;
 109 | *   |     }
 110 |     | 
 111 |     |     /**
 112 | *   |      * @notice Total fees should never exceed total deposited
 113 | *   |      */
 114 | *   |     function echidna_fees_bounded() public view returns (bool) {
 115 | *   |         return derivatives.totalFeesCollected() <= totalDeposited;
 116 | *   |     }
 117 |     | 
 118 |     |     /**
 119 | *   |      * @notice Position size should equal collateral * leverage / BPS
 120 |     |      */
 121 | *   |     function echidna_position_size_correct() public view returns (bool) {
 122 | *   |         uint256 nextId = derivatives.nextPositionId();
 123 |     |         for (uint256 i = 1; i < nextId; i++) {
 124 |     |             Position memory pos = derivatives.getPosition(i);
 125 | *   |             if (pos.isOpen) {
 126 | *   |                 uint256 expectedSize = (pos.collateral * pos.leverage) / derivatives.BPS();
 127 | *   |                 if (pos.size != expectedSize) {
 128 | *   |                     return false;
 129 | *   |                 }
 130 | *   |             }
 131 |     |         }
 132 | *   |         return true;
 133 |     |     }
 134 |     | 
 135 |     |     // ============ ACTIONS ============
 136 |     | 
 137 | *   |     function openLongYes(uint256 collateral, uint256 leverage) public {
 138 | *   |         collateral = _boundCollateral(collateral);
 139 | *   |         leverage = _boundLeverage(leverage);
 140 |     | 
 141 | *   |         try derivatives.openPosition(MARKET_ID, Direction.LONG_YES, collateral, leverage) {
 142 | *   |             totalDeposited += collateral;
 143 |     |         } catch {}
 144 |     |     }
 145 |     | 
 146 | *   |     function openLongNo(uint256 collateral, uint256 leverage) public {
 147 | *   |         collateral = _boundCollateral(collateral);
 148 | *   |         leverage = _boundLeverage(leverage);
 149 |     | 
 150 | *   |         try derivatives.openPosition(MARKET_ID, Direction.LONG_NO, collateral, leverage) {
 151 |     |             totalDeposited += collateral;
 152 |     |         } catch {}
 153 |     |     }
 154 |     | 
 155 | *   |     function openShortYes(uint256 collateral, uint256 leverage) public {
 156 | *   |         collateral = _boundCollateral(collateral);
 157 | *   |         leverage = _boundLeverage(leverage);
 158 |     | 
 159 | *   |         try derivatives.openPosition(MARKET_ID, Direction.SHORT_YES, collateral, leverage) {
 160 |     |             totalDeposited += collateral;
 161 |     |         } catch {}
 162 |     |     }
 163 |     | 
 164 | *   |     function openShortNo(uint256 collateral, uint256 leverage) public {
 165 | *   |         collateral = _boundCollateral(collateral);
 166 | *   |         leverage = _boundLeverage(leverage);
 167 |     | 
 168 | *   |         try derivatives.openPosition(MARKET_ID, Direction.SHORT_NO, collateral, leverage) {
 169 |     |             totalDeposited += collateral;
 170 |     |         } catch {}
 171 |     |     }
 172 |     | 
 173 | *   |     function closePosition(uint256 positionId) public {
 174 | *   |         positionId = _boundPositionId(positionId);
 175 |     | 
 176 | *   |         uint256 balanceBefore = token.balanceOf(address(this));
 177 | *   |         try derivatives.closePosition(positionId) {
 178 | *   |             uint256 balanceAfter = token.balanceOf(address(this));
 179 | *   |             if (balanceAfter > balanceBefore) {
 180 | *   |                 totalWithdrawn += balanceAfter - balanceBefore;
 181 |     |             }
 182 |     |         } catch {}
 183 |     |     }
 184 |     | 
 185 | *   |     function liquidatePosition(uint256 positionId) public {
 186 | *   |         positionId = _boundPositionId(positionId);
 187 |     | 
 188 | *   |         try derivatives.liquidatePosition(positionId) {
 189 |     |         } catch {}
 190 |     |     }
 191 |     | 
 192 | *   |     function updatePrice(uint256 yesPrice, uint256 noPrice) public {
 193 | *   |         yesPrice = yesPrice % 10001; // 0-10000
 194 | *   |         noPrice = 10000 - yesPrice; // Ensure they sum to 10000
 195 | *   |         oracle.setMarketData(MARKET_ID, yesPrice, noPrice);
 196 |     |     }
 197 |     | 
 198 |     |     // ============ HELPERS ============
 199 |     | 
 200 | *   |     function _boundCollateral(uint256 collateral) internal view returns (uint256) {
 201 | *   |         uint256 minCollateral = derivatives.MIN_COLLATERAL();
 202 | *   |         uint256 maxCollateral = 1000e6; // Max 1000 USDC per position
 203 | *   |         return minCollateral + (collateral % (maxCollateral - minCollateral));
 204 |     |     }
 205 |     | 
 206 | *   |     function _boundLeverage(uint256 leverage) internal view returns (uint256) {
 207 | *   |         uint256 minLev = derivatives.MIN_LEVERAGE();
 208 | *   |         uint256 maxLev = derivatives.MAX_LEVERAGE();
 209 | *   |         return minLev + (leverage % (maxLev - minLev + 1));
 210 | *   |     }
 211 |     | 
 212 | *   |     function _boundPositionId(uint256 positionId) internal view returns (uint256) {
 213 | *   |         uint256 nextId = derivatives.nextPositionId();
 214 | *   |         if (nextId <= 1) return 1;
 215 | *   |         return 1 + (positionId % (nextId - 1));
 216 |     |     }
 217 |     | }
 218 | *   | 

